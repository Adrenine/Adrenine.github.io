<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【LeetCode】Midian of Two Sorted Arrays</title>
    <link href="/post/98g2fd04.html"/>
    <url>/post/98g2fd04.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【LeetCode】系列目录"><a href="#【LeetCode】系列目录" class="headerlink" title="【LeetCode】系列目录"></a><a href="https://adrenine.github.io/post/d305db71.html">【LeetCode】系列目录</a></h3><hr><h3 id="LeetCode系列"><a href="#LeetCode系列" class="headerlink" title="LeetCode系列"></a><a href="https://adrenine.github.io/post/10fb75fe.html">LeetCode系列</a></h3><h4 id="Q：There-are-two-sorted-arrays-nums1-and-nums2-of-size-m-and-n-respectively-Find-the-median-of-the-two-sorted-arrays-The-overall-run-time-complexity-should-be-O-log-m-n"><a href="#Q：There-are-two-sorted-arrays-nums1-and-nums2-of-size-m-and-n-respectively-Find-the-median-of-the-two-sorted-arrays-The-overall-run-time-complexity-should-be-O-log-m-n" class="headerlink" title="Q：There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n))."></a>Q：There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</h4><p>You may assume nums1 and nums2 cannot be both empty.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">Example <span class="hljs-number">1</span>:<br><br>nums1 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]<br>nums2 = [<span class="hljs-number">2</span>]<br><br>The median is <span class="hljs-number">2.0</span><br>Example <span class="hljs-number">2</span>:<br><br>nums1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>nums2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>The median is (<span class="hljs-number">2</span> + <span class="hljs-number">3</span>)/<span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><span id="more"></span><hr><h4 id="E：这里有一个长度为m的有序数组nums1和长度为n的有序数组nums2。找到这两个有序数组的中位数，并且让时间复杂度为O-log-m-n-。"><a href="#E：这里有一个长度为m的有序数组nums1和长度为n的有序数组nums2。找到这两个有序数组的中位数，并且让时间复杂度为O-log-m-n-。" class="headerlink" title="E：这里有一个长度为m的有序数组nums1和长度为n的有序数组nums2。找到这两个有序数组的中位数，并且让时间复杂度为O(log(m+n))。"></a>E：这里有一个长度为m的有序数组nums1和长度为n的有序数组nums2。找到这两个有序数组的中位数，并且让时间复杂度为O(log(m+n))。</h4><p>你可以假设两个数组不可能同时为空。</p><h5 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">Example <span class="hljs-number">1</span>:<br><br>nums1 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]<br>nums2 = [<span class="hljs-number">2</span>]<br><br>The median is <span class="hljs-number">2.0</span><br>Example <span class="hljs-number">2</span>:<br><br>nums1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>nums2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>The median is (<span class="hljs-number">2</span> + <span class="hljs-number">3</span>)/<span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><hr><h4 id="A"><a href="#A" class="headerlink" title="A:"></a>A:</h4><h5 id="Approach-1："><a href="#Approach-1：" class="headerlink" title="Approach 1："></a>Approach 1：</h5><p>先不考虑时间复杂度，既然两个数组都是有序数组，那我们不就可以把两个数组合起来，然后取中位数吗，两个有序数组合并，其实就是归并排序的一个部分。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMedianSortedArrays</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">nums1</span> : [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">nums2</span> : [<span class="hljs-type">Int</span>])</span> -&gt; <span class="hljs-type">Double</span> &#123;<br>        <br>        <span class="hljs-keyword">let</span> m <span class="hljs-operator">=</span> nums1.count<br>        <span class="hljs-keyword">let</span> n <span class="hljs-operator">=</span> nums2.count<br>        <br>        <span class="hljs-keyword">var</span> nums <span class="hljs-operator">=</span> [<span class="hljs-type">Int</span>]()<br>        <br>        <span class="hljs-keyword">if</span> m <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123;<span class="hljs-comment">//num1为空数组</span><br>            <span class="hljs-keyword">if</span> n <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123;<span class="hljs-comment">//num元素为偶数个</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(nums2[n<span class="hljs-operator">/</span><span class="hljs-number">2</span> <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] <span class="hljs-operator">+</span> nums2[n<span class="hljs-operator">/</span><span class="hljs-number">2</span>]) <span class="hljs-operator">/</span> <span class="hljs-number">2.0</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(nums2[n<span class="hljs-operator">/</span><span class="hljs-number">2</span>])<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> n <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123;<span class="hljs-comment">//num2为空数组</span><br>            <span class="hljs-keyword">if</span> m <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(nums1[m<span class="hljs-operator">/</span><span class="hljs-number">2</span> <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] <span class="hljs-operator">+</span> nums1[m<span class="hljs-operator">/</span><span class="hljs-number">2</span>]) <span class="hljs-operator">/</span> <span class="hljs-number">2.0</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(nums1[m<span class="hljs-operator">/</span><span class="hljs-number">2</span>])<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">var</span> count : <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">var</span> i : <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">var</span> j : <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> count <span class="hljs-operator">&lt;</span> (m <span class="hljs-operator">+</span> n) &#123;<br>            <span class="hljs-keyword">if</span> i <span class="hljs-operator">==</span> m &#123;<span class="hljs-comment">//num1遍历完毕</span><br>                <span class="hljs-keyword">while</span> j <span class="hljs-operator">!=</span> n &#123; <span class="hljs-comment">//num2未遍历完毕</span><br>                    nums.append(nums2[j])<br>                    count <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>                    j <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>                &#125;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> j <span class="hljs-operator">==</span> n &#123; <span class="hljs-comment">//num2遍历完毕</span><br>                <span class="hljs-keyword">while</span> i <span class="hljs-operator">!=</span> m &#123;<span class="hljs-comment">//num1未遍历完毕</span><br>                    nums.append(nums1[i])<br>                    count <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>                    i <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>                &#125;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> nums1[i] <span class="hljs-operator">&lt;</span> nums2[j] &#123;<br>                nums.append(nums1[i])<br>                count <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>                i <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums.append(nums2[j])<br>                count <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>                j <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> count <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(nums[count<span class="hljs-operator">/</span><span class="hljs-number">2</span> <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] <span class="hljs-operator">+</span> nums[count<span class="hljs-operator">/</span><span class="hljs-number">2</span>]) <span class="hljs-operator">/</span> <span class="hljs-number">2.0</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(nums[count<span class="hljs-operator">/</span><span class="hljs-number">2</span>])<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Complexity-Analysis："><a href="#Complexity-Analysis：" class="headerlink" title="Complexity Analysis："></a>Complexity Analysis：</h5><ul><li>时间复杂度： O(m+n)。两个数组每个元素都要遍历一遍（m+n）</li><li>空间复杂度：O(m+n)。临时数组大小为（m+n）</li></ul><hr><h5 id="Approach-2："><a href="#Approach-2：" class="headerlink" title="Approach 2："></a>Approach 2：</h5><p>方法二是基于方法一的改进，从时间和空间上分别考虑并改进。</p><p>时间上，我们要找的是中位数，根据中位数的定义，我们没有必要将nums1和nums2两个数组整个遍历一遍，只要遍历两个数组长度总和一般的位置就可以结束，遍历次数可以少一半，但是时间复杂度还是和方法一一样。</p><p>空间上，我们需要找中位数，那对于两个数组总和为奇数时，我们需要获取<code>（m+n+1）/ 2</code>的那个元素，对于两个数组为偶数时，我们需要获取最后一次遍历的那个元素<code>（m+n）/ 2 +1</code>和他前面那个元素<code>（m+n）/ 2</code>。所以看看算法空间复杂度能不能保持在常量级。</p><p>首先明确一下遍历次数，假设<code>m+n = len</code>，对于两个数组和为奇数的时候，我们需要获取序号为<code>（len+1）/2</code>的元素，我们需要遍历<code>len / 2+1</code>次(Int计算，会抹去小数部分)；对于两个数组和为偶数的时候，我们需要获取<code>len / 2</code>的元素和<code>len / 2 +1</code>的两个元素，所以遍历次数也是<code>len / 2 + 1</code>次。所以不管是奇数还是偶数，我们的遍历次数都是<code>（m+n）/ 2 + 1</code>次。</p><p>算法实现：<br>既然我们不需要保存两个数组的所有元素，而是最多保存两个元素，那我们用两个变量currentNum和preNum来分别表示当前位置的数字和前一个数字，每次循环，将最新的结果赋值给currentNum，将currentNum赋值给preNum。<br>循环遍历思路还是和方法一一样，但是遍历次数变成len/2 + 1，不用完整遍历。用aIndex和bIndex分别表示num1和num2遍历的当前位置，进行比较，将最新的结果赋值给currentNum，将currentNum赋值给preNum。</p><p>考虑所有可能的情况包括某个数组已经没有元素：<br>若num1已经没有元素了，那可以继续遍历num2的元素，更新currentNum和preNum；即<code>aIndex≥m</code>则<code>bIndex++</code>;<br>当num1还有元素，num2没有元素，继续遍历num1的元素，更新currentNum和preNum；即<code>bIndex≥n</code> 则<code>aIndex++</code>;<br>当num1还有元素，num2也还有元素，则需要做<code>num1[aIndex]</code>和<code>num2[bIndex]</code>的比较。即<code>aIndex&lt;m</code> 且 <code>bIndex&lt;n</code>比较<code>num1[aIndex]</code>和<code>num2[bIndex]</code>的大小。</p><p>所以总结遍历条件就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">aIndex&lt;bIndex &amp;&amp; (bIndex&gt;=n || num1[aIndex]&lt;num2[bIndex])<br></code></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMedianSortedArrays</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">nums1</span>: [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">nums2</span>: [<span class="hljs-type">Int</span>])</span> -&gt; <span class="hljs-type">Double</span> &#123;<br>    <br>        <span class="hljs-keyword">var</span> currentNum <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, preNum <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, aIndex <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bIndex <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">let</span> m <span class="hljs-operator">=</span> nums1.count, n <span class="hljs-operator">=</span> nums2.count, len <span class="hljs-operator">=</span> m <span class="hljs-operator">+</span> n<br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">...</span>len<span class="hljs-operator">/</span><span class="hljs-number">2</span> &#123;<br>            preNum <span class="hljs-operator">=</span> currentNum<br>            <span class="hljs-keyword">if</span> aIndex <span class="hljs-operator">&lt;</span> m <span class="hljs-operator">&amp;&amp;</span> (bIndex <span class="hljs-operator">&gt;=</span> n <span class="hljs-operator">||</span> nums1[aIndex] <span class="hljs-operator">&lt;</span> nums2[bIndex]) &#123;<br>                currentNum <span class="hljs-operator">=</span> nums1[aIndex]<br>                aIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>            &#125;  <span class="hljs-keyword">else</span> &#123;<br>                currentNum <span class="hljs-operator">=</span> nums2[bIndex]<br>                bIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> len <span class="hljs-operator">&amp;</span> <span class="hljs-number">1</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(preNum <span class="hljs-operator">+</span> currentNum) <span class="hljs-operator">/</span> <span class="hljs-number">2.0</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span>  <span class="hljs-type">Double</span>(currentNum)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Complexity-Analysis：-1"><a href="#Complexity-Analysis：-1" class="headerlink" title="Complexity Analysis："></a>Complexity Analysis：</h5><ul><li>时间复杂度： O(m+n)。两个数组总元素个数的一半（m+n）/ 2</li><li>空间复杂度：O(1)。共申请了7个临时变量，所以是常量级</li></ul><hr><h5 id="Approach-3："><a href="#Approach-3：" class="headerlink" title="Approach 3："></a>Approach 3：</h5><p>以上两个方式都不能达到时间复杂度为O(log(m+n))，时间复杂度都是O(m+n)，要让时间复杂度为O(log(m+n))，那我们可以想到二分法，前面两个方法循环方式是一个一个遍历，一个一个排除，那我们可不可以批量排除，跳跃遍历呢，当然是可以的。假设我们现在要找第k小的数字，我们可以每次循环排除掉k / 2个数。</p><p>假设我们现在要找第7小的数字，num1和num2如下图：<br><img src="https://img-blog.csdnimg.cn/20181204162521246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215aW5jbHVkZQ==,size_16,color_FFFFFF,t_70" alt="k = 7"><br>我们比较两个数组的第k / 2个数字，如果k是奇数，向下取整，也就是比较第三个数字，上边数组中的4和下边数组中的3，如果哪个数字小，就表明该数组的前k / 2个数字都不可能是第k小的数字，可以排除掉，也就是说num2的[1，2，3]三个元素都不能是第7小的数字，我们可以把他们排除掉。将[1，3，4，9]和[4，5，6，7，8，9，10]组成两个新的数组，重新进行比较，如下图，其中橙色为已经去掉的数字。</p><p>我们现在可以总结一下：<br>数组A[1]，A[2]，A[3]，A[4]……A[k / 2]……A[m]，其中2k不一定等于m<br>数组B[1]，B[2]，B[3]，B[4]……B[k / 2]……B[n]，其中2k不一定等于n<br>假设A[k / 2] &lt; B[k / 2]，那么我们可以得出：<br>A[1]，A[2]，A[3]，A[4]……A[k / 2]都不可能是第k小的数。</p><p>而A数组中，比A[k / 2]小的数有(k / 2 - 1)个，B数组中，比B[k / 2]小的数有(k / 2 - 1)个，而A[k / 2] &lt; B[k / 2]，那么比B[k / 2]小的数有（k / 2 - 1 + k / 2 - 1 + 1）= (k - 1)个，那么B[k / 2]有可能是第k小的数，但是也有可能A数组中还有比B[k / 2]小的数。<br><img src="https://img-blog.csdnimg.cn/20181204162140471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215aW5jbHVkZQ==,size_16,color_FFFFFF,t_70" alt="k = 4"><br>上图中橙色为第一次比较就排除了的数字。现在进行第二轮比较，一开始k = 7，而我们已经排除了3个数字，所以这次 k = 4, k / 2 = 2，进行第二轮比较，因为3小于5，所以我们可以剔除num1中的[1，3]两个元素，得到结果如下图：<br><img src="https://img-blog.csdnimg.cn/20181204162218920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215aW5jbHVkZQ==,size_16,color_FFFFFF,t_70" alt="k = 2"><br>第一次我们排除了3个数字，第二次我们排除了2个数字，所以我们剩下需要找到最小的7 - 3 - 2 = 2个数字，即k = 2。现在当前查找的数字都为4，我们可以假设4≥4 也可以假设4 ≤ 4，因为我们总要排除一个4而保留一个4，所以对结果没有影响，下图是假设4 ≥ 4的结果，排除掉num2中的[4]，结果如下图：<br><img src="https://img-blog.csdnimg.cn/20181204162227346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215aW5jbHVkZQ==,size_16,color_FFFFFF,t_70" alt="k = 1"><br>此时我们已经排除了3 + 2 + 1 = 6个数字，所以剩下7 - 3 - 2 - 1 = 1，即k = 1。那我们只需要获取两个数组剩下元素中的第一次数字再进行一次比较，就可以获取到我们所要的结果。因为4&lt;5，所以第7小的数字为4。</p><hr><p>我们每次都是去k / 2的数进行比较，有时候可能会遇到数组长度小于k / 2的时候，如下图：<br><img src="https://img-blog.csdnimg.cn/20181204162235339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215aW5jbHVkZQ==,size_16,color_FFFFFF,t_70" alt="k = 7"><br>由于k / 2 = 3大于num1的长度2，所以我们将箭头指向num1的末尾进行比较，如果num1[m - 1]小于num2[k / 2]，那么直接排除掉num1数组，剩下就不用比较了，直接取num2[k - m ]即为第k小的数字，如下图：<br><img src="https://img-blog.csdnimg.cn/2018120416224557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215aW5jbHVkZQ==,size_16,color_FFFFFF,t_70" alt="k = 5"><br>在第一次比较中k = 7 ，k / 2 = 3，且num[1] = 2 &lt; num[2] = 3，所以直接排除掉整个num1数组[1，2]，剩下k = k - m = 7 - 2 = 5，即取num2[5-1]则为第k小的数字。</p><p>在上面的示例中，不论k为奇数还是偶数，对于算法都没有影响，而且，在找k的过程中，k的值都有可能奇数变偶数，偶数变奇数，最终当k=1或者某个数组为空时，停止遍历。</p><p>这里采用递归的思路，为了防止数组长度小于k / 2，所以每次比较<code>min(k /  2 , len(数组))</code>，把长度小于k / 2的那个数组排除掉。其他情况，将两数组进行递归并更新k的值直到k=1或者数组长度小于k/2。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMedianSortedArrays</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">nums1</span>: [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">nums2</span>: [<span class="hljs-type">Int</span>])</span> -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">let</span> m <span class="hljs-operator">=</span> nums1.count, n <span class="hljs-operator">=</span> nums2.count<br>        <span class="hljs-comment">//若m+n为偶数，则计算两个k值，（m+n）/ 2以及（m+n）/ 2 +1，若m+n为奇数，则计算一个k值（m+n+1）/ 2，为统一计算，不管是奇数还是偶数，我们都计算两个k，为奇数时，计算的是相同的两个k，偶数时，计算（m+n）/ 2和（m+n）/ 2 +1，而Int计算，（m+n）/ 2 == (m+n+1) / 2，所以综合起来有下面的结果。</span><br>        <span class="hljs-keyword">return</span> (findKth(nums1,nums2, (m<span class="hljs-operator">+</span>n<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<span class="hljs-operator">/</span><span class="hljs-number">2</span>) <span class="hljs-operator">+</span> findKth(nums1, nums2, (m<span class="hljs-operator">+</span>n<span class="hljs-operator">+</span><span class="hljs-number">2</span>)<span class="hljs-operator">/</span><span class="hljs-number">2</span>)) <span class="hljs-operator">*</span> <span class="hljs-number">0.5</span><br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findKth</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">nums1</span> : [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">nums2</span> : [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">k</span> : <span class="hljs-type">Int</span>)</span> -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">let</span> m <span class="hljs-operator">=</span> nums1.count, n <span class="hljs-operator">=</span> nums2.count<br>        <br>        <span class="hljs-keyword">guard</span> m <span class="hljs-operator">&lt;=</span> n <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> findKth(nums2, nums1, k)<br>        &#125;<br>        <br>        <span class="hljs-keyword">guard</span> m <span class="hljs-operator">!=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(nums2[k <span class="hljs-operator">-</span> <span class="hljs-number">1</span>])<br>        &#125;<br>        <span class="hljs-keyword">guard</span> k <span class="hljs-operator">!=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(<span class="hljs-built_in">min</span>(nums1[<span class="hljs-number">0</span>], nums2[<span class="hljs-number">0</span>]))<br>        &#125;<br>        <br>        <span class="hljs-keyword">let</span> i <span class="hljs-operator">=</span> <span class="hljs-built_in">min</span>(k <span class="hljs-operator">/</span> <span class="hljs-number">2</span>, m)<br>        <span class="hljs-keyword">let</span> j <span class="hljs-operator">=</span> <span class="hljs-built_in">min</span>(k <span class="hljs-operator">/</span> <span class="hljs-number">2</span>, m)<br>        <br>        <span class="hljs-keyword">if</span> nums1[i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] <span class="hljs-operator">&lt;</span> nums2[j <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] &#123;<br>            <span class="hljs-keyword">return</span> findKth(<span class="hljs-type">Array</span>(nums1[i<span class="hljs-operator">..&lt;</span>m]),nums2, k <span class="hljs-operator">-</span> i)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> findKth(nums1, <span class="hljs-type">Array</span>(nums2[j<span class="hljs-operator">..&lt;</span>n]), k <span class="hljs-operator">-</span> j)<br>        &#125;<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Complexity-Analysis：-2"><a href="#Complexity-Analysis：-2" class="headerlink" title="Complexity Analysis："></a>Complexity Analysis：</h5><ul><li>时间复杂度： O(log(m+n))。每进行一次循环，我们就减少 k / 2 个元素，所以时间复杂度是 O（log（k）），而<code> k = （m + n）/ 2</code> ，所以最终的复杂也就是 O（log（m + n））。</li><li>空间复杂度：O(1)。虽然我们用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，所以空间复杂度为 O（1）。</li></ul><hr><h5 id="Approach-4："><a href="#Approach-4：" class="headerlink" title="Approach 4："></a>Approach 4：</h5><p>首先看看中位数的定义：<br>中位数（又称中值，英语：Median），统计学中的专有名词，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。<br>对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。 （from： 百度百科）</p><p>我们将数组进行划分，假设数组长度为m，如下图，我们有0到m共m+1个位置可以进行切割。<br><img src="https://img-blog.csdnimg.cn/20181205142131104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215aW5jbHVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在我们分别使用i和j对A，B两个数组进行分割，将A，B两个数组左边的分割结果组合成左半部分（绿色），将右边分割结果组合成右半部分（黄色）。</p><p>当A数组和B数组的总长度为偶数时，我们能够得到下图所示的两部分。</p><p>若我们能够保证：</p><ul><li>左半部分长度等于右半部分长度：</br><br>  <code>i + j = m - i + n - j </code><br>  即：<br>   <code>j = (m + n) / 2 - i</code></li><li>左半部分最大值小于等于右半部分最小值：</br><br>  <code>max( A [ i - 1 ] , B [ j - 1 ] )  ≤ min ( A [ i ] ， B [ j ] )</code></li></ul><p>那么，中位数就可以表示为如下：</br><br><code>（左半部分最大值+右半部分最小值）* 0.5</code><br>即：<br><code>（max ( A [ i - 1 ] , B [ j - 1 ] )  + min ( A [ i ]，B [ j ] ) ) * 0.5</code><br><img src="https://img-blog.csdnimg.cn/20181205142927726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215aW5jbHVkZQ==,size_16,color_FFFFFF,t_70" alt="偶数"><br>当A数组和B数组的总长度为奇数时（假设分割使B数组左边多出一个元素），我们能够得到下图所示的两部分。</p><p>若我们能够保证：</p><ul><li>左半部分长度比右半部分长度大1：</br><br>  <code>i + j = m - i + n - j + 1 </code><br>  即：<br>   <code>j = (m + n + 1) / 2 - i</code></li><li>左半部分最大值小于等于右半部分最小值：</br><br>  <code>max( A [ i - 1 ] , B [ j - 1 ] )  ≤ min ( A [ i ] ， B [ j ] )</code></li></ul><p>那么，中位数就是左半部分最大的值，<br>即：<br><code>max ( A [ i - 1 ] , B [ j - 1 ] ) </code><br><img src="https://img-blog.csdnimg.cn/20181205142939455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215aW5jbHVkZQ==,size_16,color_FFFFFF,t_70" alt="奇数"></p><hr><p><strong>对于第一个条件：</strong><br>我们对总长度为偶数和奇数进行了分类讨论，其实因为Int运算的特性，我们可以将条件合并起来，得出：<br><code>j = ( m + n + 1 ) / 2 - i</code></p><ul><li>当<code>m+n</code>为偶数时，<code>m + n</code>能把2整除，Int(1/2) = 0</li><li>当<code>m+n</code>为奇数时，<code>m + n + 1</code>能把2整除</li></ul><p>所以对于偶数的情况，将<code>j = ( m + n ) / 2 - i</code>变成<code>j = ( m + n + 1 ) / 2 - i</code>对整个结果是没有影响的。<br>由于<code>0 ≤ i ≤ m</code>，为保证<code>0 ≤ j ≤ n</code>，我们需要保证<code>m ≤ n</code>。</p><ul><li><code>m ≤ n ，i ≤ m，j = (m + n + 1) / 2 - i ≥ (m + m + 1) / 2 - m = 0</code></li><li><code>m ≤ n ，i ≥ 0 , j = (m + n + 1) / 2 - i ≤ (n + n + 1) / 2 - i ≤ (n + n + 1) / 2 = n  </code></li></ul><hr><p><strong>对于第二个条件：</strong><br>奇数和偶数的情况是一样的，为了保证<code>max( A [ i - 1 ] , B [ j - 1 ] )  ≤ min ( A [ i ] ， B [ j ] )</code>，而<code>A[ i - 1 ] &lt; A [ i ] </code>， <code>B[ j - 1 ] &lt; B [ j ] </code>，所以只需要保证<code> B [ j - 1 ] ≤ A[ i ]</code>，<code> A [ i - 1 ] ≤ B[ j ]</code>即可。</p><p>现在我们来看，如何保证：<code> B [ j - 1 ] ≤ A[ i ]</code>，<code> A [ i - 1 ] ≤ B[ j ]</code></p><ul><li>如果<code> B [ j - 1 ] ≤ A [ i ]</code>，<code> A [ i - 1 ] ≤ B[ j ]</code>，那么我们可以直接得到结果；</li><li>如果<code> B [ j - 1 ] &gt; A [ i ]</code>，意味着A [ i ]过小，因为有序，我们只需要将i增加，而i的增减和j的增减是相反的，i变大，j就会变小，而i变大，A[ i ]也会跟着变大，j减小，B[ j ]也会减小；</li><li>如果<code> A [ i - 1 ] &gt; B [ i ]</code>，意味着A [ i ]过大，因为有序，我们只需要将i减小，i减小，j就会变大；<br>重复2，3步直到满足条件。</li></ul><hr><p>现在，让我们来考虑一下边界问题，即当 i = 0 ，i = m ，j = 0， j = n的情况：</p><ul><li>当i = 0 或者 j = 0 即切在了最前面，如下图：<br><img src="https://img-blog.csdnimg.cn/20181206114219162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215aW5jbHVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时当 i = 0，左半部分最大值即为B [ j - 1] , 当j = 0 时，左半部分最大值是A [ i - 1]；右半部分最小值不变。</li><li>当i = m 或者 j = n时，即切在了最后面，如下图：<br><img src="https://img-blog.csdnimg.cn/20181206114331155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215aW5jbHVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时当 i = m，右半部分最小值即为B [ j ] , 当j = n 时，右半部分最小值是A [ i]；左半部分最大值不变。</li></ul><hr><p>所以总结起来就是：</p><ul><li>(j = 0 or i = m or B[ j − 1 ] ≤ A[ i ]) 或是<br>(i = 0 or j = n or A[ i − 1 ] ≤ B [ j ] )<br>这意味着 i 是完美的，我们可以停止搜索。</li><li>j &gt; 0 and i &lt; m and B[ j − 1 ] &gt; A [ i ]<br>这意味着 i 太小，我们必须增大它。</li><li>i &gt; 0 and j &lt; n and A[ i − 1 ] &gt; B [ j ]<br>这意味着 i 太大，我们必须减小它。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMedianSortedArrays</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">nums1</span>: [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">nums2</span>: [<span class="hljs-type">Int</span>])</span> -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">let</span> m <span class="hljs-operator">=</span> nums1.count, n <span class="hljs-operator">=</span> nums2.count<br>        <span class="hljs-keyword">if</span> m <span class="hljs-operator">&gt;</span> n &#123;<br>            <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1)<br>        &#125;<br>        <br>        <span class="hljs-keyword">var</span> halfLength : <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> (m <span class="hljs-operator">+</span> n <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">var</span> begin <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end <span class="hljs-operator">=</span> m<br>        <span class="hljs-keyword">var</span> maxLeft <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, minRight <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> begin <span class="hljs-operator">&lt;=</span> end &#123;<br>            <span class="hljs-keyword">let</span> mid1 <span class="hljs-operator">=</span> (begin <span class="hljs-operator">+</span> end) <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">let</span> mid2 <span class="hljs-operator">=</span> halfLength <span class="hljs-operator">-</span> mid1<br>            <span class="hljs-keyword">if</span> mid1 <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> mid2 <span class="hljs-operator">&lt;</span> n <span class="hljs-operator">&amp;&amp;</span> nums1[mid1 <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] <span class="hljs-operator">&gt;</span> nums2[mid2] &#123;<br>                end <span class="hljs-operator">=</span> mid1 <span class="hljs-operator">-</span> <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> mid2 <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> mid1 <span class="hljs-operator">&lt;</span> m <span class="hljs-operator">&amp;&amp;</span> nums1[mid1] <span class="hljs-operator">&lt;</span> nums2[mid2 <span class="hljs-operator">-</span> <span class="hljs-number">1</span>] &#123;<br>                begin <span class="hljs-operator">=</span> mid1 <span class="hljs-operator">+</span> <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> mid1 <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123;<br>                    maxLeft <span class="hljs-operator">=</span> nums2 [mid2 <span class="hljs-operator">-</span> <span class="hljs-number">1</span>]<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> mid2 <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123;<br>                    maxLeft <span class="hljs-operator">=</span> nums1[mid1 <span class="hljs-operator">-</span> <span class="hljs-number">1</span>]<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    maxLeft <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(nums1[mid1 <span class="hljs-operator">-</span> <span class="hljs-number">1</span>], nums2[mid2 <span class="hljs-operator">-</span> <span class="hljs-number">1</span>])<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (m <span class="hljs-operator">+</span> n) <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">1</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(maxLeft)<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> mid1 <span class="hljs-operator">==</span> m &#123;<br>                    minRight <span class="hljs-operator">=</span> nums2[mid2]<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> mid2 <span class="hljs-operator">==</span> n &#123;<br>                    minRight <span class="hljs-operator">=</span> nums1[mid1]<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    minRight <span class="hljs-operator">=</span> <span class="hljs-built_in">min</span>(nums1[mid1], nums2[mid2])<br>                &#125;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(maxLeft <span class="hljs-operator">+</span> minRight) <span class="hljs-operator">*</span> <span class="hljs-number">0.5</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Complexity-Analysis：-3"><a href="#Complexity-Analysis：-3" class="headerlink" title="Complexity Analysis："></a>Complexity Analysis：</h5><ul><li>时间复杂度： O(log(min（m，n）) )。我们对较短的数组进行了二分查找，所以时间复杂度是 O（log（min（m，n）））。</li><li>空间复杂度：O(1)。只使用了固定变量，与数组长度无关，所以空间复杂度是O(1)。</li></ul><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#57;&#57;&#x34;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;">&#x5f;&#49;&#57;&#57;&#x34;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
      <tag>分治算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Http2.0了解</title>
    <link href="/post/4abpi8ft.html"/>
    <url>/post/4abpi8ft.html</url>
    
    <content type="html"><![CDATA[<h2 id="【开发笔记】系列目录"><a href="#【开发笔记】系列目录" class="headerlink" title="【开发笔记】系列目录"></a><a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="一、Http-2-0-特点"><a href="#一、Http-2-0-特点" class="headerlink" title="一、Http/2.0 特点"></a><a href="#1">一、Http/2.0 特点</a></h3><h4 id="nbsp-nbsp-1-字数统计和阅读时长-网站底部-文章内"><a href="#nbsp-nbsp-1-字数统计和阅读时长-网站底部-文章内" class="headerlink" title="&nbsp;&nbsp;1.字数统计和阅读时长(网站底部/文章内)"></a>&nbsp;&nbsp;<a href="#2-1">1.字数统计和阅读时长(网站底部/文章内)</a></h4><h4 id="nbsp-nbsp-2-转换连接"><a href="#nbsp-nbsp-2-转换连接" class="headerlink" title="&nbsp;&nbsp;2.转换连接"></a>&nbsp;&nbsp;<a href="#2-2">2.转换连接</a></h4><h4 id="nbsp-nbsp-3-本地搜索"><a href="#nbsp-nbsp-3-本地搜索" class="headerlink" title="&nbsp;&nbsp;3.本地搜索"></a>&nbsp;&nbsp;<a href="#2-3">3.本地搜索</a></h4><h3 id="二、常用插件"><a href="#二、常用插件" class="headerlink" title="二、常用插件"></a><a href="#2">二、常用插件</a></h3><h4 id="nbsp-nbsp-1-字数统计和阅读时长-网站底部-文章内-1"><a href="#nbsp-nbsp-1-字数统计和阅读时长-网站底部-文章内-1" class="headerlink" title="&nbsp;&nbsp;1.字数统计和阅读时长(网站底部/文章内)"></a>&nbsp;&nbsp;<a href="#2-1">1.字数统计和阅读时长(网站底部/文章内)</a></h4><h4 id="nbsp-nbsp-2-转换连接-1"><a href="#nbsp-nbsp-2-转换连接-1" class="headerlink" title="&nbsp;&nbsp;2.转换连接"></a>&nbsp;&nbsp;<a href="#2-2">2.转换连接</a></h4><h4 id="nbsp-nbsp-3-本地搜索-1"><a href="#nbsp-nbsp-3-本地搜索-1" class="headerlink" title="&nbsp;&nbsp;3.本地搜索"></a>&nbsp;&nbsp;<a href="#2-3">3.本地搜索</a></h4><h4 id="nbsp-nbsp-4-文章底部增加版权声明"><a href="#nbsp-nbsp-4-文章底部增加版权声明" class="headerlink" title="&nbsp;&nbsp;4.文章底部增加版权声明"></a>&nbsp;&nbsp;<a href="#2-4">4.文章底部增加版权声明</a></h4><span id="more"></span><hr><h1 id='1'>一、Http/2.0 特点</h1><h2 id='1-1'>&nbsp;&nbsp;1.安全</h2>基于HTTPS协议<h2 id='1-2'>&nbsp;&nbsp;2.高效</h2>使用二进制分帧进行数据传输，低延迟，高吞吐量<h2 id='1-3'>&nbsp;&nbsp;3.兼容</h2>2.0协议是在1.x的基础上升级而不是重写，1.x协议的语义、HTTP 方法、状态码、URI 及首部字段在2.0里是一样的<h1 id='2'>二、Http/2.0优化</h1><h2 id='2-1'>&nbsp;&nbsp;1.概念</h2><h3 id='2-1-1'>&nbsp;&nbsp;&nbsp;&nbsp;(1).帧（Frame）</h3>帧是数据通信的最小单位，以二进制压缩格式存放内容。包含：类型Type, 长度Length, 标记Flags, 流标识和Frame payload有效载荷。来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。[详细介绍：HTTP/2 中的帧定义](https://halfrost.com/http2-http-frames-definitions/)<h3 id='2-1-2'>&nbsp;&nbsp;&nbsp;&nbsp;(2).消息（Message）</h3>消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。<h3 id='2-1-3'>&nbsp;&nbsp;&nbsp;&nbsp;(3).流（Stream）</h3>流是连接中的一个虚拟信道，可以承载双向消息传输，包含1条或者多条Message。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。<p>特点：</p><ul><li>1.双向性：同一个流内，可同时发送和接受数据。</li><li>2.有序性：流中被传输的数据就是<code>二进制帧</code> 。帧在流上的被发送与被接收都是按照顺序进行的。</li><li>3.并行性：流中的 <code>二进制帧</code> 都是被并行传输的，无需按顺序等待。但却不会引起数据混乱，因为每个帧都有顺序标号。它们最终会被按照顺序标号来合并。</li><li>4.流的创建：流可以被客户端或服务器单方面建立, 使用或共享。</li><li>5.流的关闭：流也可以被任意一方关闭。<h3 id='2-1-4'>&nbsp;&nbsp;&nbsp;&nbsp;(4).流标识</h3>流标识是描述二进制Frame的格式，使得每个Frame能够基于HTTP/2发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的Frame存在于客户端和服务器端之间的HTTP/2连接中。一个HTTP/2连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。</li><li><em>总结</em>*</li><li>帧是流中的数据单位；</li><li>消息由一个或多个帧组成；</li><li>消息的header帧可以分成多个header帧，data帧可以分成多个data帧。</li></ul><h3 id='2-1-5'>&nbsp;&nbsp;&nbsp;&nbsp;(5).Connection连接</h3>1个TCP 连接，包含1个或者多个Stream。所有通信都在一个TCP连接上完成，此连接可以承载任意数量的双向数据流。<h2 id='2-2'>&nbsp;&nbsp;2.二进制分帧（Binary Format）</h2>将传输信息分为两个帧，分别是Headers帧和Data帧。在二进制分帧层上， HTTP/2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP/1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。<p>HTTP/2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些<strong>帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。</strong></p><p>在二进制分帧层上，HTTP/2会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证HTTP的各种动词，方法，首部都不受影响，兼容上一代HTTP标准。其中，HTTP/1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。</p><p><img src="https://i.loli.net/2020/09/11/jDsR9vUNu6IfphZ.png" alt="image.png"></p><h2 id='2-3'>3.多路复用 (Multiplexing) / 连接共享</h2>在 HTTP/1.x 中，一次链接成功后，只要该链接还没断开，那么 client 端可以在这么一个链接中有序地发起多个请求，并以此获得每个请求对应的响应数据。但是浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞，一次请求与响应的交互必须要等待前面的请求交互完成，否则后面的只能等待，这个就是**线头阻塞**。要想实现多流并行，就要开启多个TCP连接。HTTP/2.0新的分帧机制可以不依赖多个TCP连接去实现多流并行，而且多路复用允许同时通过单一的HTTP/2 连接发起多重的请求-响应消息，不会造成阻塞。![image.png](https://i.loli.net/2020/09/11/KDqP3Qgfn7y1GlJ.png)<p><strong>总结</strong></p><ul><li>1.同域名下所有通信都在单个连接上完成，同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗；</li><li>2.单个连接可以承载任意数量的双向数据流，单个连接上可以并行交错的请求和响应，之间互不干扰；</li><li>3.数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</li></ul><h2 id='2-4'>4.头部压缩（Header Compression）</h2><h3 id='2-4-1'>&nbsp;&nbsp;(1).为什么要压缩</h3><p>在 HTTP/1 中，HTTP 请求和响应都是由「状态行、请求 / 响应头部、消息主体」三部分组成。HTTP每一次通信都会携带一组头部，用于描述这次通信的的资源、浏览器属性、cookie等，HTTP/1.x每次请求都会携带大量冗余头信息，请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。一般而言，消息主体都会经过 gzip 压缩，或者本身传输的就是压缩过后的二进制文件（例如图片、音频），但状态行和头部却没有经过任何压缩，直接以纯文本传输。</p><h3 id='2-4-2'>&nbsp;&nbsp;(2).压缩策略</h3><ul><li>1.HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>2.首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;如果请求中不包含首部(例如对同一资源的轮询请求)，那么，首部开销就是零字节，此时所有首部都自动使用之前请求发送的首部；</li><li>3.每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ul><p><strong>HTTP/2关注的是首部压缩（HPACK算法），而我们常用的gzip等是报文内容（body）的压缩</strong></p><h3 id='2-4-3'>&nbsp;&nbsp;(3).压缩原理</h3>用Header字段表里的索引代替实际的Header。<p>HTTP/2的HPACK算法使用一份索引表来定义常用的HTTP Header，把常用的 HTTP Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。</p><p>例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示，如下图：<br><img src="https://i.loli.net/2020/09/15/hXpHEBURljOmdx6.png" alt="image.png"><br><a href="https://blog.csdn.net/qq_32523587/article/details/79970471">详细介绍HTTP/2 头部压缩技术介绍</a></p><h3 id='2-4-4'>&nbsp;&nbsp;(4).请求优先级（Request Priorities）</h3>把HTTP消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值* 0 表示最高优先级* -1（2的31次方） 表示最低优先级。<p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的，绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p><p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p><ul><li>优先级最高：主要的html</li><li>优先级高：CSS文件</li><li>优先级中：js文件</li><li>优先级低：图片</li></ul><h2 id='2-5'>5.服务端推送（Server Push）</h2><p>服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求，并且，服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。</p><p>正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。Server Push 让 HTTP/1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西，这相当于在一个 HTML 文档内集合了所有的资源。</p><p>不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p><h1 id='3'>三、Http/2.0性能瓶颈</h1><p>启用HTTP/2.0后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压力集中在底层一个TCP连接之上，TCP很可能就是下一个性能瓶颈，比如TCP分组的队首阻塞问题，单个TCP packet丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对HTTP/2.0下的TCP配置优化至关重要。</p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#57;&#x39;&#52;&#64;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d;">&#95;&#x31;&#57;&#x39;&#52;&#64;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发笔记</tag>
      
      <tag>Http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo配置</title>
    <link href="/post/ef4ake7i.html"/>
    <url>/post/ef4ake7i.html</url>
    
    <content type="html"><![CDATA[<h2 id="【开发笔记】系列目录"><a href="#【开发笔记】系列目录" class="headerlink" title="【开发笔记】系列目录"></a><a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a><a href="#1">一、常用命令</a></h3><h3 id="二、常用插件"><a href="#二、常用插件" class="headerlink" title="二、常用插件"></a><a href="#2">二、常用插件</a></h3><h4 id="nbsp-nbsp-1-字数统计和阅读时长-网站底部-文章内"><a href="#nbsp-nbsp-1-字数统计和阅读时长-网站底部-文章内" class="headerlink" title="&nbsp;&nbsp;1.字数统计和阅读时长(网站底部/文章内)"></a>&nbsp;&nbsp;<a href="#2-1">1.字数统计和阅读时长(网站底部/文章内)</a></h4><h4 id="nbsp-nbsp-2-链接转换"><a href="#nbsp-nbsp-2-链接转换" class="headerlink" title="&nbsp;&nbsp;2.链接转换"></a>&nbsp;&nbsp;<a href="#2-2">2.链接转换</a></h4><h4 id="nbsp-nbsp-3-本地搜索"><a href="#nbsp-nbsp-3-本地搜索" class="headerlink" title="&nbsp;&nbsp;3.本地搜索"></a>&nbsp;&nbsp;<a href="#2-3">3.本地搜索</a></h4><h4 id="nbsp-nbsp-4-文章底部增加版权声明"><a href="#nbsp-nbsp-4-文章底部增加版权声明" class="headerlink" title="&nbsp;&nbsp;4.文章底部增加版权声明"></a>&nbsp;&nbsp;<a href="#2-4">4.文章底部增加版权声明</a></h4><h4 id="nbsp-nbsp-5-next主题增加访问统计"><a href="#nbsp-nbsp-5-next主题增加访问统计" class="headerlink" title="&nbsp;&nbsp;5.next主题增加访问统计"></a>&nbsp;&nbsp;<a href="#2-5">5.next主题增加访问统计</a></h4><span id="more"></span><hr><h1 id='1'>一、常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n <span class="hljs-string">&quot;我的博客&quot;</span> == hexo new <span class="hljs-string">&quot;我的博客&quot;</span> <span class="hljs-comment">#新建文章</span><br>hexo g == hexo generate<span class="hljs-comment">#生成</span><br>hexo s == hexo server <span class="hljs-comment">#启动服务预览</span><br>hexo d == hexo deploy<span class="hljs-comment">#部署</span><br></code></pre></td></tr></table></figure><p>发布时，使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><h1 id='2'>二、常用插件</h1><h2 id='2-1'>&nbsp;&nbsp;1.字数统计和阅读时长(网站底部/文章内)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># hexo-symbols-count-time，统计字数，预计阅读时间</span><br>symbols_count_time:<br>  symbols: <span class="hljs-literal">true</span><br>  time: <span class="hljs-literal">true</span><br>  total_symbols: <span class="hljs-literal">true</span><br>  total_time: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id='2-2'>&nbsp;&nbsp;2.链接转换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># hexo-abbrlink，链接转换</span><br>root: /<br><span class="hljs-comment"># 更改 permalink 值</span><br><span class="hljs-comment"># permalink: :year/:month/:day/:title/</span><br>permalink: post/:abbrlink.html<br></code></pre></td></tr></table></figure><h2 id='2-3'>&nbsp;&nbsp;3.本地搜索</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># hexo-generator-searchdb，本地搜索</span><br>search:<br>  path: search.xml<br>  field: post<br>  format: html<br>  <span class="hljs-built_in">limit</span>: 10000<br></code></pre></td></tr></table></figure><h2 id='2-4'>&nbsp;&nbsp;4.文章底部增加版权声明</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># hexo-addlink 文章底部增加版权声明</span><br>addlink:<br>  before_text: __本文作者__：XieBangyao&lt;br /&gt;__邮箱__：xiebangyao_1994@163.com&lt;br /&gt;__本文地址__：<br>  after_text: &lt;br /&gt;__版权声明__：转载请注明出处！<br></code></pre></td></tr></table></figure><h2 id='2-5'>&nbsp;&nbsp;5.next主题增加访问统计</h2>1. 打开next主题配置文件/themes/next/_config.yml<p>在这个文件搜索busuanzi，修改enable为true</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">busuanzi_count:<br>  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span>          //此处修改为<span class="hljs-literal">true</span><br>  total_visitors: <span class="hljs-literal">true</span><br>  total_visitors_icon: user<br>  total_views: <span class="hljs-literal">true</span><br>  total_views_icon: eye<br>  post_views: <span class="hljs-literal">true</span><br>  post_views_icon: eye<br></code></pre></td></tr></table></figure><p>在这个文件搜索footer，在他子项中添加counter，并设置为true</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#统计</span><br>counter: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>2.打开next主题下的文件/themes/next/layout/_partials/footer.swig，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;% <span class="hljs-keyword">if</span> theme.footer.counter %&#125;<br>    &lt;script async src=<span class="hljs-string">&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#x39;&#x34;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;">&#x5f;&#49;&#x39;&#x39;&#x34;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发笔记</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git撤回commit与push</title>
    <link href="/post/afe2feq.html"/>
    <url>/post/afe2feq.html</url>
    
    <content type="html"><![CDATA[<h2 id="【开发笔记】系列目录"><a href="#【开发笔记】系列目录" class="headerlink" title="【开发笔记】系列目录"></a><a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-撤销commit"><a href="#1-撤销commit" class="headerlink" title="1.撤销commit"></a><a href="#1">1.撤销commit</a></h3><h3 id="2-撤销push"><a href="#2-撤销push" class="headerlink" title="2.撤销push"></a><a href="#2">2.撤销push</a></h3><span id="more"></span><hr><h1 id='1'>1.撤销commit</h1><ul><li><code>git log</code>查看提交记录，找到需要撤回到的提交id</li><li><code>git reset --soft id</code>或者<code>git reset --hard id</code>，id为需要撤回的提交id</li><li><em>Warning:（<code>--hard</code>会丢弃本地修改，请谨慎使用）</em>*</li></ul><h1 id='2'>2.撤销push</h1><ul><li><code>git log</code>查看提交记录，找到需要撤回到的提交id</li><li><code>git reset --soft id</code>或者<code>git reset --hard id</code>，id为需要撤回的提交id</li><li><code>git push origin 分支名 –-force</code>，强制提交当前版本号</li></ul><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#x39;&#x39;&#x34;&#x40;&#49;&#x36;&#51;&#46;&#99;&#111;&#109;">&#95;&#49;&#x39;&#x39;&#x34;&#x40;&#49;&#x36;&#51;&#46;&#99;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发笔记</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP三次握手与四次挥手</title>
    <link href="/post/gkea24bn.html"/>
    <url>/post/gkea24bn.html</url>
    
    <content type="html"><![CDATA[<h2 id="【开发笔记】系列目录"><a href="#【开发笔记】系列目录" class="headerlink" title="【开发笔记】系列目录"></a><a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="一、TCP报文"><a href="#一、TCP报文" class="headerlink" title="一、TCP报文"></a><a href="#1">一、TCP报文</a></h3><h3 id="二、三次握手"><a href="#二、三次握手" class="headerlink" title="二、三次握手"></a><a href="#2">二、三次握手</a></h3><h4 id="nbsp-nbsp-1-流程"><a href="#nbsp-nbsp-1-流程" class="headerlink" title="&nbsp;&nbsp;1.流程"></a>&nbsp;&nbsp;<a href="#2-1">1.流程</a></h4><h4 id="nbsp-nbsp-2-为什么要进行三次握手"><a href="#nbsp-nbsp-2-为什么要进行三次握手" class="headerlink" title="&nbsp;&nbsp;2.为什么要进行三次握手"></a>&nbsp;&nbsp;<a href="#2-2">2.为什么要进行三次握手</a></h4><h3 id="三、四次挥手"><a href="#三、四次挥手" class="headerlink" title="三、四次挥手"></a><a href="#3">三、四次挥手</a></h3><h4 id="nbsp-nbsp-1-流程-1"><a href="#nbsp-nbsp-1-流程-1" class="headerlink" title="&nbsp;&nbsp;1.流程"></a>&nbsp;&nbsp;<a href="#3-1">1.流程</a></h4><h4 id="nbsp-nbsp-2-为什么要进行四次挥手"><a href="#nbsp-nbsp-2-为什么要进行四次挥手" class="headerlink" title="&nbsp;&nbsp;2.为什么要进行四次挥手"></a>&nbsp;&nbsp;<a href="#3-2">2.为什么要进行四次挥手</a></h4><h3 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a><a href="#4">四、问题</a></h3><h4 id="nbsp-nbsp-【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#nbsp-nbsp-【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="&nbsp;&nbsp;【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>&nbsp;&nbsp;<a href="4-1">【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</a></h4><h4 id="nbsp-nbsp-【问题2】为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#nbsp-nbsp-【问题2】为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="&nbsp;&nbsp;【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>&nbsp;&nbsp;<a href="4-2">【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</a></h4><h4 id="nbsp-nbsp-【问题3】为什么不能用两次握手进行连接？"><a href="#nbsp-nbsp-【问题3】为什么不能用两次握手进行连接？" class="headerlink" title="&nbsp;&nbsp;【问题3】为什么不能用两次握手进行连接？"></a>&nbsp;&nbsp;<a href="4-3">【问题3】为什么不能用两次握手进行连接？</a></h4><h4 id="nbsp-nbsp-【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#nbsp-nbsp-【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="&nbsp;&nbsp;【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>&nbsp;&nbsp;<a href="4-4">【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？</a></h4><span id="more"></span><hr><h1 id='1'>一、TCP报文</h1><p>TCP的报文样式</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/882dc14701c94ff8a34c032b220495f9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>控制位（Control Flag）标记着握手阶段的各个状态</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a278a46d97f4d0bb2d78fa5ec51ba9a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>三次握手和四次握手示意图<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fd89791728a42f689ae0e4049dc998b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h1 id='2'> 二、三次握手</h1><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7afc59fbcf34710987cdd4b5f3919b9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id='2-1'>1.流程</h2><ul><li><strong>（1）第一次握手：</strong></br>Client将标志位SYN置为1（表示要发起一个连接），随机产生一个值seq=x，并将该数据包发送给Server，Client进入<strong>SYN_SENT</strong>状态，等待Server确认；</li><li><strong>（2）第二次握手：</strong></br>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入<strong>SYN_RCVD</strong>状态；</li><li><strong>（3）第三次握手：</strong></br>Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入<strong>ESTABLISHED</strong>状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li></ul><h2 id='2-2'> 2.为什么要进行三次握手</h2><ul><li><strong>（1）、确保收发双方收发正常；</strong></li><li><strong>（2）、防止失效的请求再次传到服务端，造成错误；</strong></br><br>  <strong>失效的连接请求</strong>：</br>主机A发出的连接请求没有收到主机B的确认，过一段时间后，主机A又向主机B发送连接请求，且建立成功，顺序完成数据传输。<br>  主机A发送的请求因网络延迟无法到达主机B(并没有丢失)，主机B以为是主机A又发起的新请求，于是主机B同意连接，并向主机A发回确认，但此时主机A根本不理会，导致主机B的资源浪费。</li><li><strong>（3）、防攻击</strong></br><br>  <strong>SYN攻击：</strong></br><br>  在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了<h1 id='3'>三、四次挥手</h1></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26bf78c20db243ff9c97fd38cee92d83~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id='3-1'> 1.流程</h2><ul><li><strong>（1）第一次挥手：</strong></br>Client发送一个FIN=1（与SYN相同，一个FIN占用一个序号），seq = x，用来关闭Client到Server的数据传送，Client进入<strong>FIN_WAIT_1</strong>状态；</li><li><strong>（2）第二次挥手：</strong></br>Server收到FIN=1后，发送一个ACK=1，ack=x+1给Client，Server进入<strong>CLOSE_WAIT</strong>状态；</li><li><strong>（3）第三次挥手：</strong></br>Server发送一个FIN=1，seq = y用来关闭Server到Client的数据传送，Server进入<strong>LAST_ACK</strong>状态；</li><li><strong>（4）第四次挥手：</strong></br>Client收到FIN=1后，Client进入<strong>TIME_WAIT</strong>状态，接着发送一个ACK=1，ack = y+1给Server，Server进入<strong>CLOSED</strong>状态，完成四次挥手。</li></ul><h2 id='3-2'> 2.为什么要进行四次挥手</h2><p><strong>防止一段数据未发送完：</strong><br>断开连接时，一方收到FIN包，另一方有数据未发送完，此时就需要先向对端回复FIN包的ACK。将剩下的数据发送完后，再像对方发送FIN,断开连接。</p><h1 id='4'>四、问题</h1><h2 id='4-1'>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</h2><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h2 id='4-2'>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h2><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h2 id='4-3'>【问题3】为什么不能用两次握手进行连接？</h2><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><p>       现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><h4 id='4-4'>【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#57;&#57;&#x34;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;">&#95;&#49;&#57;&#57;&#x34;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发笔记</tag>
      
      <tag>TCP</tag>
      
      <tag>三次握手</tag>
      
      <tag>四次挥手</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体字节对齐</title>
    <link href="/post/pfe2aew.html"/>
    <url>/post/pfe2aew.html</url>
    
    <content type="html"><![CDATA[<h2 id="【开发笔记】系列目录"><a href="#【开发笔记】系列目录" class="headerlink" title="【开发笔记】系列目录"></a><a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="结构体对齐原则"><a href="#结构体对齐原则" class="headerlink" title="结构体对齐原则"></a><a href="#1">结构体对齐原则</a></h3><h4 id="nbsp-nbsp-1-针对整个内存空间"><a href="#nbsp-nbsp-1-针对整个内存空间" class="headerlink" title="&nbsp;&nbsp;1.针对整个内存空间"></a>&nbsp;&nbsp;<a href="#1-1">1.针对整个内存空间</a></h4><h4 id="nbsp-nbsp-2-针对结构体内部成员"><a href="#nbsp-nbsp-2-针对结构体内部成员" class="headerlink" title="&nbsp;&nbsp;2.针对结构体内部成员"></a>&nbsp;&nbsp;<a href="#1-2">2.针对结构体内部成员</a></h4><h4 id="nbsp-nbsp-3-针对结构体整体"><a href="#nbsp-nbsp-3-针对结构体整体" class="headerlink" title="&nbsp;&nbsp;3.针对结构体整体"></a>&nbsp;&nbsp;<a href="#1-3">3.针对结构体整体</a></h4><span id="more"></span><hr><h1 id='1'>结构体对齐原则</h1><h2 id='1-1'>1.针对整个内存空间</h2>结构体变量的首地址能够被其最宽基本类型成员的大小所整除。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> &#123;</span><br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">short</span> b;<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-keyword">double</span> d;<span class="hljs-comment">//最宽成员占8字节</span><br>&#125; Test;<br></code></pre></td></tr></table></figure>首地址打印<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Test t;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,&amp;t); <span class="hljs-comment">//打印结果首地址可以整除8（最宽成员所占大小）</span><br></code></pre></td></tr></table></figure><h2 id='1-2'>2.针对结构体内部成员</h2><ul><li>（1）、结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍；</li><li>（2）、结构体嵌套结构体，按内部结构体宽度最宽的基本类型成员大小来对齐；</li><li>（3）、按对齐原则，在未占用空间进行填充。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test1</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a;<span class="hljs-comment">// 0~3，共4字节，偏移地址是4的0倍</span><br>    <span class="hljs-keyword">char</span> b;<span class="hljs-comment">// 4，共1字节，偏移地址是1的4倍</span><br>    <span class="hljs-keyword">double</span> c;<span class="hljs-comment">// 8~15，共8字节，偏移地址是8的1倍，故5~7需要填充</span><br>    <span class="hljs-keyword">short</span> d;<span class="hljs-comment">// 16~17，共2字节，偏移地址是2的8倍</span><br>&#125; Test1;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test2</span> &#123;</span><br>    <span class="hljs-keyword">char</span> b;<span class="hljs-comment">// 0，共1字节，偏移地址是1的0倍</span><br>    <span class="hljs-keyword">double</span> c;<span class="hljs-comment">// 8~15，共8字节，偏移地址是8的1倍，故1~7需要填充</span><br>    <span class="hljs-keyword">short</span> d;<span class="hljs-comment">// 16~17，共2字节，偏移地址是2的8倍</span><br>    <span class="hljs-keyword">int</span> a;<span class="hljs-comment">// 20~23，共4字节，偏移地址是4的5倍，故18~19需要填充</span><br>&#125; Test2;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test3</span> &#123;</span><br>    <span class="hljs-keyword">char</span> b;<span class="hljs-comment">// 0，共1字节，偏移地址是1的0倍</span><br>    <span class="hljs-keyword">double</span> c;<span class="hljs-comment">// 8~15，共8字节，偏移地址是8的1倍，故1~7需要填充</span><br>    <span class="hljs-keyword">short</span> d;<span class="hljs-comment">// 16~17，共2字节，偏移地址是2的8倍</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> <span class="hljs-title">t</span>;</span><span class="hljs-comment">// 24~39，共16字节，偏移地址是8（Test最宽成员大小为8）的3倍，故18~23需要填充</span><br>    <span class="hljs-keyword">int</span> a;<span class="hljs-comment">// 40~43，共4字节，偏移地址是4的10倍</span><br>&#125; Test3;<br><br></code></pre></td></tr></table></figure><h2 id='1-3'>3.针对结构体整体</h2><ul><li>(1).结构体的总大小为结构体最宽基本类型成员大小的整数倍；</li><li>(2).若最后所占空间小于整数倍，则在最末一个成员之后填充字节。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test1</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a;<span class="hljs-comment">// 0~3</span><br>    <span class="hljs-keyword">char</span> b;<span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">double</span> c;<span class="hljs-comment">// 8~15</span><br>    <span class="hljs-keyword">short</span> d;<span class="hljs-comment">// 16~17</span><br>&#125; Test1;<span class="hljs-comment">// 0~17总宽度18，最大成员为8，3*8=24，故结构体总宽度为24，18~23需要填充</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test2</span> &#123;</span><br>    <span class="hljs-keyword">char</span> b;<span class="hljs-comment">// 0</span><br>    <span class="hljs-keyword">double</span> c;<span class="hljs-comment">// 8~15</span><br>    <span class="hljs-keyword">short</span> d;<span class="hljs-comment">// 16~17</span><br>    <span class="hljs-keyword">int</span> a;<span class="hljs-comment">// 20~23</span><br>&#125; Test2;<span class="hljs-comment">// 0~23总宽度为24，最大成员为8，刚好是8的倍数，故结构体总宽度为24，不需要填充</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test3</span> &#123;</span><br>    <span class="hljs-keyword">char</span> b;<span class="hljs-comment">// 0，共1字节，偏移地址是1的0倍</span><br>    <span class="hljs-keyword">double</span> c;<span class="hljs-comment">// 8~15，共8字节，偏移地址是8的1倍，故1~7需要填充</span><br>    <span class="hljs-keyword">short</span> d;<span class="hljs-comment">// 16~17，共2字节，偏移地址是2的8倍</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> <span class="hljs-title">t</span>;</span><span class="hljs-comment">// 24~39，共16字节，偏移地址是8（Test最宽成员大小为8）的3倍，故18~23需要填充</span><br>    <span class="hljs-keyword">int</span> a;<span class="hljs-comment">// 40~43，共4字节，偏移地址是4的10倍</span><br>&#125; Test3;<span class="hljs-comment">// 0~43总宽度44，最大成员为8，6*8=48，故结构体总宽度为48，44~47需要填充</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#x39;&#57;&#x34;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;">&#x5f;&#x31;&#x39;&#57;&#x34;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发笔记</tag>
      
      <tag>结构体</tag>
      
      <tag>字节对齐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Wireshark抓包</title>
    <link href="/post/b24af2ae.html"/>
    <url>/post/b24af2ae.html</url>
    
    <content type="html"><![CDATA[<h2 id="【开发笔记】系列目录"><a href="#【开发笔记】系列目录" class="headerlink" title="【开发笔记】系列目录"></a><a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-注册真机设备"><a href="#1-注册真机设备" class="headerlink" title="1.注册真机设备"></a><a href="#1">1.注册真机设备</a></h3><h3 id="2-WireShark选择网口"><a href="#2-WireShark选择网口" class="headerlink" title="2.WireShark选择网口"></a><a href="#2">2.WireShark选择网口</a></h3><h3 id="3-常用过滤命令"><a href="#3-常用过滤命令" class="headerlink" title="3.常用过滤命令"></a><a href="#3">3.常用过滤命令</a></h3><span id="more"></span><hr><h1 id='1'>1.注册真机设备</h1>终端：</br><ul><li><code>rvictl -s UUID //注册</code></li><li><code>rvictl -l //查看结果</code></li></ul><h1 id='2'>2.WireShark选择网口</h1>选择`rvi0`网口，双击打开<h1 id='3'>3.常用过滤命令</h1><ul><li><code>and</code> 与</li><li><code>||</code> 或</li><li><code>ip.addr == host </code> 包含即可</li><li><code>ip.dst == host</code>目标</li><li><code>ip.src == host</code>源</li><li><code>udp</code></li><li><code>udp.port</code></li><li><code>tcp</code></li></ul><p>例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 筛选udp端口为233，源地址和目标地址包含192.168.0.233的命令</span><br>ip<span class="hljs-selector-class">.addr</span> == <span class="hljs-number">192.168</span>.<span class="hljs-number">0.233</span> and udp<span class="hljs-selector-class">.port</span> == <span class="hljs-number">233</span> <br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#x39;&#x39;&#52;&#x40;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109;">&#x5f;&#x31;&#x39;&#x39;&#52;&#x40;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a> </li></ul>]]></content>
    
    
    <categories>
      
      <category>开发笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发笔记</tag>
      
      <tag>Wireshark</tag>
      
      <tag>抓包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac生成多个ssh并配置不同域名</title>
    <link href="/post/4a6f7eb6.html"/>
    <url>/post/4a6f7eb6.html</url>
    
    <content type="html"><![CDATA[<h2 id="【开发笔记】系列目录"><a href="#【开发笔记】系列目录" class="headerlink" title="【开发笔记】系列目录"></a><a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h2><hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a><a href="#1">1.前言</a></h4><h4 id="2-生成一个SSH-Key"><a href="#2-生成一个SSH-Key" class="headerlink" title="2.生成一个SSH-Key"></a><a href="#2">2.生成一个SSH-Key</a></h4><h4 id="3-设置密码"><a href="#3-设置密码" class="headerlink" title="3.设置密码"></a><a href="#3">3.设置密码</a></h4><h4 id="4-重复步骤2和3，生成对应的rsa和rsa-pub文件"><a href="#4-重复步骤2和3，生成对应的rsa和rsa-pub文件" class="headerlink" title="4.重复步骤2和3，生成对应的rsa和rsa.pub文件"></a><a href="#4">4.重复步骤2和3，生成对应的rsa和rsa.pub文件</a></h4><h4 id="5-配置ssh-key到对应的域名"><a href="#5-配置ssh-key到对应的域名" class="headerlink" title="5.配置ssh-key到对应的域名"></a><a href="#5">5.配置ssh-key到对应的域名</a></h4><h5 id="nbsp-nbsp-1-在-ssh目录下生成一个config文件"><a href="#nbsp-nbsp-1-在-ssh目录下生成一个config文件" class="headerlink" title="&nbsp;&nbsp;(1).在~/.ssh目录下生成一个config文件"></a>&nbsp;&nbsp;<a href="#5-1">(1).在~/.ssh目录下生成一个config文件</a></h5><h5 id="nbsp-nbsp-2-配置config文件"><a href="#nbsp-nbsp-2-配置config文件" class="headerlink" title="&nbsp;&nbsp;(2).配置config文件"></a>&nbsp;&nbsp;<a href="#5-2">(2).配置config文件</a></h5><h4 id="6-将专有密钥添加到-ssh-agent-中"><a href="#6-将专有密钥添加到-ssh-agent-中" class="headerlink" title="6.将专有密钥添加到 ssh-agent 中"></a><a href="#6">6.将专有密钥添加到 ssh-agent 中</a></h4><h4 id="7-验证是否成功"><a href="#7-验证是否成功" class="headerlink" title="7.验证是否成功"></a><a href="#7">7.验证是否成功</a></h4><h4 id="8-将rsa-pub加入到GitHub-Gitlab等网站"><a href="#8-将rsa-pub加入到GitHub-Gitlab等网站" class="headerlink" title="8.将rsa.pub加入到GitHub/Gitlab等网站"></a><a href="#8">8.将rsa.pub加入到GitHub/Gitlab等网站</a></h4><h4 id="9-使用ssh而不是https-clone仓库"><a href="#9-使用ssh而不是https-clone仓库" class="headerlink" title="9.使用ssh而不是https clone仓库"></a><a href="#9">9.使用ssh而不是https clone仓库</a></h4><span id="more"></span><hr><h3 id='1'>1.前言</h3>有时候我们会有多个git账号，如GitHub，GitLab，这时如果使用同一个邮件注册，那不会有问题，但是假如用的是不同的邮件注册账号，这就需要生成不同的ssh文件并为其配置相应的域名。<h3 id='2'>2.生成一个SSH-Key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@email.com&quot;</span>//自己git账号对应的邮箱<br></code></pre></td></tr></table></figure>如若一路enter，你会得到：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">id_rsa<br>id_rsa.pub<br></code></pre></td></tr></table></figure><p>这样不是不可以，但是我们要生成多个，所以最好起有区分的名字。<br><img src="https://i.loli.net/2019/01/04/5c2f4e2bbb0ea.png" alt="默认"></p><h3 id='3'>3.设置密码</h3><p><img src="https://i.loli.net/2019/01/04/5c2f4e98d5bf5.png" alt="设置密码"><br>可以不设置，也可以键入密码</p><h3 id='4'>4.重复步骤2和3，生成对应的rsa和rsa.pub文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">//GitHub生成的对应ssh-key<br>id_github_ras   //私钥<br>id_github_ras.pub   //公钥<br><br>//Gitlab生成的对应ssh-key<br>id_gitlab_ras<br>id_gitlab_ras.pub<br></code></pre></td></tr></table></figure><h3 id='5'>5.配置ssh-key到对应的域名</h3><h4 id='5-1'>&nbsp;&nbsp;(1).在~/.ssh目录下生成一个config文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh<br>vim config<br></code></pre></td></tr></table></figure><h4 id='5-2'>&nbsp;&nbsp;(2).配置config文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host github<br>HostName github.com<br>User git<br>PreferredAuthentications publickey<br><span class="hljs-comment">#下面填写的是私钥名，没有pub后缀</span><br>IdentityFile ~/.ssh/id_github_rsa<br><br>Host gitlab<br>HostName gitlab.com<br>User git<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_gitlab_rsa <br></code></pre></td></tr></table></figure><h3 id='6'>6.将专有密钥添加到 ssh-agent 中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add ~./ssh/id_github_rsa<br>ssh-add ~./ssh/id_gitlab_rsa<br></code></pre></td></tr></table></figure>**tips:** </br>把专有密钥添加到 ssh-agent 中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add ~./ssh/id_rsa<br></code></pre></td></tr></table></figure>从 ssh-agent 中删除密钥<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add -d ./ssh/id_rsa.pub<br></code></pre></td></tr></table></figure>查看 ssh-agent 中的密钥<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add -l<br></code></pre></td></tr></table></figure><h3 id='7'>7.验证是否成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure>验证时提示是否continue，输入yes，若成功就会看到：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span> 。<br></code></pre></td></tr></table></figure><h3 id='8'>8.将rsa.pub加入到GitHub/Gitlab等网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat ~./ssh/id_github_rsa.pub<br></code></pre></td></tr></table></figure>将该字符串拷贝粘贴到Git网站对应添加ssh-key的地方：</br>GitHub:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Setting-&gt;SSH and GPG keys<br></code></pre></td></tr></table></figure>GitLab:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Setting-&gt;SSH keys<br></code></pre></td></tr></table></figure>其他网站自己找到添加ssh-key的位置，添加即可。<h3 id='9'>9.使用ssh而不是https clone仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:XXX/demo.git<br>git <span class="hljs-built_in">clone</span> git@gitlab.com:XXX/demo.git<br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#x39;&#x39;&#x34;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#x6d;">&#95;&#x31;&#x39;&#x39;&#x34;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发笔记</tag>
      
      <tag>Mac</tag>
      
      <tag>ssh</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Build for iOS but xxx build for iOS and iOS-Simulator</title>
    <link href="/post/oknmhy67.html"/>
    <url>/post/oknmhy67.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS错误与警告】系列目录"><a href="#【iOS错误与警告】系列目录" class="headerlink" title="【iOS错误与警告】系列目录"></a><a href="https://adrenine.github.io/post/e2m9iu6d.html">【iOS错误与警告】系列目录</a></h3><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>编译报错</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Building </span>for iOS, <span class="hljs-keyword">but </span>the linked <span class="hljs-keyword">and </span>embedded framework ‘xxx.framework’ was <span class="hljs-keyword">build </span>for iOS <span class="hljs-keyword">and </span>iOS-Simulator.<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">B<span class="hljs-function"><span class="hljs-title">uild</span> setting -&gt;</span> B<span class="hljs-function"><span class="hljs-title">uild</span> options -&gt;</span> Vaildate Workspace =&gt; YES<br></code></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3821f9bcd4a4bc695ea8d767519f2bb~tplv-k3u1fbpfcp-watermark.image"></p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#57;&#57;&#x34;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#109;">&#95;&#x31;&#57;&#57;&#x34;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】Longest Substring Without Repeating Characters</title>
    <link href="/post/8b62jk96.html"/>
    <url>/post/8b62jk96.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【LeetCode】系列目录"><a href="#【LeetCode】系列目录" class="headerlink" title="【LeetCode】系列目录"></a><a href="https://adrenine.github.io/post/d305db71.html">【LeetCode】系列目录</a></h3><hr><h3 id="LeetCode系列"><a href="#LeetCode系列" class="headerlink" title="LeetCode系列"></a><a href="https://adrenine.github.io/post/10fb75fe.html">LeetCode系列</a></h3><h4 id="Q：Given-a-string-find-the-length-of-the-longest-substring-without-repeating-characters"><a href="#Q：Given-a-string-find-the-length-of-the-longest-substring-without-repeating-characters" class="headerlink" title="Q：Given a string, find the length of the longest substring without repeating characters."></a>Q：Given a string, find the length of the longest substring without repeating characters.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">Example <span class="hljs-number">1</span>:<br><br>Input: <span class="hljs-string">&quot;abcabcbb&quot;</span><br>Output: <span class="hljs-number">3</span> <br>Explanation: The answer is <span class="hljs-string">&quot;abc&quot;</span>, with the length of <span class="hljs-number">3.</span> <br>Example <span class="hljs-number">2</span>:<br><br>Input: <span class="hljs-string">&quot;bbbbb&quot;</span><br>Output: <span class="hljs-number">1</span><br>Explanation: The answer is <span class="hljs-string">&quot;b&quot;</span>, with the length of <span class="hljs-number">1.</span><br>Example <span class="hljs-number">3</span>:<br><br>Input: <span class="hljs-string">&quot;pwwkew&quot;</span><br>Output: <span class="hljs-number">3</span><br>Explanation: The answer is <span class="hljs-string">&quot;wke&quot;</span>, with the length of <span class="hljs-number">3.</span> <br>             Note that the answer must be a substring, <span class="hljs-string">&quot;pwke&quot;</span> is a subsequence <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> a substring.<br></code></pre></td></tr></table></figure><span id="more"></span><hr><h4 id="E：给定一个字符串，计算出不重复的最长子串的长度。"><a href="#E：给定一个字符串，计算出不重复的最长子串的长度。" class="headerlink" title="E：给定一个字符串，计算出不重复的最长子串的长度。"></a>E：给定一个字符串，计算出不重复的最长子串的长度。</h4><h5 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">Example <span class="hljs-number">1</span>:<br>输入: <span class="hljs-string">&quot;abcabcbb&quot;</span><br>输出: <span class="hljs-number">3</span><br>解释: 最长不重复子串是<span class="hljs-string">&quot;acb&quot;</span>且长度为<span class="hljs-number">3</span><br><br>Example <span class="hljs-number">2</span>:<br>输入: <span class="hljs-string">&quot;bbbbb&quot;</span><br>输出: <span class="hljs-number">1</span><br>解释: 最长不重复子串是<span class="hljs-string">&quot;b&quot;</span>且长度为<span class="hljs-number">1</span><br>Example <span class="hljs-number">3</span>:<br><br>输入: <span class="hljs-string">&quot;pwwkew&quot;</span><br>输出: <span class="hljs-number">3</span><br>解释: 最长不重复子串是<span class="hljs-string">&quot;wke&quot;</span>且长度为<span class="hljs-number">3</span>，请注意答案必须是子串，<span class="hljs-string">&quot;pwke&quot;</span>是子序列而不是子串<br></code></pre></td></tr></table></figure><hr><h4 id="A"><a href="#A" class="headerlink" title="A:"></a>A:</h4><p>因为只需要计算最长长度，不需要记录子串，所以我们可以利用Dictionary或者Set不能重复的特性来存储当前遍历过的串，遇到相同字符，也就是key存在重复。</p><h5 id="Approach-1："><a href="#Approach-1：" class="headerlink" title="Approach 1："></a>Approach 1：</h5><p>方法一先考虑使用Dictionary的实现方式。这里key是遍历的字符，value是该字符在该字符串中的序号（不是下标）。我们使用一个变量记录当前子串的开始下标，当遇到重复字符的时候，这时我们需要去比较当前子串和上一个子串（若没有则为0）的长度，更新当前子串的开始下标（重复字符的下标加一或者还是当前开始下标），更新重复字符的下标，直到字符串遍历结束。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">s</span>: <span class="hljs-type">String</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">var</span> begin <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">//当前子串的开始下标</span><br>    <span class="hljs-keyword">var</span> maxLength <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">//当前获取的子串的最长长度</span><br>    <span class="hljs-keyword">var</span> map : [<span class="hljs-type">Character</span> : <span class="hljs-type">Int</span>] <span class="hljs-operator">=</span> [:]   <span class="hljs-comment">//key为字符，value为字符的序号（下标+1）</span><br>    <span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> s.enumerated() &#123;<span class="hljs-comment">//普通for循环与enumerated()性能差别很大，所以尽量使用enumerated()，在这个算法中，使用不同的for循环，性能相差达到100倍</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> existingIndex <span class="hljs-operator">=</span> map[value] &#123;<span class="hljs-comment">//存在重复字符</span><br>            begin <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(existingIndex, begin)<span class="hljs-comment">//更新当前子串的开始下标</span><br>        &#125;<br>        maxLength <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(maxLength, index<span class="hljs-operator">-</span>begin<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<span class="hljs-comment">//更新当前获取到的子串的最大长度</span><br>        map[value] <span class="hljs-operator">=</span> index<span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-comment">//更新重复字符的下标</span><br>        <span class="hljs-comment">// print(map)</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> maxLength<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Complexity-Analysis："><a href="#Complexity-Analysis：" class="headerlink" title="Complexity Analysis："></a>Complexity Analysis：</h5><ul><li>时间复杂度： O(n)。（LeetCode：64 ms）</li><li>空间复杂度：O(n)。</li></ul><hr><h5 id="Approach-2："><a href="#Approach-2：" class="headerlink" title="Approach 2："></a>Approach 2：</h5><p>方法二先考虑使用Set的实现方式。思路和方法一差不多，没有遇到相同字符的时候，将字符加入到Set中；遇到相同的字符时，更新最长子字符串的长度，更新当前子串的开始下标，同时判定当前字符串是不是重复的字符，若不是，将字符从Set中移除，当前子字符串的开始下标+1直到遇到相同字符。（如字符串是：”abcdecf”子字符是”abcde”，这时遇到相同字符’c’，需要将”ab”从Set中移除，begin指到第一个’c’的位置）。与方法一不同的是，如果最长的子字符是最后那个子串，这样是遍历不出的，所以还需要做一次比较：max(maxLength, charArray.count-begin)。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">s</span>: <span class="hljs-type">String</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">var</span> maxLength <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">var</span> begin <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-keyword">set</span> <span class="hljs-operator">=</span> <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Character</span>&gt;()<br>        <span class="hljs-keyword">let</span> charArray <span class="hljs-operator">=</span> <span class="hljs-type">Array</span>(s)<br>        <span class="hljs-keyword">for</span> (index, char) <span class="hljs-keyword">in</span> charArray.enumerated() &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">set</span>.contains(char) &#123;<br>                maxLength <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(maxLength, index<span class="hljs-operator">-</span>begin)<br>                <span class="hljs-keyword">while</span> charArray[begin] <span class="hljs-operator">!=</span> char &#123;<br>                    <span class="hljs-keyword">set</span>.remove(charArray[begin])<br>                    begin <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>                    <span class="hljs-comment">//print(set)</span><br>                &#125;<br>                begin <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>                <span class="hljs-comment">//print(set)</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">set</span>.insert(char)<br>                <span class="hljs-comment">//print(set)</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxLength, charArray.count<span class="hljs-operator">-</span>begin)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Complexity-Analysis：-1"><a href="#Complexity-Analysis：-1" class="headerlink" title="Complexity Analysis："></a>Complexity Analysis：</h5><ul><li>时间复杂度： O(n)。（LeetCode：76 ms）</li><li>空间复杂度：O(n)。</li></ul><hr><h5 id="Approach-3："><a href="#Approach-3：" class="headerlink" title="Approach 3："></a>Approach 3：</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">s</span>: <span class="hljs-type">String</span>)</span> -&gt; <span class="hljs-type">Int</span> &#123;<br>         <span class="hljs-keyword">var</span> hash <span class="hljs-operator">=</span> [<span class="hljs-type">Int</span>](repeating: <span class="hljs-number">0</span>, count: <span class="hljs-number">256</span>)<br>        <span class="hljs-keyword">let</span> str <span class="hljs-operator">=</span> <span class="hljs-type">Array</span>(s.utf8).map &#123; <span class="hljs-type">Int</span>(<span class="hljs-variable">$0</span>) &#125;<br>        <br>        <span class="hljs-keyword">let</span> len <span class="hljs-operator">=</span> str.count<br>        <span class="hljs-keyword">var</span> ans <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">var</span> j <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>len &#123;<br>            <span class="hljs-keyword">while</span> j <span class="hljs-operator">&lt;</span> len <span class="hljs-operator">&amp;&amp;</span> hash[str[j]] <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123;<br>                hash[str[j]] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>                j <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>                <span class="hljs-built_in">print</span>(hash)<br>            &#125;<br>            ans <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(ans, j <span class="hljs-operator">-</span> i)<br>            hash[str[i]] <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>            <span class="hljs-built_in">print</span>(hash)<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Complexity-Analysis：-2"><a href="#Complexity-Analysis：-2" class="headerlink" title="Complexity Analysis："></a>Complexity Analysis：</h5><ul><li>时间复杂度： O(n)。（LeetCode：36 ms）</li><li>空间复杂度：O(n)。</li></ul><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#57;&#x39;&#x34;&#x40;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;">&#95;&#x31;&#57;&#x39;&#x34;&#x40;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】Add Two Numbers</title>
    <link href="/post/c65eh7y4.html"/>
    <url>/post/c65eh7y4.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【LeetCode】系列目录"><a href="#【LeetCode】系列目录" class="headerlink" title="【LeetCode】系列目录"></a><a href="https://adrenine.github.io/post/d305db71.html">【LeetCode】系列目录</a></h3><hr><h3 id="LeetCode系列"><a href="#LeetCode系列" class="headerlink" title="LeetCode系列"></a><a href="https://adrenine.github.io/post/10fb75fe.html">LeetCode系列</a></h3><h4 id="Q：You-are-given-two-non-empty-linked-lists-representing-two-nonnegative-integers-The-digits-are-stored-in-reverse-order-and-each-of-their-nodes-contain-a-single-digit-Add-the-two-numbers-and-return-it-as-a-linked-list"><a href="#Q：You-are-given-two-non-empty-linked-lists-representing-two-nonnegative-integers-The-digits-are-stored-in-reverse-order-and-each-of-their-nodes-contain-a-single-digit-Add-the-two-numbers-and-return-it-as-a-linked-list" class="headerlink" title="Q：You are given two non-empty linked lists representing two nonnegative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list."></a>Q：You are given two non-empty linked lists representing two nonnegative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">You may assume the two numbers <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> contain any leading zero, except the number <span class="hljs-number">0</span> itself.<br><br>Example:<br><br>Input: (<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>Output: <span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br>Explanation: <span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807.</span><br></code></pre></td></tr></table></figure><hr><h4 id="E：给定两个非空链表代表两个非负整数，这两个数字被逆序存储并且他们的每一个节点只存一个单一数字，返回这两个数字加起来组合成的新链表。"><a href="#E：给定两个非空链表代表两个非负整数，这两个数字被逆序存储并且他们的每一个节点只存一个单一数字，返回这两个数字加起来组合成的新链表。" class="headerlink" title="E：给定两个非空链表代表两个非负整数，这两个数字被逆序存储并且他们的每一个节点只存一个单一数字，返回这两个数字加起来组合成的新链表。"></a>E：给定两个非空链表代表两个非负整数，这两个数字被逆序存储并且他们的每一个节点只存一个单一数字，返回这两个数字加起来组合成的新链表。</h4><span id="more"></span><h5 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">你可以假设这两个数字不是<span class="hljs-number">0</span>开头，除了<span class="hljs-number">0</span>它自己<br>输入：<br>链表<span class="hljs-number">1</span>：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) 链表<span class="hljs-number">2</span>：(<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>因为<span class="hljs-number">342</span> + <span class="hljs-number">465</span>=<span class="hljs-number">807</span>，所以<br>输出：<br>新链表：<br><span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><hr><h4 id="A"><a href="#A" class="headerlink" title="A:"></a>A:</h4><h5 id="Approach："><a href="#Approach：" class="headerlink" title="Approach："></a>Approach：</h5><p>因为链表存储顺序刚好和我们做加法的顺序一致，所以我们只需要按照正常数学加法来操作这两个数字即可。<br>每次拿链表1和链表2的一个元素相加，这个时候可能会有几种情况：<br>a、链表1和链表2长度不相等，此时取值一个能取，一个已经没有了；<br>b、链表1和链表2相加，有进位；<br>c、链表其中一个没有元素，一个还有元素且此时还有进位，需要元素与进位相加；<br>d、都没有元素，但是此时还有进位。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTwoNumbers</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">l1</span>: <span class="hljs-type">ListNode</span>?, <span class="hljs-keyword">_</span> <span class="hljs-params">l2</span>: <span class="hljs-type">ListNode</span>?)</span> -&gt; <span class="hljs-type">ListNode</span>? &#123;<br>        <br>        <span class="hljs-keyword">let</span> header <span class="hljs-operator">=</span> <span class="hljs-type">ListNode</span>(<span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">var</span> list1 <span class="hljs-operator">=</span> l1, list2 <span class="hljs-operator">=</span> l2, carry <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, tempNode <span class="hljs-operator">=</span> header<br>        <span class="hljs-keyword">while</span> list1 <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">||</span> list2 <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">||</span> carry <span class="hljs-operator">!=</span> <span class="hljs-number">0</span> &#123;<span class="hljs-comment">//考虑上面提到的a，b，c，d四种情况</span><br>            <span class="hljs-keyword">if</span> list1 <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;<br>                carry <span class="hljs-operator">+=</span> list1<span class="hljs-operator">!</span>.val<br>                list1 <span class="hljs-operator">=</span> list1<span class="hljs-operator">?</span>.next<br>            &#125;<br>            <span class="hljs-keyword">if</span> list2 <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;<br>                carry <span class="hljs-operator">+=</span> list2<span class="hljs-operator">!</span>.val<br>                list2 <span class="hljs-operator">=</span> list2<span class="hljs-operator">?</span>.next<br>            &#125;<br>            tempNode.next <span class="hljs-operator">=</span> <span class="hljs-type">ListNode</span>(carry<span class="hljs-operator">%</span><span class="hljs-number">10</span>)<br>            tempNode <span class="hljs-operator">=</span> tempNode.next<span class="hljs-operator">!</span><br>            carry <span class="hljs-operator">/=</span> <span class="hljs-number">10</span><span class="hljs-comment">//获取进位，如果没有，则为0</span><br><br>        &#125;<br>        <span class="hljs-keyword">return</span> header.next<span class="hljs-comment">//因为一开始实例化的是ListNode(0) ，所以要从下一个开始，不然会多一个0元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Complexity-Analysis："><a href="#Complexity-Analysis：" class="headerlink" title="Complexity Analysis："></a>Complexity Analysis：</h5><ul><li>时间复杂度： O(n)。（LeetCode：64 ms）</li><li>空间复杂度：O(n)。</li></ul><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#57;&#57;&#x34;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#x6d;">&#95;&#49;&#57;&#57;&#x34;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在@protocol 和 category 中如何使用 @property</title>
    <link href="/post/4a8q20e0.html"/>
    <url>/post/4a8q20e0.html</url>
    
    <content type="html"><![CDATA[<h3 id="【靠谱程序员】系列目录"><a href="#【靠谱程序员】系列目录" class="headerlink" title="【靠谱程序员】系列目录"></a><a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h3><hr><h3 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h3><p>在@protocol 和 category 中如何使用 @property</p><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><ul><li><p>1、在 protocol 中使用 property 只会生成 setter 和 getter 方法声明，我们使用属性的目的，是希望遵守我协议的对象能实现该属性</p></li><li><p>2、category 使用 @property 也是只会生成 setter 和 getter 方法的声明，如果我们真的需要给 category 增加属性的实现，需要借助于运行时的两个函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc">objc_setAssociatedObject<br>objc_getAssociatedObject<br></code></pre></td></tr></table></figure></li></ul><span id="more"></span><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//Person.h</span><br><span class="hljs-comment">// 本类头文件及实现文件</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-comment">// 声明一个属性</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//Person.m</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Person.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br><br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure><p>Person+Extension.h</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 分类头文件及实现文件</span><br><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Person.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> (<span class="hljs-title">Extension</span>)</span><br><br><span class="hljs-comment">// 分类中声明属性，只会生成setter和getter方法的声明，不会生成带“_”的成员变量和setter和getter方法的实现</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span> age;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>Person+Extension.m</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Person+Extension.h&quot;</span></span><br><br><span class="hljs-comment">// 使用运行时，需要导入头文件</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span> (<span class="hljs-title">Extension</span>)</span><br><br>- (<span class="hljs-keyword">void</span>)setAge:(<span class="hljs-built_in">NSInteger</span>)age&#123;<br>    <span class="hljs-comment">// 使用运行时关联对象，person对象(self)强引用age对象，并且设置标记为&quot;age&quot;(可以根据该标记来获取引用的对象age，标记可以为任意字符，只要setter和getter中的标记一致就可以)</span><br>    <span class="hljs-comment">// 参数1：源对象</span><br>    <span class="hljs-comment">// 参数2：关联时用来标记属性的key(因为可能要添加很多属性)，很多人习惯使用char *类型的key，如static char *key = &quot;age&quot;，那这里需要传入&amp;key，但是使用iOS的NSString类型的字符常量也是可以的，目测估计这里需要内存地址一致，有兴趣可以试试给objc_setAssociatedObject的key对象 new一个NSString然后再objc_getAssociatedObject的key new一个新的字面量相同的新的key对象</span><br>    <span class="hljs-comment">// 参数3：关联的对象</span><br>    <span class="hljs-comment">// 参数4：关联策略</span><br>    objc_setAssociatedObject(<span class="hljs-keyword">self</span>， <span class="hljs-string">@&quot;age&quot;</span>， @(age)， OBJC_ASSOCIATION_RETAIN);<br>&#125;<br><br>- (<span class="hljs-built_in">NSInteger</span>)age&#123;<br>    <span class="hljs-comment">// 根据“age”标识取person对象(self)强引用的age对象</span><br>    <span class="hljs-comment">// 参数1：源对象</span><br>    <span class="hljs-comment">// 参数2：关联时用来标记属性的key(因为可能要添加很多属性)</span><br>    <span class="hljs-keyword">return</span> [objc_getAssociatedObject(<span class="hljs-keyword">self</span>， <span class="hljs-string">@&quot;age&quot;</span>) integerValue];<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>objc_AssociationPolicy的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    OBJC_ASSOCIATION_ASSIGN = <span class="hljs-number">0</span>,    <span class="hljs-comment">//assign</span><br>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="hljs-number">1</span>,  <span class="hljs-comment">//retain</span><br>    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="hljs-number">3</span>,    <span class="hljs-comment">//copy</span><br>    OBJC_ASSOCIATION_RETAIN = <span class="hljs-number">01401</span>,<br>    OBJC_ASSOCIATION_COPY = <span class="hljs-number">01403</span><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#x39;&#57;&#x34;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#x6d;">&#x5f;&#x31;&#x39;&#57;&#x34;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>靠谱程序员</category>
      
    </categories>
    
    
    <tags>
      
      <tag>靠谱程序员</tag>
      
      <tag>协议</tag>
      
      <tag>protocol</tag>
      
      <tag>category</tag>
      
      <tag>分类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？</title>
    <link href="/post/87yc6ef.html"/>
    <url>/post/87yc6ef.html</url>
    
    <content type="html"><![CDATA[<h3 id="【靠谱程序员】系列目录"><a href="#【靠谱程序员】系列目录" class="headerlink" title="【靠谱程序员】系列目录"></a><a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h3><hr><h3 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h3><p>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？</p><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><h4 id="1、-property-的本质"><a href="#1、-property-的本质" class="headerlink" title="1、@property 的本质"></a>1、@property 的本质</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> = ivar + <span class="hljs-keyword">getter</span> + <span class="hljs-keyword">setter</span><br></code></pre></td></tr></table></figure><p>翻译出来就是：<br>属性（property）= 实例变量（ivar）+ 存取方法（getter和setter）<br>实例变量用于存储数据<br>存取方法用来读取写入该实例变量的数据<br>（有swift开发经验的人对这个感触应该表较深（存储属性和计算属性））<br>编译器会自动为@property添加实例变量和存取方法，当你重写存取方法中的一个的时候不用手动写实例变量：<code>@synthesize name = _name;</code>，但是当你同时重写setter和getter方法时，你需要添加这行代码才能通过编译。</p><span id="more"></span><hr><h4 id="2、ivar、getter、setter-是如何生成并添加到这个类中的？"><a href="#2、ivar、getter、setter-是如何生成并添加到这个类中的？" class="headerlink" title="2、ivar、getter、setter 是如何生成并添加到这个类中的？"></a>2、ivar、getter、setter 是如何生成并添加到这个类中的？</h4><p>“自动合成”( autosynthesis)<br>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br><span class="hljs-keyword">@synthesize</span> firstName = _myFirstName;<br><span class="hljs-keyword">@synthesize</span> lastName = _myLastName;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>反编译相关的代码，他大致生成了五个东西</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">OBJC_IVAR_<span class="hljs-variable">$类</span>名<span class="hljs-variable">$属</span>性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。<br>setter 与 getter 方法对应的实现函数<br>ivar_list ：成员变量列表<br>method_list ：方法列表<br>prop_list ：属性列表<br></code></pre></td></tr></table></figure><p>也就是说我们每次在增加一个属性，系统都会在 ivar_list 中添加一个成员变量的描述，在 method_list 中增加 setter 与 getter 方法的描述，在属性列表中增加一个属性的描述，然后计算该属性在对象中的偏移量，然后给出 setter 与 getter 方法对应的实现，在 setter 方法中从偏移量的位置开始赋值，在 getter 方法中从偏移量开始取值，为了能够读取正确字节数，系统对象偏移量的指针类型进行了类型强转。</p><hr><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>property在runtime中是objc_property_t定义如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_property *objc_property_t;<br></code></pre></td></tr></table></figure><p>而objc_property是一个结构体，包括name和attributes，定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> property_t &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *attributes;<br>&#125;;<br></code></pre></td></tr></table></figure><p>而attributes本质是objc_property_attribute_t，定义了property的一些属性，定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// Defines a property attribute</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;           <span class="hljs-comment">/**&lt; The name of the attribute */</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *value;          <span class="hljs-comment">/**&lt; The value of the attribute (usually empty) */</span><br>&#125; objc_property_attribute_t;<br></code></pre></td></tr></table></figure><p>而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。</p><p>例如：我们定义一个string的property<code>@property (nonatomic, copy) NSString *string;</code>，通过 <code>property_getAttributes(property)</code>获取到attributes并打印出来之后的结果为T@”NSString”，C，N，V_string</p><p>其中T就代表类型，可参阅<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encodings</a>，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。</p><table><thead><tr><th align="center">Code</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="center">c</td><td align="left">A char</td></tr><tr><td align="center">i</td><td align="left">An int</td></tr><tr><td align="center">s</td><td align="left">A short</td></tr><tr><td align="center">l</td><td align="left">A long l is treated as a 32-bit quantity on 64-bit programs.</td></tr><tr><td align="center">q</td><td align="left">A long long</td></tr><tr><td align="center">C</td><td align="left">An unsigned char</td></tr><tr><td align="center">I</td><td align="left">An unsigned int</td></tr><tr><td align="center">S</td><td align="left">An unsigned short</td></tr><tr><td align="center">L</td><td align="left">An unsigned long</td></tr><tr><td align="center">Q</td><td align="left">An unsigned long long</td></tr><tr><td align="center">f</td><td align="left">A float</td></tr><tr><td align="center">d</td><td align="left">A double</td></tr><tr><td align="center">B</td><td align="left">A C++ bool or a C99 _Bool</td></tr><tr><td align="center">v</td><td align="left">A void</td></tr><tr><td align="center">*</td><td align="left">A character string (char *)</td></tr><tr><td align="center">@</td><td align="left">An object (whether statically typed or typed id)</td></tr><tr><td align="center">#</td><td align="left">A class object (Class)</td></tr><tr><td align="center">:</td><td align="left">A method selector (SEL)</td></tr><tr><td align="center">[array type]</td><td align="left">An array</td></tr><tr><td align="center">{name=type…}</td><td align="left">A structure</td></tr><tr><td align="center">(name=type…)</td><td align="left">A union</td></tr><tr><td align="center">bnum</td><td align="left">A bit field of num bits</td></tr><tr><td align="center">^type</td><td align="left">A pointer to type</td></tr><tr><td align="center">?</td><td align="left">An unknown type (among other things， this code is used for function pointers)</td></tr></tbody></table><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#57;&#57;&#52;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;">&#x5f;&#x31;&#57;&#57;&#52;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>靠谱程序员</category>
      
    </categories>
    
    
    <tags>
      
      <tag>靠谱程序员</tag>
      
      <tag>属性</tag>
      
      <tag>runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</title>
    <link href="/post/5fa0ub2h.html"/>
    <url>/post/5fa0ub2h.html</url>
    
    <content type="html"><![CDATA[<h3 id="【靠谱程序员】系列目录"><a href="#【靠谱程序员】系列目录" class="headerlink" title="【靠谱程序员】系列目录"></a><a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h3><hr><h3 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h3><p>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</p><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><h4 id="1、让自己的类可以使用copy修饰符"><a href="#1、让自己的类可以使用copy修饰符" class="headerlink" title="1、让自己的类可以使用copy修饰符"></a>1、让自己的类可以使用copy修饰符</h4><ul><li>（1）、让自己的类遵循NSCopying协议</li><li>（2）、实现NSCopying协议中必须实现的代理方法：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">id</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone;<br></code></pre></td></tr></table></figure><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">id</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone &#123;<br>    <span class="hljs-comment">//创建实例的方式比较特殊</span><br>    Person *p = [[[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] allocWithZone:zone] init];   <br>    <br>    p.name = <span class="hljs-keyword">self</span>.name;<br>    p.age = <span class="hljs-keyword">self</span>.age;<br>    <br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><span id="more"></span><h4 id="2、如何重写带copy关键字的setter"><a href="#2、如何重写带copy关键字的setter" class="headerlink" title="2、如何重写带copy关键字的setter"></a>2、如何重写带copy关键字的setter</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-comment">//[_name release];</span><br>    _name = [name <span class="hljs-keyword">copy</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="Copy-amp-MutableCopy"><a href="#Copy-amp-MutableCopy" class="headerlink" title="Copy &amp; MutableCopy"></a>Copy &amp; MutableCopy</h4><p>使用copy或mutableCopy方法可以创建一个对象的副本</p><ul><li><strong>copy</strong><br>需要实现NSCoppying协议<br>这些创建的是不可变副本(如NSString、NSArray、NSDictionary)</li><li><strong>mutableCopy</strong><br>需要先实现NSMutableCopying协议<br>创建的是可变副本(如NSMutableString、NSMutableArray、NSMutableDictionary)</li><li><strong>copy的目的</strong>是建立副本，同时修改原始对象和复本不会互相干扰</li></ul><p>查看上篇博客，了解更多关于<a href="https://adrenine.github.io/post/b5y4dc3.html">深拷贝 &amp; 浅拷贝</a>的内容</p><ul><li><strong>深拷贝</strong><br>内容拷贝，源对象和副本指向的是不同的两个对象<br>源对象引用计数器不变，副本计数器设置为1</li><li><strong>浅拷贝</strong><br>指针拷贝，源对象和副本指向的是同一个对象<br>对象的引用计数器+1，其实相当于做了一次retain操作</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>只有不可变对象创建不可变副本(copy)才是浅复制，其他都是深复制</strong></p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#x39;&#x39;&#x34;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;">&#x5f;&#x31;&#x39;&#x39;&#x34;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>靠谱程序员</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>靠谱程序员</tag>
      
      <tag>深拷贝</tag>
      
      <tag>浅拷贝</tag>
      
      <tag>协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这个写法会出什么问题： @property (copy) NSMutableArray *array</title>
    <link href="/post/b5y4dc3.html"/>
    <url>/post/b5y4dc3.html</url>
    
    <content type="html"><![CDATA[<h3 id="【靠谱程序员】系列目录"><a href="#【靠谱程序员】系列目录" class="headerlink" title="【靠谱程序员】系列目录"></a><a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h3><hr><h3 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h3><p>这个写法会出什么问题： </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSMutableArray</span> *array;<br></code></pre></td></tr></table></figure><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><ul><li>(1）、copy修饰的属性进行赋值的时候会生成一份不可变的副本，此时修改副本array（增删之类的操作）会提示找不到方法而报异常；</li><li>(2）、不写原子性修饰词默认使用atomic，而atomic性能比nonatomic差很多。</li></ul><hr><h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><ul><li><a href="#4-1">浅拷贝</a><ul><li><a href="#4-1-1">不可变对象的不可变拷贝</a></li></ul></li><li><a href="#4-2">深拷贝</a><ul><li><a href="#4-2-1">可变对象的可变拷贝</a></li><li><a href="#4-2-2">可变对象的不可变拷贝</a></li><li><a href="#4-2-3">不可变对象的可变拷贝</a>    </li></ul></li><li><a href="#4-3">总结</a><h4 id='4-1'> 浅拷贝：指针拷贝，不生成新对象</h4><h5 id='4-1-1'> 不可变对象的不可变拷贝</h5></li></ul><span id="more"></span><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *array = [<span class="hljs-built_in">NSArray</span> array];<br><br><span class="hljs-comment">//相同地址        </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,array);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,[array <span class="hljs-keyword">copy</span>]);<br><br><span class="hljs-comment">// __NSArray0 (不可变数组)      </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([[array <span class="hljs-keyword">copy</span>] <span class="hljs-keyword">class</span>]));<br></code></pre></td></tr></table></figure><p>输出：<br><img src="https://i.loli.net/2019/04/12/5cb024c78c620.png" alt="在这里插入图片描述"></p><hr><h4 id='4-2'> 深拷贝：生成一个新对象，对象内容相同（ 除浅拷贝那种情况，其他都是深拷贝）</h4><h5 id='4-2-1'>  可变对象的可变拷贝 </h5>    <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSMutableArray</span> *mutArray = [<span class="hljs-built_in">NSMutableArray</span> array];<br><br><span class="hljs-comment">//输出不同地址   </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,mutArray);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,[mutArray mutableCopy]);<br><br><span class="hljs-comment">// __NSArrayM （可变数组）</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([[mutArray mutableCopy] <span class="hljs-keyword">class</span>]));<br></code></pre></td></tr></table></figure>输出：![在这里插入图片描述](https://i.loli.net/2019/04/12/5cb0253253451.png)<h5 id='4-2-2'> 可变对象的不可变拷贝    </h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSMutableArray</span> *mutArray = [<span class="hljs-built_in">NSMutableArray</span> array];<br><span class="hljs-comment">//不同地址      </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,mutArray);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,[mutArray <span class="hljs-keyword">copy</span>]);<br><br><span class="hljs-comment">// __NSArray0</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([[mutArray <span class="hljs-keyword">copy</span>] <span class="hljs-keyword">class</span>]));<br></code></pre></td></tr></table></figure><p>输出：<br><img src="https://i.loli.net/2019/04/12/5cb0257999966.png" alt="在这里插入图片描述"></p><h5 id='4-2-3'> 不可变对象的可变拷贝    </h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *array = [<span class="hljs-built_in">NSArray</span> array];<br><br><span class="hljs-comment">//不同对象  </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,array);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,[array mutableCopy]);<br><span class="hljs-comment">// __NSArrayM    </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([[array mutableCopy] <span class="hljs-keyword">class</span>]));<br></code></pre></td></tr></table></figure><p>输出：<br><img src="https://i.loli.net/2019/04/12/5cb025b3269ed.png" alt="在这里插入图片描述"></p><hr><h4 id='4-2'> 总结</h4><p><strong>除不可变对象的不可变拷贝为浅拷贝，其余都是深拷贝</strong><br><img src="https://i.loli.net/2019/04/12/5cb026d4b7035.png" alt="在这里插入图片描述"></p><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#x39;&#x39;&#x34;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;">&#x5f;&#x31;&#x39;&#x39;&#x34;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>靠谱程序员</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>靠谱程序员</tag>
      
      <tag>修饰词</tag>
      
      <tag>深拷贝</tag>
      
      <tag>浅拷贝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎么用 copy 关键字？</title>
    <link href="/post/1g2rp43e.html"/>
    <url>/post/1g2rp43e.html</url>
    
    <content type="html"><![CDATA[<h3 id="【靠谱程序员】系列目录"><a href="#【靠谱程序员】系列目录" class="headerlink" title="【靠谱程序员】系列目录"></a><a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h3><hr><h3 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h3><p>怎么用 copy 关键字？</p><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><ul><li>（1）、一般对于那些遵循NSCopying协议的类才能使用copy，例如针对那些有不可变类型和可变类型的类，NSString, NSArray 与之对应的是NSMutableString, NSMutableArray等。因为他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</li><li>（2）、block一般也使用copy，这是MRC遗留下来的使用习惯<h5 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h5>  在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写<br>  不写都行：对于 block 使用copy还是strong效果是一样的，但写上copy也无伤大雅，还<br>  能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用<br>  者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会<br>  在调用之前自行拷贝属性值。这种操作多余而低效。你也许会对这种做法有些怪异，不需要写却<br>  依然写。</li></ul><span id="more"></span>  <hr><p><strong>示例：</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *userId;<br><br>- (<span class="hljs-keyword">instancetype</span>)initWithUserId:(<span class="hljs-built_in">NSString</span> *)userId &#123;<br>   <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];<br>   <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>) &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>   &#125;<br>   _userId = [userId <span class="hljs-keyword">copy</span>];<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#57;&#x39;&#x34;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;">&#x5f;&#x31;&#57;&#x39;&#x34;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>靠谱程序员</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>靠谱程序员</tag>
      
      <tag>属性</tag>
      
      <tag>修饰词</tag>
      
      <tag>Copy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么情况使用 weak 关键字，相比 assign 有什么不同？</title>
    <link href="/post/f9d3oq4d.html"/>
    <url>/post/f9d3oq4d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【靠谱程序员】系列目录"><a href="#【靠谱程序员】系列目录" class="headerlink" title="【靠谱程序员】系列目录"></a><a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h3><hr><h3 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h3><p>什么情况使用 weak 关键字，相比 assign 有什么不同？</p><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><ul><li>1、什么情况下使用weak：<ul><li> a、在ARC中修饰代理</li><li> b、使用@IBOutlet连接控件</li><li> c、当block会造成循环引用</li></ul></li><li>2、与assign的不同<ul><li> assign可以用于非对象类型，而weak必须用于对象类型</li></ul></li></ul><span id="more"></span><hr><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><h5 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h5><ul><li><p>a、修饰变量类型的区别<br>weak 只可以修饰对象。如果修饰基本数据类型，编译器会报错-“Property with ‘weak’ attribute must be of object type”。<br>assign 可修饰对象，和基本数据类型。当需要修饰对象类型时，MRC时代使用unsafe_unretained。当然，unsafe_unretained也可能产生野指针，所以它名字是”unsafe_”。</p></li><li><p>b、是否产生野指针的区别<br>weak 不会产生野指针问题。因为weak修饰的对象释放后（引用计数器值为0），指针会自动被置nil，之后再向该对象发消息也不会崩溃。 weak是安全的。<br>assign 如果修饰对象，会产生野指针问题；如果修饰基本数据类型则是安全的。修饰的对象释放后，指针不会自动被置空，此时向对象发消息会崩溃。</p></li></ul><h5 id="2、相似"><a href="#2、相似" class="headerlink" title="2、相似"></a>2、相似</h5><p>都可以修饰对象类型，但是assign修饰对象会存在问题。</p><h5 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h5><ul><li>assign 适用于基本数据类型如int,float,struct等值类型，不适用于引用类型。因为值类型会被放入栈中，遵循先进后出原则，由系统负责管理栈内存。而引用类型会被放入堆中，需要我们自己手动管理内存或通过ARC管理。</li><li>weak 适用于delegate和block等引用类型，不会导致野指针问题，也不会循环引用，非常安全。</li></ul><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#57;&#x39;&#x34;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;">&#95;&#49;&#57;&#x39;&#x34;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>靠谱程序员</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>靠谱程序员</tag>
      
      <tag>属性</tag>
      
      <tag>修饰词</tag>
      
      <tag>ARC</tag>
      
      <tag>MRC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码风格优化与纠错</title>
    <link href="/post/f829ea4b.html"/>
    <url>/post/f829ea4b.html</url>
    
    <content type="html"><![CDATA[<h3 id="【靠谱程序员】系列目录"><a href="#【靠谱程序员】系列目录" class="headerlink" title="【靠谱程序员】系列目录"></a><a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h3><hr><h3 id="问：风格纠错"><a href="#问：风格纠错" class="headerlink" title="问：风格纠错"></a>问：风格纠错</h3><p><img src="https://i.loli.net/2020/06/01/Ug4OPqnSKxtNX85.png" alt="风格纠错"></p><span id="more"></span><hr><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 1.使用NS_ENUM而不是C语言类型的枚举enum</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_ENUM</span>(<span class="hljs-built_in">NSInteget</span>, XBYGender) &#123; <span class="hljs-comment">//使用gender比sex正式</span><br>    XBYGenderMan,<br>    XBYGenderWoman<br>&#125;<br><br><span class="hljs-comment">// 2.一般定义一个初始化方法来对属性进行赋值，而把具体属性隐藏起来（放.m文件中），</span><br><span class="hljs-comment">// 或者设置为只读，不可外部修改（这里倾向于设置为只读）</span><br><br><span class="hljs-comment">// 3.NSString一般使用copy修饰</span><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><br><span class="hljs-comment">// 4.和enum一样，尽量避免c语言的内容，将int改成NSInteger或者NSUInteger</span><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSUInteger</span> age;<br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">assign</span>) XBYGender gender;<br><br><span class="hljs-comment">// 5.初始化一般是一个实例化方法一个工厂方法</span><br><span class="hljs-comment">// 6.初始化应该把属性都有对应的赋值</span><br><span class="hljs-comment">// 7/返回值一般用instancetype而不是id</span><br><br>+ (<span class="hljs-keyword">instancetype</span>)initWithUserName:(<span class="hljs-built_in">NSString</span> *)name age:(<span class="hljs-built_in">NSUInteger</span>)age gender:(XBYGender)genger;<br>- (<span class="hljs-keyword">instancetype</span>)initWithUserName:(<span class="hljs-built_in">NSString</span> *)name age:(<span class="hljs-built_in">NSUInteger</span>)age gender:(XBYGender)genger;<br><br><span class="hljs-comment">// 8.login本来就有动作的意思，不需要do</span><br>- (<span class="hljs-keyword">void</span>)login;<br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#x39;&#57;&#x34;&#x40;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d;">&#x5f;&#x31;&#x39;&#57;&#x34;&#x40;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>靠谱程序员</category>
      
    </categories>
    
    
    <tags>
      
      <tag>靠谱程序员</tag>
      
      <tag>代码风格</tag>
      
      <tag>纠错</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS内存管理</title>
    <link href="/post/evbcd26d.html"/>
    <url>/post/evbcd26d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="1-weak的实现原理-SideTable的结构是什么样的"><a href="#1-weak的实现原理-SideTable的结构是什么样的" class="headerlink" title="1.weak的实现原理? SideTable的结构是什么样的"></a>1.weak的实现原理? SideTable的结构是什么样的</h3><h3 id="2-关联对象的应用-系统如何实现关联对象的"><a href="#2-关联对象的应用-系统如何实现关联对象的" class="headerlink" title="2.关联对象的应用?系统如何实现关联对象的"></a>2.关联对象的应用?系统如何实现关联对象的</h3><h3 id="3-关联对象的如何进行內存管理的-关联对象如何实现weak属性"><a href="#3-关联对象的如何进行內存管理的-关联对象如何实现weak属性" class="headerlink" title="3.关联对象的如何进行內存管理的?关联对象如何实现weak属性"></a>3.关联对象的如何进行內存管理的?关联对象如何实现weak属性</h3><h3 id="4-Autoreleasepoo-l的原理-所使用的的数据结构是什么"><a href="#4-Autoreleasepoo-l的原理-所使用的的数据结构是什么" class="headerlink" title="4. Autoreleasepoo l的原理?所使用的的数据结构是什么"></a>4. Autoreleasepoo l的原理?所使用的的数据结构是什么</h3><h3 id="5-ARC的实现原理-ARC下对-retain-amp-release做了哪些优化"><a href="#5-ARC的实现原理-ARC下对-retain-amp-release做了哪些优化" class="headerlink" title="5.ARC的实现原理?ARC下对 retain&amp; release做了哪些优化"></a>5.ARC的实现原理?ARC下对 retain&amp; release做了哪些优化</h3><h3 id="6-ARC下哪些情况会造成内存泄漏"><a href="#6-ARC下哪些情况会造成内存泄漏" class="headerlink" title="6.ARC下哪些情况会造成内存泄漏"></a>6.ARC下哪些情况会造成内存泄漏</h3><span id="more"></span><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#x39;&#57;&#52;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#x6d;">&#95;&#x31;&#x39;&#57;&#52;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUICatalog Invalid asset name supplied</title>
    <link href="/post/nmuyt54s.html"/>
    <url>/post/nmuyt54s.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS错误与警告】系列目录"><a href="#【iOS错误与警告】系列目录" class="headerlink" title="【iOS错误与警告】系列目录"></a><a href="https://adrenine.github.io/post/e2m9iu6d.html">【iOS错误与警告】系列目录</a></h3><hr><h3 id="Xcode警告"><a href="#Xcode警告" class="headerlink" title="Xcode警告"></a>Xcode警告</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">framework</span>] CUICatalog: Invalid asset name supplied: <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>使用<code>[UIImage imageNamed:@&quot;&quot;]</code>初始化了一个UIImage</p><span id="more"></span><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>使用Symbolic Breakpoint<br><img src="https://user-gold-cdn.xitu.io/2020/7/15/173506366c4fb0d2?w=908&h=398&f=png&s=333032" alt="image.png"><br>Symbol处填写<code>[UIImage imageNamed:]</code></br><br>Condition处填写<code>[(NSString *)$arg3 length] == 0</code>，如果是检测nil，此处填写<code>$arg3 == nil</code></p><p>运行以后，断点就会停在name为@””的地方。</p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#x39;&#x34;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;">&#x5f;&#49;&#x39;&#x39;&#x34;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVC</title>
    <link href="/post/hjbvw26d.html"/>
    <url>/post/hjbvw26d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="一-Getter"><a href="#一-Getter" class="headerlink" title="一 Getter"></a>一 Getter</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)valueForKey:(<span class="hljs-built_in">NSString</span> *)key;                          <span class="hljs-comment">//直接通过Key来取值</span><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)valueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath;                  <span class="hljs-comment">//通过KeyPath来取值</span><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/07/qZ2BRJP17xEIMdm.png" alt="image.png"></p><span id="more"></span><ul><li>1.通过<code>getter</code>方法搜索实例，按照<code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code>, <code>_&lt;key&gt;的顺序查找</code>getter`方法。如果发现符合的方法，就调用对应的方法并拿着结果跳转到第五步。否则，就继续到下一步。</li><li>2.如果没有找到简单的<code>getter</code>方法，则搜索其匹配模式的方法<code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;key&gt;AtIndexes:</code>。</br><br>  如果找到其中的第一个和其他两个中的一个，则就会返回一个可以响应<code>NSArray</code>所有方法的代理集合(它是<code>NSKeyValueArray</code>，是<code>NSArray</code>的子类)。或者说给这个代理集合发送属于<code>NSArray</code>的方法，就会以<code>countOf&lt;Key&gt;</code>,<code>objectIn&lt;Key&gt;AtIndex</code>或<code>&lt;Key&gt;AtIndexes</code>这几个方法组合的形式调用。否则，继续到第三步。</br><br>  代理对象随后将<code>NSArray</code>接收到的<code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;key&gt;AtIndexes:</code>的消息给符合<code>KVC</code>规则的调用方。</br><br>  当代理对象和<code>KVC</code>调用方通过上面方法一起工作时，就会允许其行为类似于<code>NSArray</code>一样。</li><li>3.如果没有找到<code>NSArray</code>简单存取方法，或者<code>NSArray</code>存取方法组。那么会同时查找<code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code>命名的方法。</br><br>  如果找到三个方法，则创建一个集合代理对象，该对象响应所有<code>NSSet</code>方法并返回。否则，继续执行第四步。</br><br>  给这个代理对象发<code>NSSet</code>的消息，就会以<code>countOf&lt;Key&gt;</code>，<code>enumeratorOf&lt;Key&gt;</code>,<code>memberOf&lt;Key&gt;</code>组合的形式调用。</li><li>4.如果没有发现简单<code>getter</code>方法，或集合存取方法组，以及接收类方法<code>accessInstanceVariablesDirectly</code>是返回<code>YES</code>的。搜索一个名为<code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>的实例，根据他们的顺序。</br><br> 如果发现对应的实例，则立刻获得实例可用的值并跳转到第五步，如果重写了类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>返回NO的话，那么会直接调用<code>valueForUndefinedKey:</code>。</li><li>5.如果取回的是一个对象指针，则直接返回这个结果。<br>  如果取回的是一个基础数据类型，但是这个基础数据类型是被<code>NSNumber</code>支持的，则存储为<code>NSNumber</code>并返回。</br><br>  如果取回的是一个不支持<code>NSNumber</code>的基础数据类型，则通过<code>NSValue</code>进行存储并返回。</li><li>6.如果所有情况都失败，则调用<code>valueForUndefinedKey:</code>方法并抛出异常，这是默认行为。但是子类可以重写此方法。</li></ul><h3 id="二-Setter"><a href="#二-Setter" class="headerlink" title="二 Setter"></a>二 Setter</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)value forKey:(<span class="hljs-built_in">NSString</span> *)key;          <span class="hljs-comment">//通过Key来设值</span><br>- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)value forKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath;  <span class="hljs-comment">//通过KeyPath来设值</span><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/07/BKyu9a2iE5HMPUY.png" alt="image.png"></p><ul><li>1.查找<code>set&lt;Key&gt;:</code>或<code>_set&lt;Key&gt;</code>命名的<code>setter</code>，按照这个顺序，如果找到的话，代码通过<code>setter</code>方法完成设置。</li><li>2.如果没有找到<code>setter</code>方法，KVC机制会检查<code>+ (BOOL)accessInstanceVariablesDirectly</code>的返回值，如果<code>accessInstanceVariablesDirectly</code>类属性返回<code>YES</code>，则查找一个命名规则为<code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>的实例变量。根据这个顺序，如果发现则将<code>value</code>赋值给实例变量，如果返回值为NO，KVC会执行<code>setValue：forUndefinedKey：</code>方法。</li><li>3.如果没有发现<code>setter</code>或实例变量，则调用<code>setValue:forUndefinedKey:</code>方法，并默认提出一个异常，但是一个<code>NSObject</code>的子类可以提出合适的行为。</li></ul><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#x39;&#57;&#x34;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#111;&#109;">&#95;&#49;&#x39;&#57;&#x34;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atomic与自旋锁</title>
    <link href="/post/etr9ui6d.html"/>
    <url>/post/etr9ui6d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><ul><li>  <code>自旋锁</code> 不同于<code>互斥锁</code> 如果访问的资源被占用，它会处于 <code>忙等</code> 状态。自旋锁由于一直处于忙等状态所以他在线程锁被释放的时候会立即获取而不用唤醒，所以其执行效率是很高的，尤其是在多核的cpu上运行效率很高，但是其忙等的状态会消耗<code>cpu</code>的性能，所以其性能比互斥锁要低很多。</li><li>  <code>atomic</code> 的底层实现，老版本是<code>自旋锁</code>，新版本是<code>互斥锁</code>。</li><li>  <code>atomic</code> 并不是绝对线程安全，它能保证代码进入 <code>getter</code> 和 <code>setter</code> 方法的时候是安全的，但是并不能保证多线程的访问情况下是安全的，一旦出了 <code>getter</code> 和 <code>setter</code> 方法，其线程安全就要由程序员自己来把握，所以 <code>atomic</code> 属性和线程安全并没有必然联系。</li></ul><span id="more"></span><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (atomic, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span> number;  <br>  <br>- (<span class="hljs-keyword">void</span>)atomicTest &#123;  <br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i ++) &#123;  <br>            <span class="hljs-keyword">self</span>.number = <span class="hljs-keyword">self</span>.number + <span class="hljs-number">1</span>;  <br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;A-self.number is %ld&quot;</span>,<span class="hljs-keyword">self</span>.number);  <br>        &#125;  <br>    &#125;);  <br>  <br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i ++) &#123;  <br>            <span class="hljs-keyword">self</span>.number = <span class="hljs-keyword">self</span>.number + <span class="hljs-number">1</span>;  <br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;B-self.number is %ld&quot;</span>,<span class="hljs-keyword">self</span>.number);  <br>        &#125;  <br>    &#125;);  <br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们的 <code>number</code> 是 <code>atomic</code> 进行加锁了啊，为什么还会出现线程安全问题。其实答案上文已经有了，只是需要我们仔细去品，<code>atomic</code> 只是针对 <code>setter</code> 和 <code>getter</code> 方法进行加锁，上述代码有两个异步线程同时执行，如果某个时间 <code>A线程</code> 执行到<code>getter</code>方法，之后 <code>cpu</code> 立即切换到 <code>线程B</code> 去执行他的get方法那么这个时候他们进行 <code>+1</code> 的处理并执行<code>setter</code>方法，那么两个线程的 <code>number</code> 就会是一样的结果，这样我们的 <code>+1</code>就会出现线程安全问题，就会导致我们的数字出现偏差</p><p><a href="https://juejin.im/post/6844904101981978637">链接</a></p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#x39;&#52;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#109;">&#x5f;&#49;&#x39;&#x39;&#52;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS自旋锁、互斥锁与递归锁</title>
    <link href="/post/e2iokj6d.html"/>
    <url>/post/e2iokj6d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="一-自旋锁"><a href="#一-自旋锁" class="headerlink" title="一 自旋锁"></a>一 自旋锁</h3><p>是一种用于保护多线程共享资源的锁，与一般互斥锁（mutex）不同之处在于当自旋锁尝试获取锁时以忙等待（busy waiting）的形式不断地循环检查锁是否可用。当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会一直等待（不会睡眠），当上一个线程的任务执行完毕，下一个线程会立即执行。<br>在多CPU的环境中，对持有锁较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能。<br><strong>优点</strong><br>自旋锁不会引起调用者睡眠，所以不会进行线程调度，CPU时间片轮转等耗时操作。所有如果能在很短的时间内获得锁，自旋锁的效率远高于互斥锁。<br><strong>缺点</strong><br>自旋锁一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。</p><p><strong>小结</strong><br>效率高，但是耗费资源，不能实现递归调用。  </p><span id="more"></span><h3 id="二-互斥锁"><a href="#二-互斥锁" class="headerlink" title="二 互斥锁"></a>二 互斥锁</h3><p>当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会进入睡眠状态等待任务执行完毕，当上一个线程的任务执行完毕，下一个线程会自动唤醒然后执行任务。</p><h3 id="三-递归锁"><a href="#三-递归锁" class="headerlink" title="三 递归锁"></a>三 递归锁</h3><p>递归锁允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// _lock = [[NSRecursiveLock alloc] init]; // pthread_mutex_t可替换成NSRecursiveLock</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">pthread_mutex_t</span> pLock;<br><span class="hljs-keyword">pthread_mutexattr_t</span> attr;<br>pthread_mutexattr_init(&amp;attr); <span class="hljs-comment">//初始化attr并且给它赋予默认</span><br>pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); <span class="hljs-comment">//设置锁类型，这边是设置为递归锁</span><br>pthread_mutex_init(&amp;pLock, &amp;attr);<br>pthread_mutexattr_destroy(&amp;attr); <span class="hljs-comment">//销毁一个属性对象，在重新进行初始化之前该结构不能重新使用</span><br><br><span class="hljs-comment">//1.线程1</span><br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> (^RecursiveBlock)(<span class="hljs-keyword">int</span>);<br>    RecursiveBlock = ^(<span class="hljs-keyword">int</span> value) &#123;<br><span class="hljs-comment">//        [_lock lock];</span><br>        pthread_mutex_lock(&amp;pLock);<br>        <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0</span>) &#123;<br>            NSLog(@<span class="hljs-string">&quot;value: %d&quot;</span>, value);<br>            RecursiveBlock(value - <span class="hljs-number">1</span>);<br>        &#125;<br><span class="hljs-comment">//        [_lock unlock];</span><br>        pthread_mutex_unlock(&amp;pLock);<br>    &#125;;<br>    RecursiveBlock(<span class="hljs-number">5</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h3><ul><li>自旋锁会忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。  </li><li>互斥锁会休眠，即在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程。  </li></ul><h3 id="五-常见的锁"><a href="#五-常见的锁" class="headerlink" title="五 常见的锁"></a>五 常见的锁</h3><ul><li><strong>自旋锁</strong><ul><li>atomic</li><li>OSSpinLock</li><li>dispatch_semaphore_t （信号量 GCD）</li></ul></li><li><strong>互斥锁</strong><ul><li>os_unfair_lock（替代OSSpinLock） </li><li>pthread_mutex （含recursive实现方案）</li><li>@synchronized</li><li>NSLock （对象锁）</li><li>NSConditionLock （条件锁）</li><li>NSCondition</li><li>NSRecursiveLock （递归锁）</li></ul></li></ul><h3 id="六-常见锁的性能"><a href="#六-常见锁的性能" class="headerlink" title="六 常见锁的性能"></a>六 常见锁的性能</h3><p><img src="https://i.loli.net/2020/09/08/vTCife7cUSqdnzx.png" alt="image.png"><br>图片来源<a href="https://blog.ibireme.com/">@ibireme</a></p><h3 id="七-常见锁的使用"><a href="#七-常见锁的使用" class="headerlink" title="七 常见锁的使用"></a>七 常见锁的使用</h3><p><a href="https://www.jianshu.com/p/33b608903488">iOS中常见的10种锁</a></p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#x39;&#57;&#52;&#x40;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;">&#95;&#x31;&#x39;&#57;&#52;&#x40;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS远程推送流程</title>
    <link href="/post/e2iu766d.html"/>
    <url>/post/e2iu766d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="一-iOS消息推送流程"><a href="#一-iOS消息推送流程" class="headerlink" title="一 iOS消息推送流程"></a>一 iOS消息推送流程</h3><ul><li>1.由App向iOS设备发送一个注册通知，用户需要同意系统发送推送</li><li>2.iOS应用向APNS远程推送服务器发送App的Bundle Id和Device UUID</li><li>3.APNS根据设备的UUID和App的Bundle Id生成deviceToken再发回App</li><li>4.App再将deviceToken发送给远程推送服务器（自己的服务器），再由服务器保存到数据库中</li><li>5.当自己的服务器想发送推送时，在远程推送服务器中输入想发送的消息并选择发给哪些用户的deviceToken，由远程推送服务器发送给APNS</li><li>6.APNS根据deviceToken发送给对应的用户<span id="more"></span><h3 id="二-相关代码"><a href="#二-相关代码" class="headerlink" title="二 相关代码"></a>二 相关代码</h3></li></ul><h4 id="1-获取DeviceToken"><a href="#1-获取DeviceToken" class="headerlink" title="1.获取DeviceToken"></a>1.获取DeviceToken</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">// do some initiale working</span><br>    ...<br>    <br>    [application registerForRemoteNotificationTypes:<span class="hljs-built_in">UIRemoteNotificationTypeBadge</span> | <span class="hljs-built_in">UIRemoteNotificationTypeAlert</span> | <span class="hljs-built_in">UIRemoteNotificationTypeSound</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-处理成功回调"><a href="#1-处理成功回调" class="headerlink" title="1).处理成功回调"></a>1).处理成功回调</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)application:(<span class="hljs-built_in">UIApplication</span> *)app didRegisterForRemoteNotificationsWithDeviceToken:(<span class="hljs-built_in">NSData</span> *)deviceToken &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Receive DeviceToken: %@&quot;</span>, deviceToken);<br>    <span class="hljs-comment">// 上传自家服务器</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-处理失败回调"><a href="#2-处理失败回调" class="headerlink" title="2).处理失败回调"></a>2).处理失败回调</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application didFailToRegisterForRemoteNotificationsWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;注册失败，无法获取设备ID, 具体错误: %@&quot;</span>, error);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-处理接收消息回调"><a href="#2-处理接收消息回调" class="headerlink" title="2.处理接收消息回调"></a>2.处理接收消息回调</h4><h4 id="1-、App未启动"><a href="#1-、App未启动" class="headerlink" title="1)、App未启动"></a>1)、App未启动</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-keyword">if</span> (launchOptions) &#123;<br>        <span class="hljs-comment">// do something else</span><br>        ...<br>    <br>    &#125;<br>    <br>    [application registerForRemoteNotificationTypes:<span class="hljs-built_in">UIRemoteNotificationTypeBadge</span> | <span class="hljs-built_in">UIRemoteNotificationTypeAlert</span> | <span class="hljs-built_in">UIRemoteNotificationTypeSound</span>];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-、App正在运行"><a href="#2-、App正在运行" class="headerlink" title="2)、App正在运行"></a>2)、App正在运行</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="hljs-built_in">NSDictionary</span> *)userInfo &#123;<br>    <span class="hljs-keyword">if</span> (application.applicationState == <span class="hljs-built_in">UIApplicationStateActive</span>) &#123;<br>        <span class="hljs-comment">// App在前台</span><br>        <span class="hljs-comment">// 转换成一个本地通知，显示到通知栏，你也可以直接显示出一个alertView，只是那样稍显aggressive：）</span><br>        <span class="hljs-built_in">UILocalNotification</span> *localNotification = [[<span class="hljs-built_in">UILocalNotification</span> alloc] init];<br>        localNotification.userInfo = userInfo;<br>        localNotification.soundName = <span class="hljs-built_in">UILocalNotificationDefaultSoundName</span>;<br>        localNotification.alertBody = [userInfo objectForKey:<span class="hljs-string">@&quot;alertInfo&quot;</span>];<br>        localNotification.fireDate = [userInfo objectForKey:<span class="hljs-string">@&quot;date&quot;</span>];<br>        [[<span class="hljs-built_in">UIApplication</span> sharedApplication] scheduleLocalNotification:localNotification];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 后台到前台</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-处理小红点"><a href="#3-处理小红点" class="headerlink" title="3.处理小红点"></a>3.处理小红点</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)applicationDidEnterBackground:(<span class="hljs-built_in">UIApplication</span> *)application &#123;<br>    <span class="hljs-comment">//设置应用程序图片右上角的数字(如果想要取消右上角的数字, 直接把这个参数值为0) </span><br>    [[<span class="hljs-built_in">UIApplication</span> sharedApplication] setApplicationIconBadgeNumber:<span class="hljs-number">0</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)applicationWillEnterForeground:(<span class="hljs-built_in">UIApplication</span> *)application &#123;<br>    [[<span class="hljs-built_in">UIApplication</span> sharedApplication] setApplicationIconBadgeNumber:<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#x39;&#52;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#111;&#109;">&#x5f;&#49;&#x39;&#x39;&#52;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SEL的使用与原理</title>
    <link href="/post/e2789u6d.html"/>
    <url>/post/e2789u6d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><span id="more"></span><hr><h3 id="一-概念"><a href="#一-概念" class="headerlink" title="一 概念"></a>一 概念</h3><ul><li><strong>SEL</strong><br>方法名（编号）</li><li><strong>IMP</strong><br>一个函数指针,保存了方法的地址</li><li><strong>@selector(方法名)</strong><br>获取方法的编号，结果是SEL类型。他的行为基本可以等同于C语言中的函数指针<!--more--><h3 id="二-区别"><a href="#二-区别" class="headerlink" title="二 区别"></a>二 区别</h3>  C语言中，可以直接把函数名赋值给一个函数指针，而且函数指针直接保存了函数地址<br>  Objc中的类不能直接应用函数指针，只能使用@selector来获取，获取的是方法的编号</li></ul><h3 id="三-原理"><a href="#三-原理" class="headerlink" title="三 原理"></a>三 原理</h3><p>方法以@selector作为索引，@selector的数据类型是SEL，对应每个方法的编号，当我们寻找方法的时候使用的是这个方法编号。类中存在一个methodLists专门用来存放方法实现IMP和SEL的映射。方法编号SEL通过Dispatch table表寻找到对应的IMP，IMP就是一个函数指针，然后执行这个方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> &#123;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> <span class="hljs-title">super_class</span>;</span>  <span class="hljs-comment">/*父类*/</span><br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;                 <span class="hljs-comment">/*类名字*/</span><br><br>    <span class="hljs-keyword">long</span> version;                   <span class="hljs-comment">/*版本信息*/</span><br><br>    <span class="hljs-keyword">long</span> info;                        <span class="hljs-comment">/*类信息*/</span><br><br>    <span class="hljs-keyword">long</span> instance_size;               <span class="hljs-comment">/*实例大小*/</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar_list</span> *<span class="hljs-title">ivars</span>;</span>     <span class="hljs-comment">/*实例参数链表*/</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method_list</span> **<span class="hljs-title">methodLists</span>;</span>  <span class="hljs-comment">/*方法链表*/</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_cache</span> *<span class="hljs-title">cache</span>;</span>               <span class="hljs-comment">/*方法缓存*/</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_protocol_list</span> *<span class="hljs-title">protocols</span>;</span>   <span class="hljs-comment">/*协议链表*/</span><br><br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method</span> *<span class="hljs-title">Method</span>;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_</span> <span class="hljs-title">method</span> &#123;</span><br><br>    SEL method_name;<span class="hljs-comment">//方法名</span><br><br>    <span class="hljs-keyword">char</span> *method_types;<span class="hljs-comment">//参数类型</span><br><br>    IMP method_imp;<span class="hljs-comment">//方法实现</span><br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="四-相关"><a href="#四-相关" class="headerlink" title="四 相关"></a>四 相关</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span>   返回对象的类；<br><br><span class="hljs-symbol">isKindOfClass</span> 和 <span class="hljs-symbol">isMemberOfClass</span>检查对象是否在指定的类继承体系中；<br><br><span class="hljs-symbol">respondsToSelector</span> 检查对象能否相应指定的消息；<br><br><span class="hljs-symbol">conformsToProtocol</span> 检查对象是否实现了指定协议类的方法；<br><br><span class="hljs-symbol">methodForSelector</span>  返回指定方法实现的地址。<br><br><span class="hljs-symbol">performSelector:<span class="hljs-symbol">withObject</span></span> 执行<span class="hljs-symbol">SEL</span> 所指代的方法。<br><br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#57;&#x39;&#52;&#64;&#x31;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;">&#95;&#49;&#57;&#x39;&#52;&#64;&#x31;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>weak与unsafe_unretain</title>
    <link href="/post/ghj7e26d.html"/>
    <url>/post/ghj7e26d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><ul><li>weak修饰的指针变量，在指向的内存地址销毁后，会在Runtime的机制下，自动置为nil。</li><li>_Unsafe_Unretain不会置为nil，容易出现悬垂指针，发生崩溃。但是_Unsafe_Unretain比__weak效率高。<span id="more"></span></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objc"><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span>()</span><br><br><span class="hljs-comment">//@property (nonatomic, strong) NSMutableArray *array;</span><br><span class="hljs-comment">//@property (nonatomic, weak) NSMutableArray *array;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">unsafe_unretained</span>) <span class="hljs-built_in">NSMutableArray</span> *array;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span></span><br><br>- (<span class="hljs-keyword">void</span>)test &#123;<br>    <span class="hljs-keyword">self</span>.array = @[<span class="hljs-string">@&quot;1&quot;</span>,<span class="hljs-string">@&quot;2&quot;</span>].mutableCopy;<br>    <span class="hljs-keyword">void</span> (^block)(<span class="hljs-keyword">void</span>) = ^ &#123;<br>    <span class="hljs-comment">//使用unsafe_unretained下面这行会发生崩溃，self.array成了僵尸对象</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-keyword">self</span>.array);<br>    &#125;;<br>    block();<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#x39;&#57;&#52;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#109;">&#95;&#49;&#x39;&#57;&#52;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>isKindOfClass与isMemberOfClass</title>
    <link href="/post/hje6726d.html"/>
    <url>/post/hje6726d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="一-Code"><a href="#一-Code" class="headerlink" title="一 Code"></a>一 Code</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs objc"><br>- (<span class="hljs-keyword">void</span>)testClassISA &#123;<br><br><span class="hljs-keyword">id</span> b1 = [<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>];<br><br><span class="hljs-keyword">id</span> b2 = [<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>];<br><br><span class="hljs-keyword">id</span> b3 = [[<span class="hljs-built_in">NSObject</span> new] <span class="hljs-keyword">class</span>];<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;[NSObject class] = %@ , %@, %@&quot;</span>, b1,b2,b3);<br><br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">BOOL</span> res1 = [(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>] isKindOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// false</span><br><span class="hljs-built_in">BOOL</span> res2 = [(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>] isMemberOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">BOOL</span> res3 = [(<span class="hljs-keyword">id</span>)[[<span class="hljs-built_in">NSObject</span> new] <span class="hljs-keyword">class</span>] isKindOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// false</span><br><span class="hljs-built_in">BOOL</span> res4 = [(<span class="hljs-keyword">id</span>)[[<span class="hljs-built_in">NSObject</span> new] <span class="hljs-keyword">class</span>] isMemberOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">BOOL</span> res5 = [(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> new] isKindOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">BOOL</span> res6 = [(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> new] isMemberOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// false</span><br><span class="hljs-built_in">BOOL</span> res7 = [(<span class="hljs-keyword">id</span>)[Test <span class="hljs-keyword">class</span>] isKindOfClass:(<span class="hljs-keyword">id</span>)[Test <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// false</span><br><span class="hljs-built_in">BOOL</span> res8 = [(<span class="hljs-keyword">id</span>)[Test <span class="hljs-keyword">class</span>] isKindOfClass:(<span class="hljs-keyword">id</span>)[Test <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// false</span><br><span class="hljs-built_in">BOOL</span> res9 = [(<span class="hljs-keyword">id</span>)[[Test new] <span class="hljs-keyword">class</span>] isKindOfClass:(<span class="hljs-keyword">id</span>)[Test <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// false</span><br><span class="hljs-built_in">BOOL</span> res10 = [(<span class="hljs-keyword">id</span>)[[Test new] <span class="hljs-keyword">class</span>] isMemberOfClass:(<span class="hljs-keyword">id</span>)[Test <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">BOOL</span> res11 = [(<span class="hljs-keyword">id</span>)[Test new] isKindOfClass:(<span class="hljs-keyword">id</span>)[Test <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">BOOL</span> res12 = [(<span class="hljs-keyword">id</span>)[Test new] isMemberOfClass:(<span class="hljs-keyword">id</span>)[Test <span class="hljs-keyword">class</span>]];<br><br><span class="hljs-comment">// 1, 0, 1, 0, 1, 1</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d, %d, %d, %d, %d, %d&quot;</span>,res1, res2, res3,res4,res5, res6);<br><br><span class="hljs-comment">// 0, 0, 0, 0, 1, 1</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d, %d, %d, %d, %d, %d&quot;</span>,res7, res8, res9,res10,res11, res12);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="二-源码"><a href="#二-源码" class="headerlink" title="二 源码"></a>二 源码</h3><h4 id="0-源码解析"><a href="#0-源码解析" class="headerlink" title="0.源码解析"></a>0.源码解析</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-comment">/// 类方法，返回自身</span><br><br>+ (Class)<span class="hljs-keyword">class</span> &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br><br>&#125;<br><br><span class="hljs-comment">/// 实例方法，查找isa（类）</span><br><br>- (Class)<span class="hljs-keyword">class</span> &#123;<br><br><span class="hljs-keyword">return</span> object_getClass(<span class="hljs-keyword">self</span>);<br><br>&#125;<br><br>Class object_getClass(<span class="hljs-keyword">id</span> obj)<br><br>&#123;<br><br><span class="hljs-keyword">if</span> (obj) <span class="hljs-keyword">return</span> obj-&gt;getIsa();<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Nil;<br><br>&#125;<br><br><span class="hljs-keyword">inline</span> Class<br><br>objc_object::getIsa()<br><br>&#123;<br><br><span class="hljs-keyword">if</span> (isTaggedPointer()) &#123;<br><br>uintptr_t slot = ((uintptr_t)<span class="hljs-keyword">this</span> &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK;<br><br><span class="hljs-keyword">return</span> objc_tag_classes[slot];<br><br>&#125;<br><br><span class="hljs-keyword">return</span> ISA();<br><br>&#125;<br><br><span class="hljs-keyword">inline</span> Class<br><br>objc_object::ISA()<br><br>&#123;<br><br>assert(!isTaggedPointer());<br><br><span class="hljs-keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);<br><br>&#125;<br><br><span class="hljs-comment">/// 类方法，沿着继承链，去判定isa（类对象isa是元类）和参数是否相等</span><br><br>+ (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;<br><br><span class="hljs-keyword">for</span> (Class tcls = <span class="hljs-keyword">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;superclass) &#123;<br><br><span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br><br>&#125;<br><br><span class="hljs-comment">/// 实例方法，沿着继承链，去判定isa（实例对象isa是类）和参数是否相等</span><br><br>- (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;<br><br><span class="hljs-keyword">for</span> (Class tcls = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;<br><br><span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br><br>&#125;<br><br><span class="hljs-comment">/// 类方法，判定isa（元类）和参数是否相等</span><br><br>+ (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>-&gt;ISA() == cls;<br><br>&#125;<br><br><span class="hljs-comment">/// 实例方法，判定isa（类）和参数是否相等</span><br><br>- (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;<br><br><span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] == cls;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><ol><li><code>object_getClass(obj)</code>返回的是obj的isa指针；</li></ol></li><li><ol start="2"><li><code>[obj class]</code>则分两种情况：</li></ol></li><li><p><strong>obj为实例对象</strong></p></li></ul><p>调用的是实例方法：<code>- (Class)class</code>，返回的obj对象中的isa指针；</p><ul><li><strong>obj为类对象（包括元类和根类以及根元类）</strong></li></ul><p>调用的是类方法：<code>+ (Class)class</code>，返回的结果为其本身。</p><p><a href="https://segmentfault.com/a/1190000023883965">参考：【iOS笔记 #3】class方法和objc_getClass方法</a></p><h4 id="1-isKindOfClass"><a href="#1-isKindOfClass" class="headerlink" title="1.isKindOfClass"></a>1.isKindOfClass</h4><p><strong>是否是当前类或当前类的子类实例</strong></p><p><code>Returns a Boolean value that indicates whether the receiver is an instance of given class or an instance of any class that inherits from that class.</code></p><p><strong>判定依据</strong></p><p>实例对象调用<code>isKindOfClass</code></p><p>沿继承链获取isa（类对象），判定class与继承链上获取的isa是否有相等的</p><p>类对象调用<code>isKindOfClass</code></p><p>沿继承链获取isa（元类对象），判定class与继承链上获取的isa是否有相等的</p><h4 id="2-isMemberOfClass"><a href="#2-isMemberOfClass" class="headerlink" title="2.isMemberOfClass"></a>2.isMemberOfClass</h4><p><strong>是否是给定类的实例</strong></p><p><code>Returns a Boolean value that indicates whether the receiver is an instance of a given class.</code></p><p>isMemberOfClass的源码实现是拿到自己的isa指针和自己比较，是否相等。</p><p><img src="https://i.loli.net/2020/06/22/GV93sCL4aSyoZcn.png" alt="图1"></p><h3 id="三-解析"><a href="#三-解析" class="headerlink" title="三 解析"></a>三 解析</h3><h4 id="1-res1"><a href="#1-res1" class="headerlink" title="1. res1"></a>1. res1</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"><br><span class="hljs-built_in">BOOL</span> res1 = [(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>] isKindOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]]; <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><p><code>[NSObject class]</code>类对象调用<code>+(Class)class</code>返回自身，即NSObject</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><br><span class="hljs-comment">/// 类方法，沿着继承链，去判定isa（类对象isa是元类）和参数是否相等</span><br><br>+ (<span class="hljs-keyword">BOOL</span>)isKindOfClass:(Class)<span class="hljs-keyword">cls</span>;<br><br></code></pre></td></tr></table></figure><p>返回自身，即NSObject的isa是NSObjectMeta，不等，沿继承链查找superclass，[NSObjectMeta superclass] == NSObject（图右上角可看出），此时相等，返回true</p><h4 id="2-res2"><a href="#2-res2" class="headerlink" title="2. res2"></a>2. res2</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"><br><span class="hljs-built_in">BOOL</span> res2 = [(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>] isMemberOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]]; <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><p><code>[NSObject class]</code>即NSObject</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><br><span class="hljs-comment">/// 类方法，判定isa（元类）和参数是否相等</span><br><br>+ (<span class="hljs-keyword">BOOL</span>)isMemberOfClass:(Class)<span class="hljs-keyword">cls</span>;<br><br></code></pre></td></tr></table></figure><p>[NSObject class] == NSObject，[NSObject class]的isa是NSObjectMeta，NSObject != NSObjectMeta，所以是false</p><h4 id="3-res3"><a href="#3-res3" class="headerlink" title="3. res3"></a>3. res3</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-built_in">BOOL</span> res3 = [(<span class="hljs-keyword">id</span>)[[<span class="hljs-built_in">NSObject</span> new] <span class="hljs-keyword">class</span>] isKindOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]]; <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><p>[NSObject new] class] == NSObject，后续分析与res1一致，所以是true</p><h4 id="4-res4"><a href="#4-res4" class="headerlink" title="4. res4"></a>4. res4</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-built_in">BOOL</span> res4 = [(<span class="hljs-keyword">id</span>)[[<span class="hljs-built_in">NSObject</span> new] <span class="hljs-keyword">class</span>] isMemberOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]]; <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><p>[NSObject new] class] == NSObject，后续分析与res2一致，所以是false</p><h4 id="5-res5"><a href="#5-res5" class="headerlink" title="5. res5"></a>5. res5</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-built_in">BOOL</span> res5 = [(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> new] isKindOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]]; <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">/// 实例方法，沿着继承链，去判定isa（实例对象isa是类）和参数是否相等</span><br><br>- (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls;<br><br></code></pre></td></tr></table></figure><p>id o = [NSObject new]; o 的calss是NSObject，[NSObject class] == NSObject，进入循环即相等，所以是true</p><h4 id="6-res6"><a href="#6-res6" class="headerlink" title="6. res6"></a>6. res6</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-built_in">BOOL</span> res6 = [(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> new] isMemberOfClass:(<span class="hljs-keyword">id</span>)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]]; <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">/// 实例方法，判定isa（类）和参数是否相等</span><br><br>- (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)cls;<br><br></code></pre></td></tr></table></figure><p>id o = [NSObject new]; o 的isa是NSObject，[NSObject class] == NSObject，进入循环即相等，所以是true</p><h4 id="7-res7"><a href="#7-res7" class="headerlink" title="7. res7"></a>7. res7</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-built_in">BOOL</span> res7 = [(<span class="hljs-keyword">id</span>)[Test <span class="hljs-keyword">class</span>] isKindOfClass:(<span class="hljs-keyword">id</span>)[Test <span class="hljs-keyword">class</span>]]; <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><p>[Test class] == Test</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><br><span class="hljs-comment">/// 类方法，沿着继承链，去判定isa（类对象isa是元类）和参数是否相等</span><br><br>+ (<span class="hljs-keyword">BOOL</span>)isKindOfClass:(Class)<span class="hljs-keyword">cls</span>;<br><br></code></pre></td></tr></table></figure><p>1 -&gt; Test的isa是TestMeta，TestMeta != Test；</p><p>2 -&gt; 找superclass，[Test superclass] == NSObject，NSObject的isa是NSObjectMeta，NSObjectMeta != Test；</p><p>3 -&gt; 继续找superclass，[NSObject superclass] == nil，nil != Test，所以是false</p><h4 id="8-res8"><a href="#8-res8" class="headerlink" title="8. res8"></a>8. res8</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><br>BOOL res8 = [(id)<span class="hljs-string">[[Test new] class] isKindOfClass:(id)[Test class]]</span>; // <span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><p>[Test class] == Test，[Test new] class] == Test</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><br><span class="hljs-comment">/// 类方法，沿着继承链，去判定isa（类对象isa是元类）和参数是否相等</span><br><br>+ (<span class="hljs-keyword">BOOL</span>)isKindOfClass:(Class)<span class="hljs-keyword">cls</span>;<br><br></code></pre></td></tr></table></figure><p>1 -&gt; Test 的isa是TestMeta，不等于Test，</p><p>2 -&gt; Test的superclass是NSObject，NSObject的isa是NSObjectMeat，不等于Test，</p><p>3 -&gt; NSObject的superclass是nil，不等于Test，所以是false</p><p><strong>余下分析同理……</strong></p><hr><p><strong>总结一下判定流程</strong><br>结合上图1，共有三列，第一列实例对象，第二列类对象，第三列元类对象。</p><ul><li><code>+ (BOOL)isKindOfClass:(Class)cls;</code><br> 类方法，沿着继承链，去判定isa（类对象isa是元类）和参数是否相等，即判定<strong>第三列</strong>的所有元类以及<strong>根元类的父类NSObject</strong>是否有能和参数匹配的。<br>参见res7的判定流程</li><li><code>- (BOOL)isKindOfClass:(Class)cls;</code><br>  实例方法，沿着继承链，去判定isa（实例对象isa是类）和参数是否相等，即判定<strong>第二列</strong>的所有类以及<strong>根类NSObject</strong>是否有能和参数匹配的。<br>参见res5的判定流程</li><li><code>+ (BOOL)isMemberOfClass:(Class)cls;</code><br>  类方法，判定isa（元类）和参数是否相等，<strong>只判定一次</strong>，判定元类，即<strong>第三列</strong>是否有能和参数匹配的。<br>参见res2的判定流程</li><li><code>- (BOOL)isMemberOfClass:(Class)cls;</code><br>  实例方法，判定isa（类）和参数是否相等，<strong>只判定一次</strong>，判定元类，即<strong>第二列</strong>是否有能和参数匹配的。<br>参见res6的判定流程</li></ul><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#x39;&#52;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;">&#x5f;&#49;&#x39;&#x39;&#52;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常驻线程</title>
    <link href="/post/sde3r26d.html"/>
    <url>/post/sde3r26d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><p>以下代码来自AFNetworking 2.x</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-keyword">void</span>)networkRequestThreadEntryPoint:(<span class="hljs-keyword">id</span>)__unused object &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        [[<span class="hljs-built_in">NSThread</span> currentThread] setName:<span class="hljs-string">@&quot;AFNetworking&quot;</span>];<br><br>        <span class="hljs-built_in">NSRunLoop</span> *runLoop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<br>        [runLoop addPort:[<span class="hljs-built_in">NSMachPort</span> port] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>        [runLoop run];<br>    &#125;<br>&#125;<br><br>+ (<span class="hljs-built_in">NSThread</span> *)networkRequestThread &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSThread</span> *_networkRequestThread = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> oncePredicate;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;<br>        _networkRequestThread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="hljs-literal">nil</span>];<br>        [_networkRequestThread start];<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> _networkRequestThread;<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><p>调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <span class="hljs-comment">// Do any additional setup after loading the view.</span><br>    <span class="hljs-keyword">self</span>.view.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor];<br>    <br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) onThread:[ViewController networkRequestThread] withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">NO</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;<br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test2) onThread:[ViewController networkRequestThread] withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">NO</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)test &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>,__func__);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)test2 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>,__func__);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#57;&#57;&#x34;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;">&#x5f;&#x31;&#57;&#57;&#x34;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDWebImage浅析</title>
    <link href="/post/easdr26d.html"/>
    <url>/post/easdr26d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h1 id='1'>一、官方图片</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/019bd43834ea45c5a00ede539bd0b6c3~tplv-k3u1fbpfcp-zoom-1.image" alt="SDWebImageSequenceDiagram.png"></p><span id="more"></span><h1 id='2'>二、流程梳理</h1><h2 id='2-1'>1、需要获取图片的类</h2><p>调用方法去请求图片资源（APNG，Gif，WebP）；</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)sd_setImageWithURL:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSURL</span> *)url <br>  placeholderImage:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIImage</span> *)placeholder <br>         options:(SDWebImageOptions)options;<br></code></pre></td></tr></table></figure><h2 id='2-2'>2、UIWebImage+WebCache</h2><p>调用方法去请求图片资源</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)sd_internalSetImageWithURL:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSURL</span> *)url<br>                  placeholderImage:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIImage</span> *)placeholder<br>                           options:(SDWebImageOptions)options<br>                           context:(<span class="hljs-keyword">nullable</span> SDWebImageContext *)context<br>                     setImageBlock:(<span class="hljs-keyword">nullable</span> SDSetImageBlock)setImageBlock<br>                          progress:(<span class="hljs-keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock<br>                         completed:(<span class="hljs-keyword">nullable</span> SDInternalCompletionBlock)completedBlock;<br></code></pre></td></tr></table></figure><h2 id='2-3'>3、UIView+WebCache</h2><h3 id='2-3-1'> （1）、该类管理一个字典</h3><p>该字典用来存放遵循<code>SDWebImageOperation</code>协议的键值对，key为</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objc">validOperationKey = <span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>])<br>````<br><br>此时会获取该key的operation调用`[operation cancel]`；<br><br>&lt;h3 id=&#x27;2-3-2&#x27;&gt;（2）、获取SDWebImageManager单例&lt;/h3&gt;<br><br>从上下文获取或者直接获取`[SDWebImageManager sharedManager]`单例对象；<br><br>&lt;h3 id=&#x27;2-3-3&#x27;&gt; （3）、取消和存储operation&lt;/h3&gt;<br><br>获取`SDWebImageManager`单例对象，调用[<span class="hljs-number">4</span>、SDWebImageManager 中的（<span class="hljs-number">1</span>）](#<span class="hljs-number">2</span><span class="hljs-number">-4</span><span class="hljs-number">-1</span>)中的方法获取operation，调用`[<span class="hljs-keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];`先执行`[operation cancel];`再将operation存放在字典中；<br><br>&lt;h2 id=&#x27;2-4&#x27;&gt;4、SDWebImageManager&lt;/h2&gt;<br><br>&lt;h3 id=&#x27;2-4-1&#x27;&gt; （1）、获取operation&lt;/h3&gt;<br><br>调用`loadImageWithURL:options:progress:completed:`请求图片资源，该方法返回一个遵循`SDWebImageOperation`协议的`SDWebImageCombinedOperation`对象operation;<br><br>&lt;h3 id=&#x27;2-4-2&#x27;&gt; （2）、通过url查询key&lt;/h3&gt;<br><br>（**PS：和[<span class="hljs-number">3</span>、<span class="hljs-built_in">UIView</span>+WebCache （<span class="hljs-number">1</span>）、该类管理一个字典](#<span class="hljs-number">2</span><span class="hljs-number">-3</span><span class="hljs-number">-1</span>)中获取的key不同**）<br><br>```objc<br><span class="hljs-built_in">NSString</span> *key = [<span class="hljs-keyword">self</span> cacheKeyForURL:url context:context];<br></code></pre></td></tr></table></figure><h3 id='2-4-3'> （3）、获取SDImageCachesManager</h3><p>从上下文获取或直接获取<code>[SDImageCachesManager sharedManager]</code>单例对象，<code>SDImageCachesManager</code>遵循<code>SDImageCache</code>协议；</p><h2 id='2-5'>5、SDImageCachesManager</h2><p>调用方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">id</span>&lt;SDWebImageOperation&gt;)queryImageForKey:(<span class="hljs-built_in">NSString</span> *)key <br>    options:(SDWebImageOptions)options <br>    context:(SDWebImageContext *)context <br>    cacheType:(SDImageCacheType)cacheType <br>    completion:(SDImageCacheQueryCompletionBlock)completionBlock；<br></code></pre></td></tr></table></figure><p>根据不同的queryOperationPolicy和cacheType去获取不同的operation和cache，这步是去内存中获取</p><h2 id='2-6'>6、SDWebImageManager</h2><p>处理上面<a href="#2-5">5、SDImageCachesManager</a>方法调用的回调</p><h3 id='2-6-1'> （1）、没有获取到内存中的cachedImage，去磁盘获取</h3><p>调用上面<a href="#2-5">5、SDImageCachesManager</a>中的方法去存储的缓存中获取（我理解的是磁盘中），获取到以后，调用下面这个方法进行存储</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// Use the store cache process instead of downloading, and ignore .refreshCached option for now</span><br>[<span class="hljs-keyword">self</span> callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:cachedImage downloadedData:cachedData finished:<span class="hljs-literal">YES</span> progress:progressBlock completed:completedBlock];<br></code></pre></td></tr></table></figure><h5 id='2-6-2'> （2）、没有获取到磁盘中的cachedImage走下载逻辑</h5><p>步骤<a href="#2-6-1">（1）、没有获取到内存中的cachedImage，去磁盘获取</a>也没有获取到cachedImage，走下面下载逻辑</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>&lt;SDWebImageOperation&gt;)requestImageWithURL:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSURL</span> *)url<br>                                                options:(SDWebImageOptions)options<br>                                                context:(<span class="hljs-keyword">nullable</span> SDWebImageContext *)context<br>                                               progress:(<span class="hljs-keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock<br>                                              completed:(<span class="hljs-keyword">nullable</span> SDImageLoaderCompletedBlock)completedBlock;<br></code></pre></td></tr></table></figure><p>若没有设置（即使用默认设置），则也会走下面（c）存储逻辑</p><h3 id='2-6-3'> （3）、获取到了cachedImage，走存储和刷新逻辑</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// Continue store cache process</span><br>[<span class="hljs-keyword">self</span> callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock];<br></code></pre></td></tr></table></figure><h3 id='2-6-4'> （4）、获取到了image</h4><p>无论是cachedImage还是获取到了downloadImage，都会走回调返回image给上一级调用者<br>返回链如下：</br><br>SDImageCachesManager —&gt; <a href="#2-3">3、UIView+WebCache</a> —&gt; <a href="#2-2">2、UIImageView+WebCache</a> —&gt; <a href="#2-1">1、需要获取图片的类</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock image:cachedImage data:cachedData error:<span class="hljs-literal">nil</span> cacheType:cacheType finished:<span class="hljs-literal">YES</span> url:url];<br></code></pre></td></tr></table></figure><h1 id='3'>三、注意事项</h1><ul><li>1、SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片；</li><li>2、从硬盘读取到了图片，会将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）</li><li>3、图片保存到 SDImageCache 中，内存缓存和硬盘缓存会同时保存；</li><li>4、不论在哪一步获取到了图片，都会沿着返回链返回给图片调用者用于显示图片；</li><li>5、二级缓存：内存缓存-&gt;磁盘缓存，最后启动下载；</li><li>6、clearDisk // 清除磁盘缓存上的所有image；</li><li>7、cleanDisk // 清除磁盘缓存上过期的image；</li><li>8、默认清除磁盘缓存的时长是7天，先清除掉过期的缓存文件，若空间还不够，按时间先后，清理最早缓存的文件；</li><li>9、maxCacheSize没有设置默认值，所以在默认情况下不会对缓存空间设置限制。</li></ul><h1 id='4'>四、官方其他图片</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fea276241145425c835f292ba3718541~tplv-k3u1fbpfcp-zoom-1.image" alt="SDWebImageTopLevelClassDiagram.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3f66bdac3a346b593dbbee4981c4e53~tplv-k3u1fbpfcp-zoom-1.image" alt="SDWebImageClassDiagram.png"></p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#x39;&#x39;&#x34;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#109;">&#95;&#49;&#x39;&#x39;&#x34;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS延迟执行</title>
    <link href="/post/gfs2e26d.html"/>
    <url>/post/gfs2e26d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="一、performSelector"><a href="#一、performSelector" class="headerlink" title="一、performSelector"></a>一、performSelector</h3><ul><li>非阻塞</li><li>主线程执行(子线程不启动runloop的话不会执行)<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(delayMethods) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">1.0</span>];<br></code></pre></td></tr></table></figure></li><li>执行之前可取消<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc">[<span class="hljs-built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(delayMethods) object:<span class="hljs-literal">nil</span>];<br><br>[<span class="hljs-built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="hljs-keyword">self</span>];<br></code></pre></td></tr></table></figure></li></ul><span id="more"></span><h3 id="二、NSTimer"><a href="#二、NSTimer" class="headerlink" title="二、NSTimer"></a>二、NSTimer</h3><ul><li>非阻塞</li><li>主线程执行<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSTimer</span> *timer =  [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(delayMethods) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">NO</span>];<br></code></pre></td></tr></table></figure></li><li>执行之前可销毁<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">[timer invalidate];<br></code></pre></td></tr></table></figure></li></ul><h3 id="三、sleep"><a href="#三、sleep" class="headerlink" title="三、sleep"></a>三、sleep</h3><ul><li>阻塞</li><li>不可取消<h4 id="1-、objective-c"><a href="#1-、objective-c" class="headerlink" title="1)、objective-c"></a>1)、objective-c</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">[<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h4 id="2-、c"><a href="#2-、c" class="headerlink" title="2)、c"></a>2)、c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sleep(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="四、GCD"><a href="#四、GCD" class="headerlink" title="四、GCD"></a>四、GCD</h3></li><li>非阻塞</li><li>不可取消</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">1</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;<br>[<span class="hljs-keyword">self</span> delayMethods];<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#57;&#57;&#x34;&#x40;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;">&#95;&#49;&#57;&#57;&#x34;&#x40;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iPad Multitasking support requires xxx</title>
    <link href="/post/emn1h26d.html"/>
    <url>/post/emn1h26d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS错误与警告】系列目录"><a href="#【iOS错误与警告】系列目录" class="headerlink" title="【iOS错误与警告】系列目录"></a><a href="https://adrenine.github.io/post/e2m9iu6d.html">【iOS错误与警告】系列目录</a></h3><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>iPad提交报错“iPad Multitasking support requires launch story board in bundle ”</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR </span>ITMS<span class="hljs-string">-90474</span>: &quot;Invalid Bundle. iPad Multitasking support requires these<br>orientations: &#x27;UIInterfaceOrientationPortrait,UIInterfaceOrientationPortraitUpsideDown,<br>UIInterfaceOrientationLandscapeLeft,UIInterfaceOrientationLandscapeRight&#x27;.<br>Found &#x27;UIInterfaceOrientationPortrait&#x27; in bundle com.xx.xxx&quot;<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>勾选<code>Requires full screen</code><br><img src="https://user-gold-cdn.xitu.io/2020/6/5/1728248125534db1?w=1752&h=746&f=png&s=70290" alt="image.png"></p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#57;&#52;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#109;">&#x5f;&#49;&#x39;&#57;&#52;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/post/ei822g6d.html"/>
    <url>/post/ei822g6d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h2 id="一-常见多线程实现"><a href="#一-常见多线程实现" class="headerlink" title="一 常见多线程实现"></a>一 常见多线程实现</h2><h3 id="（一）pthread"><a href="#（一）pthread" class="headerlink" title="（一）pthread"></a>（一）pthread</h3><h4 id="（1）特点"><a href="#（1）特点" class="headerlink" title="（1）特点"></a>（1）特点</h4><ul><li>1）一套通用的多线程API  </li><li>2）适用于Unix/Linux/Windows等系统  </li><li>3）跨平台可移植  </li><li>4）使用难度大  <h4 id="（2）使用语言"><a href="#（2）使用语言" class="headerlink" title="（2）使用语言"></a>（2）使用语言</h4>C语言<h4 id="（3）使用频率"><a href="#（3）使用频率" class="headerlink" title="（3）使用频率"></a>（3）使用频率</h4>几乎不用  <h4 id="（4）线程生命周期"><a href="#（4）线程生命周期" class="headerlink" title="（4）线程生命周期"></a>（4）线程生命周期</h4>由程序员进行管理<h4 id="（5）概念、属性与方法"><a href="#（5）概念、属性与方法" class="headerlink" title="（5）概念、属性与方法"></a>（5）概念、属性与方法</h4>略<span id="more"></span><h3 id="（二）NSThread"><a href="#（二）NSThread" class="headerlink" title="（二）NSThread"></a>（二）NSThread</h3><h4 id="（1）特点-1"><a href="#（1）特点-1" class="headerlink" title="（1）特点"></a>（1）特点</h4></li><li>1）使用更加面向对象  </li><li>2）简单易用，可直接操作线程对象  <h4 id="（2）使用语言-1"><a href="#（2）使用语言-1" class="headerlink" title="（2）使用语言"></a>（2）使用语言</h4>OC<h4 id="（3）使用频率-1"><a href="#（3）使用频率-1" class="headerlink" title="（3）使用频率"></a>（3）使用频率</h4>偶尔使用 <h4 id="（4）线程生命周期-1"><a href="#（4）线程生命周期-1" class="headerlink" title="（4）线程生命周期"></a>（4）线程生命周期</h4>由程序员进行管理<h4 id="（5）概念、属性与方法-1"><a href="#（5）概念、属性与方法-1" class="headerlink" title="（5）概念、属性与方法"></a>（5）概念、属性与方法</h4><h5 id="1）创建线程"><a href="#1）创建线程" class="headerlink" title="1）创建线程:"></a>1）创建线程:</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 实例化线程需要手动启动才能运行，手动调用[newThread start];</span><br><span class="hljs-built_in">NSThread</span> *newThread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(demo:) object:<span class="hljs-string">@&quot;Thread&quot;</span>];<br><span class="hljs-comment">//或</span><br><span class="hljs-built_in">NSThread</span> *newThread= [[<span class="hljs-built_in">NSThread</span> alloc] init];<br><span class="hljs-comment">//或</span><br><span class="hljs-built_in">NSThread</span> *newThread= [[<span class="hljs-built_in">NSThread</span> alloc] initWithBlock:^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;initWithBlock&quot;</span>);<br>&#125;];<br></code></pre></td></tr></table></figure><h5 id="2）常用属性"><a href="#2）常用属性" class="headerlink" title="2）常用属性"></a>2）常用属性</h5></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">/// a.线程字典</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">每个线程都维护了一个&lt;键-值&gt;的字典，它可以在线程里面的任何地方被访问。你可以使用该字典来保存一些信息，这些信息在整个线程的执行过程中都保持不变。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">retain</span>) <span class="hljs-built_in">NSMutableDictionary</span> *threadDictionary;<br><br><span class="hljs-comment">/// b.优先级</span><br><span class="hljs-keyword">@property</span> <span class="hljs-keyword">double</span> threadPriority;<br><br><span class="hljs-comment">/// c.线程优先级</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  NSQualityOfServiceUserInteractive：最高优先级,主要用于提供交互UI的操作,比如处理点击事件,绘制图像到屏幕上</span><br><span class="hljs-comment">  NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务</span><br><span class="hljs-comment">  NSQualityOfServiceDefault：默认优先级，当没有设置优先级的时候，线程默认优先级</span><br><span class="hljs-comment">  NSQualityOfServiceUtility：普通优先级，主要用于不需要立即返回的任务</span><br><span class="hljs-comment">  NSQualityOfServiceBackground：后台优先级，用于完全不紧急的任务</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">@property</span> <span class="hljs-built_in">NSQualityOfService</span> qualityOfService; <br><br><span class="hljs-comment">/// d.线程名称</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><br><span class="hljs-comment">/// e.线程分配的栈的大小（子线程默认512k，主线程1M）</span><br><span class="hljs-keyword">@property</span> <span class="hljs-built_in">NSUInteger</span> stackSize ;<br><br><span class="hljs-comment">/// f.是否在执行</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">getter</span>=isExecuting) <span class="hljs-built_in">BOOL</span> executing;<br><br><span class="hljs-comment">/// g.是否已完成</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">getter</span>=isFinished) <span class="hljs-built_in">BOOL</span> finished;<br><br><span class="hljs-comment">/// h.是否被取消</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">getter</span>=isCancelled) <span class="hljs-built_in">BOOL</span> cancelled;<br></code></pre></td></tr></table></figure><h5 id="3）常用方法"><a href="#3）常用方法" class="headerlink" title="3）常用方法"></a>3）常用方法</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/// a.启动线程 </span><br>-(<span class="hljs-keyword">void</span>)start;  <span class="hljs-comment">//实例化线程需要手动启动才能运行</span><br><br><span class="hljs-comment">/// b.是否是主线程</span><br>-(<span class="hljs-built_in">BOOL</span>)isMainThread; <br><br><span class="hljs-comment">/// c.获取当前线程</span><br>+(<span class="hljs-keyword">void</span>)currentThread;<br><br><span class="hljs-comment">/// d.当前代码运行所在线程是否是子线程</span><br>+(<span class="hljs-built_in">BOOL</span>)isMultiThreaded; <br><br><span class="hljs-comment">/// e.退出当前线程</span><br>+(<span class="hljs-keyword">void</span>)exit; <br><br><span class="hljs-comment">/// f.创建子线程并开始</span><br><span class="hljs-comment">// 以下两种方式，创建完成后就可执行，不需手动开启</span><br>+ (<span class="hljs-keyword">void</span>)detachNewThreadWithBlock:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-keyword">void</span>))block;<br>+ (<span class="hljs-keyword">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class="hljs-keyword">id</span>)target withObject:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)argument;<br></code></pre></td></tr></table></figure><h3 id="（三）GCD"><a href="#（三）GCD" class="headerlink" title="（三）GCD"></a>（三）GCD</h3><h4 id="（1）特点-2"><a href="#（1）特点-2" class="headerlink" title="（1）特点"></a>（1）特点</h4><ul><li>1）旨在替代NSThread等线程技术  </li><li>2）充分利用设备的多核（自动）  <h4 id="（2）使用语言-2"><a href="#（2）使用语言-2" class="headerlink" title="（2）使用语言"></a>（2）使用语言</h4>C语言  <h4 id="（3）使用频率-2"><a href="#（3）使用频率-2" class="headerlink" title="（3）使用频率"></a>（3）使用频率</h4>经常使用  <h4 id="（4）线程生命周期-2"><a href="#（4）线程生命周期-2" class="headerlink" title="（4）线程生命周期"></a>（4）线程生命周期</h4>自动管理<h4 id="（5）概念、属性与方法-2"><a href="#（5）概念、属性与方法-2" class="headerlink" title="（5）概念、属性与方法"></a>（5）概念、属性与方法</h4><h5 id="1）栅栏方法"><a href="#1）栅栏方法" class="headerlink" title="1）栅栏方法"></a>1）栅栏方法</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> dispatch_barrier_sync(<span class="hljs-built_in">dispatch_queue_t</span> queue, dispatch_block_t block);<br><span class="hljs-keyword">void</span> dispatch_barrier_async(<span class="hljs-built_in">dispatch_queue_t</span> queue, dispatch_block_t block);<br></code></pre></td></tr></table></figure>多读单写</li><li>  1.读写互斥</li><li>  2.写写互斥  </li><li>  3.读读并发</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TestFileReadWrite</span> ()</span><br><br><span class="hljs-comment">//模拟场景，允许多个线程同时访问字典，但是只有一个线程可以写字典，多线程需要访问的数据量</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableDictionary</span> *dataDic;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TestFileReadWrite</span> </span>&#123;<br>    <span class="hljs-comment">//定义一个并发队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> _concurrent_queue;<br>&#125;<br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        _concurrent_queue = dispatch_queue_create(<span class="hljs-string">&quot;com.by.concurrent_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>        _dataDic = @&#123;&#125;.mutableCopy;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">// 读取数据，并发操作</span><br>- (<span class="hljs-keyword">id</span>)by_objectForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    __block <span class="hljs-keyword">id</span> obj;<br>    <span class="hljs-comment">//同步读取数据</span><br>    <span class="hljs-built_in">dispatch_sync</span>(_concurrent_queue, ^&#123;<br>        obj = [<span class="hljs-keyword">self</span>.dataDic objectForKey:key];<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> obj;<br>    <br>&#125;<br><br><span class="hljs-comment">// 写入数据，异步栅栏</span><br>- (<span class="hljs-keyword">void</span>)by_setObject:(<span class="hljs-keyword">id</span>)obj forKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    key = [key <span class="hljs-keyword">copy</span>];<br>    dispatch_barrier_async(_concurrent_queue, ^&#123;<br>        [<span class="hljs-keyword">self</span>.dataDic setObject:obj forKey:key];<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure><p><strong>解析</strong></p><ul><li>首先我们要维系一个GCD 队列，最好不用全局队列，毕竟大家都知道全局队列遇到栅栏函数是有坑点的，这里就不分析了！ </li><li>因为考虑性能 死锁 堵塞的因素不考虑串行队列，用的是自定义的并发队列！<code>_concurrent_queue = dispatch_queue_create(&quot;com.by.concurrent_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</code></li><li>首先我们来看看读操作:<code>by_setObject:forKey:</code> 我们考虑到多线程影响是不能用异步函数的！说明：<ul><li>  线程2 获取：<code>name</code> 线程3 获取 <code>age</code></li><li>  如果因为异步并发，导致混乱 本来读的是<code>name</code> 结果读到了<code>age</code></li><li>  我们允许多个任务同时进去! 但是读操作需要同步返回，所以我们选择:<code>同步函数</code> <strong>（读读并发）</strong></li></ul></li><li>我们再来看看写操作，在写操作的时候对key进行了copy, 关于此处的解释，插入一段来自参考文献的引用:</li></ul><blockquote><p>函数调用者可以自由传递一个<code>NSMutableString</code>的<code>key</code>，并且能够在函数返回后修改它。因此我们必须对传入的字符串使用<code>copy</code>操作以确保函数能够正确地工作。如果传入的字符串不是可变的（也就是正常的<code>NSString</code>类型），调用<code>copy</code>基本上是个空操作。</p></blockquote><ul><li>这里我们选择 <code>dispatch_barrier_async</code>, 为什么是栅栏函数而不是异步函数或者同步函数，下面分析：<ul><li>栅栏函数任务：之前所有的任务执行完毕，并且在它后面的任务开始之前，期间不会有其他的任务执行，这样比较好的促使 写操作一个接一个写 <strong>（写写互斥）</strong>，不会乱！</li><li>为什么不是异步函数？应该很容易分析，毕竟会产生混乱！</li><li>  为什么不用同步函数？如果读写都操作了，那么用同步函数，就有可能存在：我写需要等待读操作回来才能执行，显然这里是不合理！</li></ul></li></ul><h5 id="2）信号量"><a href="#2）信号量" class="headerlink" title="2）信号量"></a>2）信号量</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">dispatch_semaphore<br><span class="hljs-comment">/// 降低信号量，返回值小于0将会阻塞</span><br><span class="hljs-keyword">long</span> dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout); <br><span class="hljs-comment">/// 升高信号量，如果前面信号量为-1，使用这个方法将解除阻塞</span><br><span class="hljs-keyword">long</span> dispatch_semaphore_signal(dispatch_semaphore_t dsema);   <br></code></pre></td></tr></table></figure><h5 id="3）延时执行方法"><a href="#3）延时执行方法" class="headerlink" title="3）延时执行方法"></a>3）延时执行方法</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> dispatch_after(dispatch_time_t when, <span class="hljs-built_in">dispatch_queue_t</span> queue, dispatch_block_t block);<br></code></pre></td></tr></table></figure><h5 id="4）一次性代码（只执行一次）"><a href="#4）一次性代码（只执行一次）" class="headerlink" title="4）一次性代码（只执行一次）"></a>4）一次性代码（只执行一次）</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> <span class="hljs-built_in">dispatch_once</span>(<span class="hljs-built_in">dispatch_once_t</span> *predicate, dispatch_block_t block);<br></code></pre></td></tr></table></figure><p>单例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> MyClass * __instance;<br><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance &#123;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        __instance = [[<span class="hljs-keyword">super</span> allocWithZone:<span class="hljs-literal">NULL</span>] init];<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> __instance;<br>&#125;<br><br>+ (<span class="hljs-keyword">instancetype</span>)allocWithZone:(<span class="hljs-keyword">struct</span> _NSZone *)zone &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> shareInstance];<br>&#125;<br><br>- (<span class="hljs-keyword">id</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="5）快速迭代方法"><a href="#5）快速迭代方法" class="headerlink" title="5）快速迭代方法"></a>5）快速迭代方法</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> dispatch_apply(size_t iterations, <span class="hljs-built_in">dispatch_queue_t</span> queue, <span class="hljs-keyword">void</span> (^block)(size_t));<br></code></pre></td></tr></table></figure><h5 id="6）队列组"><a href="#6）队列组" class="headerlink" title="6）队列组"></a>6）队列组</h5><p>dispatch_group</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 全局变量group</span><br>dispatch_group_t group = dispatch_group_create();<br><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 进入组（进入组和离开组必须成对出现, 否则会造成死锁）</span><br>dispatch_group_enter(group);<br>dispatch_group_async(group, queue, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-comment">//离开组</span><br>    dispatch_group_leave(group);<br>&#125;);<br><br>dispatch_group_enter(group);<br>dispatch_group_async(group, queue, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>    dispatch_group_leave(group);<br>&#125;);<br><br>dispatch_group_notify(group, queue, ^&#123;  <span class="hljs-comment">// 监听组里所有线程完成的情况</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务1，2已完成&quot;</span>);<br>    &#125;);    <br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="（四）NSOperation"><a href="#（四）NSOperation" class="headerlink" title="（四）NSOperation"></a>（四）NSOperation</h3><h4 id="（1）特点："><a href="#（1）特点：" class="headerlink" title="（1）特点："></a>（1）特点：</h4><ul><li>1）基于GCD（底层是GCD）  </li><li>2）比GCD多了一些更简单实用的功能  </li><li>3）使用更加面向对象  <h4 id="（2）使用语言-3"><a href="#（2）使用语言-3" class="headerlink" title="（2）使用语言"></a>（2）使用语言</h4>OC<h4 id="（3）使用频率-3"><a href="#（3）使用频率-3" class="headerlink" title="（3）使用频率"></a>（3）使用频率</h4>经常使用  <h4 id="（4）线程生命周期-3"><a href="#（4）线程生命周期-3" class="headerlink" title="（4）线程生命周期"></a>（4）线程生命周期</h4>自动管理<h4 id="（5）概念、属性与方法-3"><a href="#（5）概念、属性与方法-3" class="headerlink" title="（5）概念、属性与方法"></a>（5）概念、属性与方法</h4><h5 id="1）-创建"><a href="#1）-创建" class="headerlink" title="1）.创建"></a>1）.创建</h5>a.使用子类 NSInvocationOperation<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 1.创建 NSInvocationOperation 对象</span><br><span class="hljs-built_in">NSInvocationOperation</span> *op = [[<span class="hljs-built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(task1) object:<span class="hljs-literal">nil</span>];<br><br><span class="hljs-comment">// 2.调用 start 方法开始执行操作</span><br>[op start];<br></code></pre></td></tr></table></figure>b.使用子类 NSBlockOperation<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 1.创建 NSBlockOperation 对象</span><br><span class="hljs-built_in">NSBlockOperation</span> *op = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]); <span class="hljs-comment">// 打印当前线程</span><br>    &#125;<br>&#125;];<br><br><span class="hljs-comment">// 2.调用 start 方法开始执行操作</span><br>[op start];<br></code></pre></td></tr></table></figure>c.自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CustomNSOperation</span></span><br><br>- (<span class="hljs-keyword">void</span>)main &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.isCancelled) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>; i++) &#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;current thread: %@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br><br>    <span class="hljs-comment">// 1.创建 CustomNSOperation 对象</span><br>    CustomNSOperation *op = [[CustomNSOperation alloc] init];<br>    <span class="hljs-comment">// 2.调用 start 方法开始执行操作，在主线程调用，将不会开辟新线程</span><br>    [op start];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二-多线程的原理"><a href="#二-多线程的原理" class="headerlink" title="二 多线程的原理"></a>二 多线程的原理</h2></li></ul><p>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）<br>多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）<br>如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象<br>思考：如果线程非常非常多，会发生什么情况？<br>CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源<br>每条线程被调度执行的频次会降低（线程的执行效率降低）</p><h2 id="三-多线程的优点"><a href="#三-多线程的优点" class="headerlink" title="三 多线程的优点"></a>三 多线程的优点</h2><p>能适当提高程序的执行效率<br>能适当提高资源利用率（CPU、内存利用率）</p><h2 id="四-多线程的缺点"><a href="#四-多线程的缺点" class="headerlink" title="四 多线程的缺点"></a>四 多线程的缺点</h2><p>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能<br>线程越多，CPU在调度线程上的开销就越大<br>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</p><h2 id="五-你更倾向于哪一种？"><a href="#五-你更倾向于哪一种？" class="headerlink" title="五 你更倾向于哪一种？"></a>五 你更倾向于哪一种？</h2><p>倾向于GCD：<br>GCD 技术是一个轻量的，底层实现隐藏的神奇技术，我们能够通过GCD和block轻松实现多线程编程，有时候，GCD相比其他系统提供的多线程方法更加有效，当然，有时候GCD不是最佳选择，另一个多线程编程的技术 NSOprationQueue 让我们能够将后台线程以队列方式依序执行，并提供更多操作的入口，这和 GCD 的实现有些类似。<br>这种类似不是一个巧合，在早期，MacOX 与 iOS 的程序都普遍采用Operation Queue来进行编写后台线程代码，而之后出现的GCD技术大体是依照前者的原则来实现的，而随着GCD的普及，在iOS 4 与 MacOS X 10.6以后，Operation Queue的底层实现都是用GCD来实现的。</p><h2 id="六-GCD与NSOprationQueue的区别"><a href="#六-GCD与NSOprationQueue的区别" class="headerlink" title="六 GCD与NSOprationQueue的区别"></a>六 GCD与NSOprationQueue的区别</h2><h3 id="（1）区别"><a href="#（1）区别" class="headerlink" title="（1）区别"></a>（1）区别</h3><ul><li>1.GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择；</li><li>2.在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)；</li><li>3.NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行；</li><li>4.我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样能比GCD更加有效地掌控我们执行的后台任务；</li><li>5.在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码；</li><li>6.我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</li></ul><p>总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。  </p><h3 id="（二）更倾向于哪个"><a href="#（二）更倾向于哪个" class="headerlink" title="（二）更倾向于哪个"></a>（二）更倾向于哪个</h3><p>更倾向于<strong>NSOperation</strong></p><p>NSOperation相对于GCD：  </p><ul><li>1，NSOperation拥有更多的函数可用，具体查看api。NSOperationQueue 是在GCD基础上实现的，只不过是GCD更高一层的抽象。  </li><li>2，在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。  </li><li>3，NSOperationQueue支持KVO。可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）  </li><li>4，GCD 只支持FIFO 的队列，而NSOperationQueue可以调整队列的执行顺序（通过调整权重）。NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。</li></ul><h3 id="（三）使用NSOperation的情况"><a href="#（三）使用NSOperation的情况" class="headerlink" title="（三）使用NSOperation的情况"></a>（三）使用NSOperation的情况</h3><p>各个操作之间有依赖关系、操作需要取消暂停、并发管理、控制操作之间优先级，限制同时能执行的线程数量.让线程在某时刻停止/继续等。</p><h3 id="（四）使用GCD的情况"><a href="#（四）使用GCD的情况" class="headerlink" title="（四）使用GCD的情况"></a>（四）使用GCD的情况</h3><p>一般的需求很简单的多线程操作，用GCD都可以了，简单高效。</p><p>从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。</p><p>当需求简单，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。</p><h2 id="七-常见提问"><a href="#七-常见提问" class="headerlink" title="七 常见提问"></a>七 常见提问</h2><ul><li>  1.你理解的多线程？</li><li>  2.可能会追问，每种多线程基于什么语言？</li><li>  3.生命周期是如何管理？</li><li>  4.你更倾向于哪种？追问至现在常用的两种你的看法是？</li></ul><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://www.jianshu.com/p/686dbf4bbb52">NSThread</a><br><a href="https://www.jianshu.com/p/2d57c72016c6">GCD</a></p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#57;&#x34;&#64;&#49;&#54;&#51;&#46;&#99;&#111;&#109;">&#x5f;&#49;&#x39;&#57;&#x34;&#64;&#49;&#54;&#51;&#46;&#99;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS控件自适应大小</title>
    <link href="/post/eyujn26d.html"/>
    <url>/post/eyujn26d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h1 id="一、文字控件自适应大小"><a href="#一、文字控件自适应大小" class="headerlink" title="一、文字控件自适应大小"></a>一、文字控件自适应大小</h1><h2 id="（一）、实现效果："><a href="#（一）、实现效果：" class="headerlink" title="（一）、实现效果："></a>（一）、实现效果：</h2><p>左边控件长度可被挤压，右边控件完全展示。当左边控件长度过长时，进行挤压，保证右边控件能完全展示。</br></p><p>效果如下图：<br><img src="https://user-gold-cdn.xitu.io/2019/8/16/16c994a46fd816c6?w=366&h=89&f=png&s=9509" alt="左边被挤压"></p><p><img src="https://user-gold-cdn.xitu.io/2019/8/16/16c994bb2ec00a35?w=367&h=87&f=png&s=7730" alt="左边未挤压"></p><span id="more"></span><h2 id="（二）、实现方式："><a href="#（二）、实现方式：" class="headerlink" title="（二）、实现方式："></a>（二）、实现方式：</h2><h3 id="（1）、直接计算控件长度"><a href="#（1）、直接计算控件长度" class="headerlink" title="（1）、直接计算控件长度"></a>（1）、直接计算控件长度</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//计算文字宽度</span><br>- (<span class="hljs-built_in">CGFloat</span>)textWidthFromTitle:(<span class="hljs-built_in">NSString</span> *)title fontSize:(<span class="hljs-built_in">CGFloat</span>)fontSize&#123;<br>    <span class="hljs-built_in">CGSize</span> constrainedSize = <span class="hljs-built_in">CGSizeMake</span>(<span class="hljs-number">0</span>, MAXFLOAT);<br>    <span class="hljs-built_in">CGRect</span> textRect = [title boundingRectWithSize:constrainedSize options:<span class="hljs-built_in">NSStringDrawingUsesLineFragmentOrigin</span><br>                                       attributes:@&#123;<span class="hljs-built_in">NSFontAttributeName</span>:[<span class="hljs-built_in">UIFont</span> systemFontOfSize:fontSize]&#125; context:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-keyword">return</span> textRect.size.width + <span class="hljs-number">1</span>; <span class="hljs-comment">//在label中能显示全</span><br>&#125;<br></code></pre></td></tr></table></figure><p>计算每一个Label的宽度</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//左Lable宽度</span><br><span class="hljs-built_in">CGFloat</span> longWidth = [<span class="hljs-keyword">self</span> textWidthFromTitle:titleArray[<span class="hljs-number">0</span>] fontSize:<span class="hljs-number">15</span>];<br><br><span class="hljs-comment">//中间Lable宽度</span><br><span class="hljs-built_in">CGFloat</span> normalWidth = [<span class="hljs-keyword">self</span> textWidthFromTitle:titleArray[<span class="hljs-number">1</span>] fontSize:<span class="hljs-number">15</span>];<br><br><span class="hljs-comment">//右Lable宽度</span><br><span class="hljs-built_in">CGFloat</span> shortWidth = [<span class="hljs-keyword">self</span> textWidthFromTitle:titleArray[<span class="hljs-number">2</span>] fontSize:<span class="hljs-number">15</span>];<br><br><span class="hljs-comment">//屏幕宽度</span><br><span class="hljs-built_in">CGFloat</span> screenWidth = [<span class="hljs-built_in">UIScreen</span> mainScreen].bounds.size.width;<br><br><span class="hljs-comment">//计算左Label真实宽度</span><br><span class="hljs-built_in">CGFloat</span> longRealWdith = MIN(longWidth, (screenWidth - normalWidth - shortWidth - <span class="hljs-number">10</span> * <span class="hljs-number">4</span>));  <span class="hljs-comment">//间距为10</span><br></code></pre></td></tr></table></figure><p>使用frame或者Masonry进行布局。</p><h3 id="（2）、使用约束优先级"><a href="#（2）、使用约束优先级" class="headerlink" title="（2）、使用约束优先级"></a>（2）、使用约束优先级</h3><h4 id="（a）、理论"><a href="#（a）、理论" class="headerlink" title="（a）、理论"></a>（a）、理论</h4><ul><li><strong>约束优先级</strong></br> 在Autolayout中每个约束都有一个优先级, 优先级的范围是1 ~ 1000。创建一个约束，默认的优先级是最高的1000。</li><li><strong>Content Hugging Priority</strong></br> 该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸，默认是250。</li><li><strong>Content Compression Resistance Priority</strong></br> 该优先级和上面那个优先级相对应，表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩，默认是750</li></ul><p>默认情况下两边的label的Content Hugging和Content Compression优先级都是一样的，所以不做处理的话，左边会显示完全，而右边的会被挤压。</p><p><strong>为了让右边的label完全显示，那么我们需要增大右边label的抗压缩级，或者减小左边label的抗压缩级，总之是得让右边的抗压缩级大于左边的label，这样才能让右边的label内容优先显示。</strong></p><p>UIView中关于Content Hugging 和 Content Compression Resistance的方法有：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">UILayoutPriority</span>)contentHuggingPriorityForAxis:(<span class="hljs-built_in">UILayoutConstraintAxis</span>)axis <span class="hljs-built_in">NS_AVAILABLE_IOS</span>(<span class="hljs-number">6</span>_0);<br>- (<span class="hljs-keyword">void</span>)setContentHuggingPriority:(<span class="hljs-built_in">UILayoutPriority</span>)priority forAxis:(<span class="hljs-built_in">UILayoutConstraintAxis</span>)axis <span class="hljs-built_in">NS_AVAILABLE_IOS</span>(<span class="hljs-number">6</span>_0);<br><br>- (<span class="hljs-built_in">UILayoutPriority</span>)contentCompressionResistancePriorityForAxis:(<span class="hljs-built_in">UILayoutConstraintAxis</span>)axis <span class="hljs-built_in">NS_AVAILABLE_IOS</span>(<span class="hljs-number">6</span>_0);<br>- (<span class="hljs-keyword">void</span>)setContentCompressionResistancePriority:(<span class="hljs-built_in">UILayoutPriority</span>)priority forAxis:(<span class="hljs-built_in">UILayoutConstraintAxis</span>)axis <span class="hljs-built_in">NS_AVAILABLE_IOS</span>(<span class="hljs-number">6</span>_0);<br></code></pre></td></tr></table></figure><h4 id="（b）、代码"><a href="#（b）、代码" class="headerlink" title="（b）、代码"></a>（b）、代码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span>.leftLB mas_makeConstraints:^(MASConstraintMaker *make) &#123;<br>    make.height.equalTo(@(<span class="hljs-number">30</span>));<br>    make.left.equalTo(<span class="hljs-keyword">self</span>.bgView).offset(<span class="hljs-number">10</span>);<br>    make.centerY.equalTo(<span class="hljs-keyword">self</span>.bgView).offset(<span class="hljs-number">-50</span>);<br>    make.right.mas_lessThanOrEqualTo(<span class="hljs-keyword">self</span>.rightLB.mas_left);<br>&#125;];<br>    <br>[<span class="hljs-keyword">self</span>.rightLB mas_makeConstraints:^(MASConstraintMaker *make) &#123;<br>    make.height.equalTo(@(<span class="hljs-number">30</span>));<br>    make.left.mas_greaterThanOrEqualTo(<span class="hljs-keyword">self</span>.leftLB.mas_right);<br>    make.right.equalTo(<span class="hljs-keyword">self</span>.bgView).offset(<span class="hljs-number">-10</span>);<br>    make.centerY.equalTo(<span class="hljs-keyword">self</span>.leftLB);<br>&#125;];<br>    <br>[<span class="hljs-keyword">self</span>.leftLB1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;<br>    make.height.equalTo(@(<span class="hljs-number">30</span>));<br>    make.left.equalTo(<span class="hljs-keyword">self</span>.bgView).offset(<span class="hljs-number">10</span>);<br>    make.centerY.equalTo(<span class="hljs-keyword">self</span>.bgView).offset(<span class="hljs-number">50</span>);<br>    make.right.mas_lessThanOrEqualTo(<span class="hljs-keyword">self</span>.rightLB1.mas_left);<br>&#125;];<br>    <br>[<span class="hljs-keyword">self</span>.rightLB1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;<br>    make.height.equalTo(@(<span class="hljs-number">30</span>));<br>    make.left.mas_greaterThanOrEqualTo(<span class="hljs-keyword">self</span>.leftLB1.mas_right);<br>    make.right.equalTo(<span class="hljs-keyword">self</span>.bgView).offset(<span class="hljs-number">-10</span>);<br>    make.centerY.equalTo(<span class="hljs-keyword">self</span>.leftLB1);<br>&#125;];<br><br><span class="hljs-comment">//下面四行代码四选一即可</span><br><span class="hljs-comment">//让左边的label抗压缩性降低，即可压缩，越高越不容易被压缩</span><br>[<span class="hljs-keyword">self</span>.leftLB1 setContentCompressionResistancePriority:<span class="hljs-built_in">UILayoutPriorityDefaultLow</span> forAxis:<span class="hljs-built_in">UILayoutConstraintAxisHorizontal</span>];<br>    <br><span class="hljs-comment">//或者让左边的label抗拉伸性增高，越高越不容易被拉伸</span><br><span class="hljs-comment">//     [self.leftLB1 setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="hljs-comment">//或者让右边的label抗压缩性增高，即可扩张</span><br><span class="hljs-comment">//     [self.rightLB1 setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="hljs-comment">//或者让右边的label抗拉伸性降低，即可扩张</span><br><span class="hljs-comment">//     [self.rightLB1 setContentHuggingPriority:UILayoutPriorityDefaultLow forAxis:UILayoutConstraintAxisHorizontal];</span><br></code></pre></td></tr></table></figure><h4 id="（c）、效果"><a href="#（c）、效果" class="headerlink" title="（c）、效果"></a>（c）、效果</h4><p><img src="https://user-gold-cdn.xitu.io/2019/8/16/16c99aef7226591a?w=366&h=180&f=png&s=17716"></p><hr><h1 id="二、普通控件等间距自适应大小"><a href="#二、普通控件等间距自适应大小" class="headerlink" title="二、普通控件等间距自适应大小"></a>二、普通控件等间距自适应大小</h1><h2 id="等间距布局，宽度自适应"><a href="#等间距布局，宽度自适应" class="headerlink" title="等间距布局，宽度自适应"></a>等间距布局，宽度自适应</h2><h3 id="（1）、实现效果"><a href="#（1）、实现效果" class="headerlink" title="（1）、实现效果"></a>（1）、实现效果</h3><p><img src="https://user-gold-cdn.xitu.io/2019/8/16/16c99b93add70e25?w=364&h=177&f=png&s=1976"></p><h3 id="（2）、实现"><a href="#（2）、实现" class="headerlink" title="（2）、实现"></a>（2）、实现</h3><p>4个控件，横向布局，控件间距30，第一个控件与父容器间距15，<br> 最后一个控件与父容器间距15</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//将需要布局的view加入一个数组中</span><br><span class="hljs-built_in">NSArray</span> *array = @[v1,v2,v3,v4]; <br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 使用方法，一次性配置：横向布局，控件间距30，第一个控件与父容器间距15，</span><br><span class="hljs-comment"> 最后一个控件与父容器间距15，将MASAxisTypeHorizontal换成MASAxisTypeVertical则是纵向布局</span><br><span class="hljs-comment"> */</span><br>[array mas_distributeViewsAlongAxis:MASAxisTypeHorizontal <br>    withFixedSpacing:<span class="hljs-number">30</span> leadSpacing:<span class="hljs-number">15</span> tailSpacing:<span class="hljs-number">15</span>];<br>    <br><span class="hljs-comment">//给数组中每个view设置约束，在父view的与需要平分的方向的垂直方向的位置，例如需要在水平方向平分，就给一个竖直方向的位置</span><br>[array mas_makeConstraints:^(MASConstraintMaker *make) &#123;<br>    make.centerY.equalTo(<span class="hljs-keyword">self</span>.bgView);<br>    make.height.equalTo(@<span class="hljs-number">100</span>);<br>&#125;];<br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#x39;&#x39;&#x34;&#64;&#x31;&#x36;&#51;&#46;&#99;&#111;&#x6d;">&#95;&#x31;&#x39;&#x39;&#x34;&#64;&#x31;&#x36;&#51;&#46;&#99;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调整UIButton Image与Title位置</title>
    <link href="/post/e7uin26d.html"/>
    <url>/post/e7uin26d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="1、UIEdgeInsetsMake介绍"><a href="#1、UIEdgeInsetsMake介绍" class="headerlink" title="1、UIEdgeInsetsMake介绍"></a>1、UIEdgeInsetsMake介绍</h3><p>首先简单介绍一下<strong>UIEdgeInsetsMake</strong><br>引用：<a href="http://www.jianshu.com/p/0d3dbc30fad5">UIEdgeInsetsMake使用详解</a>的图片和讲解，再加上自己的理解与实现</p><p><strong>先看定义</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-built_in">UIEdgeInsets</span> &#123;<br>  <span class="hljs-built_in">CGFloat</span> top, left, bottom, right; <span class="hljs-comment">// specify amount to inset (positive) for each of the edges. values can be negative to &#x27;outset&#x27;</span><br>&#125; <span class="hljs-built_in">UIEdgeInsets</span>;<br></code></pre></td></tr></table></figure><p>UIEdgeInsets实际就是一个结构体:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-built_in">CGFloat</span> top ,  <span class="hljs-built_in">CGFloat</span> left ,  <span class="hljs-built_in">CGFloat</span> bottom ,  <span class="hljs-built_in">CGFloat</span> right )<br></code></pre></td></tr></table></figure><span id="more"></span><p>要设置的就是四个边距。</p><p>先看一张图：<br><img src="https://user-gold-cdn.xitu.io/2018/1/7/160cf8c937712711?w=300&h=300&f=png&s=15812" alt="图UIEdgeInsets"></p><blockquote><p>图中，蓝色标识为可变区域， 绿色标识为不变区域。<strong>UIEdgeInsets</strong>结构体的属性<strong>top</strong>与<strong>bottom</strong>为一对，用来指定纵向可变区域（黑色虚线矩形），<strong>left</strong>与<strong>right</strong>为一对，用来指定横向可变区域(白色虚线矩形)。当UIButton/UIImageView的<strong>size</strong>大于UIImage的<strong>size</strong>时，会调整图片中可变区域大小以铺满整个控件,具体调整规则如下：</p></blockquote><ul><li>(1)控件宽度大于图片宽度，拉伸白色虚线矩形</li><li>(2)控件高度大于图片高度，拉伸黑色虚线矩形</li><li>(3)控件宽度小于图片宽度时，横向整体缩小(可变区与不变区比例不变)</li><li>(4)控件高度小于图片高度时，纵向整体缩小(可变区与不变区比例不变)</li></ul><hr><h3 id="2、UIEdgeInsetsMake在UIButton上的应用"><a href="#2、UIEdgeInsetsMake在UIButton上的应用" class="headerlink" title="2、UIEdgeInsetsMake在UIButton上的应用"></a>2、UIEdgeInsetsMake在UIButton上的应用</h3><p>上面都是引用别人写的东西，也该说说自己的内容了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-built_in">CGFloat</span> top , <span class="hljs-built_in">CGFloat</span> left , <span class="hljs-built_in">CGFloat</span> bottom , <span class="hljs-built_in">CGFloat</span> right )<br></code></pre></td></tr></table></figure><p>UIEdgeInsetsMake是一个用来描述内容物在包裹容器里面的内边距的一个结构体描述，用UIButton来举例，button里面的Image是内容物，button是包裹容器，可以用UIEdgeInsetsMake结构体来描述Image在button里面的内边距。<br>拿图“UIEdgeInsets”来说就是设置UIEdgeInsetsMake以后，Image的位置就是黑色虚线和白色虚线重合的中间区域。<br>这种理解有一个前提就是用来描述单独内容物，比如在UIButton里面你只设置了Image或者只设置了TitleLabel的时候，当同时设置了Image和TitleLabel的时候，会有一些差别，下面再说。</p><p>回到主题《UIButton的UIEdgeInsetsMake的使用》<br>这里主要是讲UIEdgeInsetsMake在UIButton上的应用，相信很多人都遇到了那种需求，就是原本button图片在左，title在右，很多时候确实也是这样，但是有时候需求可能是“图片在上，title在下”或者是“图片在右，title在左”，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/7/160cf8c934c438c0?w=384&h=146&f=png&s=7773" alt="原始按钮"></p><p><img src="https://user-gold-cdn.xitu.io/2018/1/7/160cf8c936084403?w=390&h=160&f=png&s=7877" alt="修改后的按钮"></p><p>这时候原来系统自带按钮就需要我们使用UIEdgeInsetsMake来进行设置了。上面说到内容物是单一的和多个的是不一样，不一样在哪？</p><p><strong>对于设置了image和title的button，系统会在设置以后自动设置一个合适的ImageEdgeInsets和TitleEdgeInsets</strong></p><p>问：啥叫合适的？<br>答：你new一个button显示一下就会发现，他边距确实蛮合适的，虽然有时候title挤在一起显示不全，但是起码边距看上去蛮顺眼，所以我也不知道啥叫合适的，我只知道new一个button，设置了image和title以后，就会有一个默认的ImageEdgeInsets和TitleEdgeInsets。</p><p>下面我们在设置image和title之后，打印一下两者的边距：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//生成button</span><br><span class="hljs-built_in">UIButton</span> *button = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<br>[button setTitle:<span class="hljs-string">@&quot;这是一个按钮&quot;</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>[button setImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;image&quot;</span>] forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>button.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">160</span>, <span class="hljs-number">40</span>);<br>button.backgroundColor = [<span class="hljs-built_in">UIColor</span> redColor];<br>button.titleLabel.backgroundColor = [<span class="hljs-built_in">UIColor</span> purpleColor];<br>[<span class="hljs-keyword">self</span>.view addSubview:button];<br><br><span class="hljs-comment">//打印before</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;before--&gt;%@&quot;</span>,<span class="hljs-built_in">NSStringFromUIEdgeInsets</span>(button.imageEdgeInsets));<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;before--&gt;%@&quot;</span>,<span class="hljs-built_in">NSStringFromUIEdgeInsets</span>(button.titleEdgeInsets));<br><br><span class="hljs-comment">//修改边距</span><br>button.imageEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, button.titleLabel.intrinsicContentSize.width, <span class="hljs-number">0</span>, -button.titleLabel.intrinsicContentSize.width);<br>button.titleEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, -button.currentImage.size.width, <span class="hljs-number">0</span>, button.currentImage.size.width);<br><br><span class="hljs-comment">//打印after</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;after--&gt;%@&quot;</span>,<span class="hljs-built_in">NSStringFromUIEdgeInsets</span>(button.imageEdgeInsets));<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;after--&gt;%@&quot;</span>,<span class="hljs-built_in">NSStringFromUIEdgeInsets</span>(button.titleEdgeInsets));<br></code></pre></td></tr></table></figure><p>会发现两者的边距，会发现两者打印出来都是（0，0，0，0）和（0，0，0，0）。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/7/160cf8c938329845?w=1096&h=130&f=png&s=50521" alt="打印结果"></p><p>WTF？？？你是来逗我的，这边距明显都不为0啊，所以我<strong>猜想</strong>，这个其实并不是image和titleLabel相对于button的边距，这是在原有基础边距基础上进行的一个偏移。</p><p><strong>上面我们说到，在给button设置了image和title以后，系统会自动设置一个合适</strong>（多合适，看原始按钮那个图就知道，确实蛮合适的这边距）**的ImageEdgeInsets和TitleEdgeInsets，所以我们此时打印before其实可能打印的并不是真实的imageEdgeInsets和titleEdgeInsets，而是我们设置的EdgeInsets，因为我们没有设置，所以都打印（0，0，0，0），后来我们设置以后，打印出了{0, 110.5, 0, -110.5}和{0, -23, 0, 23}**。<br>现在就要说说设置的这两行代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">button.imageEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, button.titleLabel.intrinsicContentSize.width, <span class="hljs-number">0</span>, -button.titleLabel.intrinsicContentSize.width);<br>button.titleEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, -button.currentImage.size.width, <span class="hljs-number">0</span>, button.currentImage.size.width);<br></code></pre></td></tr></table></figure><p>一个更新image的边距，一个更新title的边距。<br>首先我们说更新image的边距，我们需要让image右移一个titleLabel的宽度的距离，所以我们需要image的左右边距都右移一个titleLabel。<br>还记得我们一开始设定的正负方向吗，(warning：left以右为正方向，right以左为正方向，但是可以帮助理解下面进行偏移时+ -距离，top向下为正和bottom向上为正，这个可以参照使用masonry进行约束设置判定方向)。</p><p>我们使用button.titleLabel.intrinsicContentSize.width计算titleLabel的宽度（<strong>tips：使用button.titleLabel.bounds.size.width的在iOS8以上会得到宽度为0的结果，造成错误的结果</strong>），然后因为image的left和right都要向右偏移一个titleLabel的宽度，而left以右为正方向，right以左为正方向，所以是设置的是</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, button.titleLabel.intrinsicContentSize.width, <span class="hljs-number">0</span>, -button.titleLabel.intrinsicContentSize.width);```<br>同理，titleLabel需要向左移一个image的宽度，按照我们预想的正负方向进行设置：<br>```objectivec<br>button.titleEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, -button.currentImage.size.width, <span class="hljs-number">0</span>, button.currentImage.size.width);<br></code></pre></td></tr></table></figure><p>这里需要注意<strong>使用<code>button.currentImage.size.width</code>计算得到的效果要好于button.imageView计算出来的width</strong></p><hr><p>总结模式：</p><ul><li>图片在左，title在右</li><li>图片在上，title在下</li><li>图片在右，title在左</li><li>图片在下，title在上</li></ul><p>贴出代码，就不一一讲解了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)layoutButtonWithEdgeInsetsStyle:(<span class="hljs-built_in">MKButtonEdgeInsetsStyle</span>)style<br>                        imageTitleSpace:(<span class="hljs-built_in">CGFloat</span>)space &#123;<br>    <span class="hljs-comment">// 1. 得到imageView和titleLabel的宽、高</span><br>    <span class="hljs-comment">//    CGFloat imageWith = self.imageView.frame.size.width;</span><br>    <span class="hljs-comment">//    CGFloat imageHeight = self.imageView.frame.size.height;</span><br>    <span class="hljs-built_in">CGFloat</span> imageWith = <span class="hljs-keyword">self</span>.currentImage.size.width;<br>    <span class="hljs-built_in">CGFloat</span> imageHeight = <span class="hljs-keyword">self</span>.currentImage.size.height;<br><br>    <span class="hljs-built_in">CGFloat</span> labelWidth = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-built_in">CGFloat</span> labelHeight = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">UIDevice</span> currentDevice].systemVersion.floatValue &gt;= <span class="hljs-number">8.0</span>) &#123;<br>        <span class="hljs-comment">// 由于iOS8中titleLabel的size为0，用下面的这种设置</span><br>        labelWidth = <span class="hljs-keyword">self</span>.titleLabel.intrinsicContentSize.width;<br>        labelHeight = <span class="hljs-keyword">self</span>.titleLabel.intrinsicContentSize.height;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        labelWidth = <span class="hljs-keyword">self</span>.titleLabel.frame.size.width;<br>        labelHeight = <span class="hljs-keyword">self</span>.titleLabel.frame.size.height;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 声明全局的imageEdgeInsets和labelEdgeInsets</span><br>    <span class="hljs-built_in">UIEdgeInsets</span> imageEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsZero</span>;<br>    <span class="hljs-built_in">UIEdgeInsets</span> labelEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsZero</span>;<br><br>    <span class="hljs-comment">// 3. 根据style和space得到imageEdgeInsets和labelEdgeInsets的值</span><br>    <span class="hljs-keyword">switch</span> (style) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">MKButtonEdgeInsetsStyleTop</span>: &#123;<br>            imageEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(-labelHeight-space, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -labelWidth);<br>            labelEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, -imageWith, -imageHeight-space, <span class="hljs-number">0</span>);<br>        &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">MKButtonEdgeInsetsStyleLeft</span>: &#123;<br>            imageEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, -space, <span class="hljs-number">0</span>, space);<br>            labelEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, space, <span class="hljs-number">0</span>, -space);<br>        &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">MKButtonEdgeInsetsStyleBottom</span>: &#123;<br>            imageEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -labelHeight-space, -labelWidth);<br>            labelEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(-imageHeight-space, -imageWith, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">MKButtonEdgeInsetsStyleRight</span>: &#123;<br>            imageEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, labelWidth+space, <span class="hljs-number">0</span>, -labelWidth-space);<br>            labelEdgeInsets = <span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, -imageWith-space, <span class="hljs-number">0</span>, imageWith+space);<br>        &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4. 赋值</span><br>    <span class="hljs-keyword">self</span>.titleEdgeInsets = labelEdgeInsets;<br>    <span class="hljs-keyword">self</span>.imageEdgeInsets = imageEdgeInsets;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、联系方式"><a href="#3、联系方式" class="headerlink" title="3、联系方式"></a>3、联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#57;&#x39;&#x34;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109;">&#x5f;&#x31;&#57;&#x39;&#x34;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>UIButton</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>class与objc_getClass方法</title>
    <link href="/post/db79nmkl.html"/>
    <url>/post/db79nmkl.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开发过程中，我们有时候需要获取当前屏幕显示的最顶层的ViewController，然后操作这个ViewController实现一些功能，比如加个加载圈，提示框之类的。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过最底层的ViewController依次向上寻找，直到找到最顶层的ViewController，也就是从UIApplication的keyWindow的rootViewController开始寻找（如果有多个UIWindow则要考虑UIWindow的选择问题。</p><p>在寻找的过程中，要分别考虑当前ViewController是UITabBarController和UINavigationController的情况，同时还要考虑到当前ViewController是否通过<code>presentViewController:animated:completion:</code>模态展示了其他ViewController。</p><span id="more"></span><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// UIViewController+TopViewController.h</span><br><br>+ (<span class="hljs-built_in">UIViewController</span> * )topViewController &#123;<br>    <span class="hljs-built_in">UIViewController</span> *resultVC;<br>    resultVC = [<span class="hljs-keyword">self</span> recursiveTopViewController:[[<span class="hljs-built_in">UIApplication</span> sharedApplication].keyWindow rootViewController]];<br>    <span class="hljs-keyword">while</span> (resultVC.presentedViewController) &#123;<br>        resultVC = [<span class="hljs-keyword">self</span> recursiveTopViewController:resultVC.presentedViewController];<br>    &#125;<br>    <span class="hljs-keyword">return</span> resultVC;<br>&#125;<br><br>+ (<span class="hljs-built_in">UIViewController</span> * )recursiveTopViewController:(<span class="hljs-built_in">UIViewController</span> *)vc &#123;<br>    <span class="hljs-keyword">if</span> ([vc isKindOfClass:[<span class="hljs-built_in">UINavigationController</span> <span class="hljs-keyword">class</span>]]) &#123;<br>        <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> recursiveTopViewController:[(<span class="hljs-built_in">UINavigationController</span> *)vc topViewController]];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([vc isKindOfClass:[<span class="hljs-built_in">UITabBarController</span> <span class="hljs-keyword">class</span>]]) &#123;<br>        <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> recursiveTopViewController:[(<span class="hljs-built_in">UITabBarController</span> *)vc selectedViewController]];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> vc;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIViewController</span> *vc = [<span class="hljs-built_in">UIViewController</span> toViewController];<br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#x39;&#x39;&#52;&#x40;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109;">&#95;&#49;&#x39;&#x39;&#52;&#x40;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新闻类App Top-TabBarController实现</title>
    <link href="/post/a93i76hj.html"/>
    <url>/post/a93i76hj.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="1-写在前面："><a href="#1-写在前面：" class="headerlink" title="1.写在前面："></a>1.写在前面：</h3><p>前段时间项目用到了类似新闻类客户端顶部的滚动条，虽然网上也有很多，但是本着锻炼自己的想法，自己动手写了一个，所幸效果不差，遂分享出来，一方面给大家参考，一方面也给自己记录。</p><p>上效果图：<br><img src="https://user-gold-cdn.xitu.io/2018/1/9/160dac17760b6739?w=321&h=575&f=gif&s=355042" alt="效果"></p><span id="more"></span><h3 id="2-使用方法："><a href="#2-使用方法：" class="headerlink" title="2.使用方法："></a>2.使用方法：</h3><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *titleArray = @[<span class="hljs-string">@&quot;推荐&quot;</span>,<span class="hljs-string">@&quot;热点&quot;</span>,<span class="hljs-string">@&quot;视频&quot;</span>,<span class="hljs-string">@&quot;体育&quot;</span>,<span class="hljs-string">@&quot;搞笑&quot;</span>];<br><span class="hljs-built_in">NSMutableArray</span> *vcArray = @[].mutableCopy;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;titleArray.count; i++) &#123;<br>    ViewController *vc = [ViewController new];<br>    [vcArray addObject:vc];<br>&#125;<br>XBYTopTabBarViewController *tabVC = [[XBYTopTabBarViewController alloc] initWithSegmentTitles:titleArray childVcs:vcArray];<br>[<span class="hljs-keyword">self</span>.navigationController pushViewController:tabVC animated:<span class="hljs-literal">YES</span>];<br></code></pre></td></tr></table></figure><h4 id="方法2：（推荐使用）"><a href="#方法2：（推荐使用）" class="headerlink" title="方法2：（推荐使用）"></a>方法2：（推荐使用）</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//新建ViewController继承XBYTopTabBarViewController，改写init方法</span><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>        <span class="hljs-built_in">NSArray</span> *tabNames = @[<span class="hljs-string">@&quot;推荐&quot;</span>,<span class="hljs-string">@&quot;热点&quot;</span>,<span class="hljs-string">@&quot;视频&quot;</span>,<span class="hljs-string">@&quot;体育&quot;</span>,<span class="hljs-string">@&quot;搞笑&quot;</span>];<br><br>        <span class="hljs-built_in">NSMutableArray</span> *vcs = @[].mutableCopy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> *name <span class="hljs-keyword">in</span> tabNames) &#123;<br>            ViewController *vc = [[ViewController alloc]init];<br>            [vcs addObject:vc];<br>        &#125;<br>        <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> initWithSegmentTitles:tabNames childVcs:vcs];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里是封装的是一个ViewController，网上很多封装的都是view，需要一系列配置，我觉得比较麻烦，还是继承来的快一些，继承XBYTopTabBarViewController以后，有多少个子项新建多个vc，调用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">instancetype</span>)initWithSegmentTitles:(<span class="hljs-built_in">NSArray</span> *)titles<br>                             childVcs:(<span class="hljs-built_in">NSArray</span> *)childVcs;<br></code></pre></td></tr></table></figure><p>方法，这里继承的vc和众多子vc的生命周期都已经设置好了，可以不用管了，只需要继承（懒一点继承也不要了，直接调用上面这个方法），其他的都不用管了。</p><h3 id="3-实现思路："><a href="#3-实现思路：" class="headerlink" title="3.实现思路："></a>3.实现思路：</h3><p>这里用到了两个scrollView<br>上面title一栏是一个scrollView（这里也可以用其他view，这个scrollView不需要左右滑动，但是需要响应点击事件），后面用smallScrollView表示，下面可以左右滑动的部分也是一个scrollView，后面用bigScrollView表示。<br>有多少个滑动项，就新建多少个label添加到smallScrollView里面：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)setupSmallScrollView &#123;<br>    <span class="hljs-built_in">CGFloat</span> labelW = kScreenWidth/(<span class="hljs-keyword">self</span>.segmentTitles.count&gt;<span class="hljs-number">5</span>?<span class="hljs-number">5</span>:<span class="hljs-keyword">self</span>.segmentTitles.count);<br>    <span class="hljs-keyword">self</span>.smallScrollView.contentSize = <span class="hljs-built_in">CGSizeMake</span>(labelW * <span class="hljs-keyword">self</span>.segmentTitles.count, <span class="hljs-number">44</span>);<br><br>    <span class="hljs-built_in">CGFloat</span> labelX,labelY = <span class="hljs-number">0</span>, labelH = smallScrollViewH;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">self</span>.segmentTitles.count; i++) &#123;<br>        labelX = i * labelW;<br>        GGSOrderStatusLabel *label = [[GGSOrderStatusLabel alloc]initWithFrame:<span class="hljs-built_in">CGRectMake</span>(labelX, labelY, labelW, labelH)];<br>        label.text = <span class="hljs-keyword">self</span>.segmentTitles[i];<br>        label.tag = i;<br>        label.userInteractionEnabled = <span class="hljs-literal">YES</span>;<br>        [label addGestureRecognizer:[[<span class="hljs-built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(labelTapAction:)]];<br>        [<span class="hljs-keyword">self</span>.smallScrollView addSubview:label];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>给label添加手势，响应点击事件，同时让bigScrollView跟随点击的smallScrollView的子项联动：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)labelTapAction:(<span class="hljs-built_in">UITapGestureRecognizer</span> *)gesture &#123;<br>    GGSOrderStatusLabel *titlelable = (GGSOrderStatusLabel *)gesture.view;<br>    <span class="hljs-keyword">if</span> (titlelable.tag == _currentIndex) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">CGFloat</span> offsetX = titlelable.tag * <span class="hljs-keyword">self</span>.bigScrollView.frame.size.width;<br><br>    <span class="hljs-built_in">CGFloat</span> offsetY = <span class="hljs-keyword">self</span>.bigScrollView.contentOffset.y;<br>    <span class="hljs-built_in">CGPoint</span> offset = <span class="hljs-built_in">CGPointMake</span>(offsetX, offsetY);<br><br>    [<span class="hljs-keyword">self</span>.bigScrollView setContentOffset:offset animated:<span class="hljs-literal">YES</span>];  <span class="hljs-comment">//点击smallScrollView的label项，bigScrollView要联动，同时滚动。</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>实现bigScrollView的代理，让smallScrollView跟随它联动：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/** 滚动结束后调用 */</span><br>- (<span class="hljs-keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="hljs-built_in">UIScrollView</span> *)scrollView &#123;<br>    <span class="hljs-comment">// 获得索引</span><br>    <span class="hljs-built_in">NSUInteger</span> index = scrollView.contentOffset.x / <span class="hljs-keyword">self</span>.bigScrollView.frame.size.width;<br><br>    <span class="hljs-comment">// 滚动标题栏</span><br>    GGSOrderStatusLabel *titleLable = (GGSOrderStatusLabel *)<span class="hljs-keyword">self</span>.smallScrollView.subviews[index];<br>    <span class="hljs-comment">// label居中的offsetx</span><br>    <span class="hljs-built_in">CGFloat</span> offsetx = titleLable.center.x - <span class="hljs-keyword">self</span>.smallScrollView.frame.size.width * <span class="hljs-number">0.5</span>;<br>    <span class="hljs-built_in">CGFloat</span> offsetMax = <span class="hljs-keyword">self</span>.smallScrollView.contentSize.width - <span class="hljs-keyword">self</span>.smallScrollView.frame.size.width;<br>    <span class="hljs-keyword">if</span> (offsetx &lt; <span class="hljs-number">0</span>) &#123;<br>        offsetx = <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offsetx &gt; offsetMax)&#123;<br>        offsetx = offsetMax;<br>    &#125;<br>    <span class="hljs-built_in">CGPoint</span> offset = <span class="hljs-built_in">CGPointMake</span>(offsetx, <span class="hljs-keyword">self</span>.smallScrollView.contentOffset.y);<br>    <span class="hljs-comment">// 要放在gcd里才有动画</span><br>    <span class="hljs-built_in">dispatch_async</span>(GCD_MAINQUEUE, ^&#123;<br>        [<span class="hljs-keyword">self</span>.smallScrollView setContentOffset:offset animated:<span class="hljs-literal">YES</span>];<br>    &#125;);<br><br>    <span class="hljs-built_in">UIViewController</span> *oldVC = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> (_currentIndex != <span class="hljs-number">-1</span>) &#123;<br>        oldVC = <span class="hljs-keyword">self</span>.childVcs[_currentIndex];<br>    &#125;<br><br>    <span class="hljs-built_in">UIViewController</span> *newsVc = <span class="hljs-keyword">self</span>.childVcs[index];<br>    <span class="hljs-keyword">self</span>.currentIndex = index;<br>    <span class="hljs-comment">// 其他label设置成初始状态</span><br>    [<span class="hljs-keyword">self</span>.smallScrollView.subviews enumerateObjectsUsingBlock:^(<span class="hljs-keyword">id</span> obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> *stop) &#123;<br>        <span class="hljs-keyword">if</span> (idx != index) &#123;<br>            GGSOrderStatusLabel *temlabel = <span class="hljs-keyword">self</span>.smallScrollView.subviews[idx];<br>            temlabel.scale = <span class="hljs-number">0.0</span>;<br>        &#125;<br>    &#125;];<br><br>    <span class="hljs-keyword">if</span> (newsVc.view.superview)  &#123;<span class="hljs-comment">//调用生命周期函数(如viewwillappear等)</span><br>        <span class="hljs-keyword">if</span> (oldVC) &#123;<br>            [newsVc beginAppearanceTransition:<span class="hljs-literal">NO</span> animated:<span class="hljs-literal">YES</span>];<br>            [newsVc endAppearanceTransition];<br>        &#125;<br><br>        [newsVc beginAppearanceTransition:<span class="hljs-literal">YES</span> animated:<span class="hljs-literal">YES</span>];<br>        [newsVc endAppearanceTransition];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    [<span class="hljs-keyword">self</span> addChildViewController:newsVc];<br>    newsVc.view.frame = scrollView.bounds;<span class="hljs-comment">//bounds的x就是scrollView的offsetx</span><br>    [<span class="hljs-keyword">self</span>.bigScrollView addSubview:newsVc.view];<br>    [newsVc didMoveToParentViewController:<span class="hljs-keyword">self</span>];<br><br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(segmentViewController:didAddChildViewController:)]) &#123;<br>        [<span class="hljs-keyword">self</span>.delegate segmentViewController:<span class="hljs-keyword">self</span> didAddChildViewController:newsVc];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h3><p>见下面头文件描述：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">XBYTopTabBarViewControllerDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><br><span class="hljs-keyword">@optional</span><br>- (<span class="hljs-keyword">void</span>)topTabBarViewController:(XBYTopTabBarViewController *)topTabBarVC<br>didAddChildViewController:(<span class="hljs-built_in">UIViewController</span> *)childVC;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">XBYTopTabBarViewController</span> : <span class="hljs-title">UIViewController</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">上面滑块的标题</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSArray</span> *segmentTitles;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">一个滑块对应一个viewController</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSMutableArray</span> *childVcs;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">当前滑块的index</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span> currentIndex;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">用于存放滑块的scrollView</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIScrollView</span> *smallScrollView;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">用于存放viewController的scrollView</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIScrollView</span> *bigScrollView;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-keyword">id</span>&lt;XBYTopTabBarViewControllerDelegate&gt; delegate;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">@param titles 滑块标题数组</span><br><span class="hljs-comment">@param childVcs 滑块对应的viewController数组</span><br><span class="hljs-comment">@return &lt;#return value description#&gt;</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-keyword">instancetype</span>)initWithSegmentTitles:(<span class="hljs-built_in">NSArray</span> *)titles<br>childVcs:(<span class="hljs-built_in">NSArray</span> *)childVcs;<br><br></code></pre></td></tr></table></figure><h3 id="4-Demo"><a href="#4-Demo" class="headerlink" title="4.Demo:"></a>4.Demo:</h3><p><a href="https://github.com/Adrenine/XBYTopTabBarViewController">XBYTopTabBarViewController</a></p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#57;&#x39;&#x34;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;">&#x5f;&#x31;&#57;&#x39;&#x34;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>UIScrollView</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>靠谱程序员系列目录</title>
    <link href="/post/10fb75fe.html"/>
    <url>/post/10fb75fe.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h4 id="nbsp-nbsp-【iOS-Sharing】系列目录"><a href="#nbsp-nbsp-【iOS-Sharing】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS Sharing】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjuia973.html">【iOS Sharing】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS笔记】系列目录"><a href="#nbsp-nbsp-【iOS笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【靠谱程序员】系列目录"><a href="#nbsp-nbsp-【靠谱程序员】系列目录" class="headerlink" title="&nbsp;&nbsp;【靠谱程序员】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS警告与报错】系列目录"><a href="#nbsp-nbsp-【iOS警告与报错】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS警告与报错】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2m9iu6d.html">【iOS警告与报错】系列目录</a></h4><h4 id="nbsp-nbsp-【开发笔记】系列目录"><a href="#nbsp-nbsp-【开发笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【开发笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【Leet-Code】系列目录"><a href="#nbsp-nbsp-【Leet-Code】系列目录" class="headerlink" title="&nbsp;&nbsp;【Leet Code】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/d305db71.html">【Leet Code】系列目录</a></h4><h4 id="nbsp-nbsp-【Coding】系列目录"><a href="#nbsp-nbsp-【Coding】系列目录" class="headerlink" title="&nbsp;&nbsp;【Coding】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ab23a973.html">【Coding】系列目录</a></h4><hr><h3 id="【靠谱程序员】系列目录"><a href="#【靠谱程序员】系列目录" class="headerlink" title="【靠谱程序员】系列目录]"></a>【靠谱程序员】系列目录]</h3><h4 id="nbsp-nbsp-【-1】代码风格优化与纠错"><a href="#nbsp-nbsp-【-1】代码风格优化与纠错" class="headerlink" title="&nbsp;&nbsp;【#1】代码风格优化与纠错"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/f829ea4b.html">【#1】代码风格优化与纠错</a></h4><h4 id="nbsp-nbsp-【-2】什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#nbsp-nbsp-【-2】什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="&nbsp;&nbsp;【#2】什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/f9d3oq4d.html">【#2】什么情况使用 weak 关键字，相比 assign 有什么不同？</a></h4><h4 id="nbsp-nbsp-【-3】怎么用-copy-关键字？"><a href="#nbsp-nbsp-【-3】怎么用-copy-关键字？" class="headerlink" title="&nbsp;&nbsp;【#3】怎么用 copy 关键字？"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/1g2rp43e.html">【#3】怎么用 copy 关键字？</a></h4><h4 id="nbsp-nbsp-【-4】这个写法会出什么问题：-property-copy-NSMutableArray-array"><a href="#nbsp-nbsp-【-4】这个写法会出什么问题：-property-copy-NSMutableArray-array" class="headerlink" title="&nbsp;&nbsp;【#4】这个写法会出什么问题： @property (copy) NSMutableArray *array"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/b5y4dc3.html">【#4】这个写法会出什么问题： @property (copy) NSMutableArray *array</a></h4><h4 id="nbsp-nbsp-【-5】如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"><a href="#nbsp-nbsp-【-5】如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？" class="headerlink" title="&nbsp;&nbsp;【#5】如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/5fa0ub2h.html">【#5】如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</a></h4><h4 id="nbsp-nbsp-【-6】-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的？"><a href="#nbsp-nbsp-【-6】-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的？" class="headerlink" title="&nbsp;&nbsp;【#6】@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/87yc6ef.html">【#6】@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？</a></h4><h4 id="nbsp-nbsp-【-7】在-protocol-和-category-中如何使用-property"><a href="#nbsp-nbsp-【-7】在-protocol-和-category-中如何使用-property" class="headerlink" title="&nbsp;&nbsp;【#7】在@protocol 和 category 中如何使用 @property"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/4a8q20e0.html">【#7】在@protocol 和 category 中如何使用 @property</a></h4><hr><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>面试题来源是微博@我就叫Sunny怎么了的这篇博文：<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/">《招聘一个靠谱的 iOS》</a>，其中共55题，除第一题为纠错题外，其他54道均为简答题。<br>出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p><p>答案为<strong>本人自测使用</strong>，部分答案有借鉴孙源（sunnyxx）大神的<a href="https://github.com/ChenYilong/iOSInterviewQuestions">答案</a>以及<a href="https://juejin.im/post/5b0c09425188251550795225">其他答案</a>。</p><p>未经出题者校对，如有纰漏，请指正。</p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#x39;&#57;&#x34;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#x6f;&#x6d;">&#95;&#x31;&#x39;&#57;&#x34;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>靠谱程序员</category>
      
    </categories>
    
    
    <tags>
      
      <tag>目录</tag>
      
      <tag>靠谱程序员</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS数组排序</title>
    <link href="/post/73d0bgy4.html"/>
    <url>/post/73d0bgy4.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p>数组排序比较多，我们讲一种比较常用的，这里涉及到一个知识点：<br><strong>NSComparisonResult：</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-built_in">NSComparisonResult</span> : <span class="hljs-built_in">NSInteger</span> &#123;<br>    <span class="hljs-built_in">NSOrderedAscending</span> = <span class="hljs-number">-1</span>L,<br>    <span class="hljs-built_in">NSOrderedSame</span>,<br>    <span class="hljs-built_in">NSOrderedDescending</span><br>&#125; <span class="hljs-built_in">NSComparisonResult</span>;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/08/21/K8zgpafMl5kIe2L.png" alt="image.png"><br><strong>NSOrderedAscending：</strong> 左边数据比右边小，可理解成增序<br><strong>NSOrderedSame：</strong> 相等<br><strong>NSOrderedDescending：</strong> 左边数据比右边大，可理解成降序</p><span id="more"></span><hr><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *array = @[<span class="hljs-string">@&quot;Benz&quot;</span>,<span class="hljs-string">@&quot;BMW&quot;</span>,<span class="hljs-string">@&quot;Ferrari&quot;</span>,<span class="hljs-string">@&quot;Lamborghini&quot;</span>];<br></code></pre></td></tr></table></figure><h4 id="1、普通排序系统自带的升序"><a href="#1、普通排序系统自带的升序" class="headerlink" title="1、普通排序系统自带的升序"></a>1、普通排序系统自带的升序</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *sortedArray1 = [array sortedArrayUsingSelector:<span class="hljs-keyword">@selector</span>(compare:)];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;普通排序:%@&quot;</span>,sortedArray1);<br></code></pre></td></tr></table></figure><h4 id="2、逆转数组"><a href="#2、逆转数组" class="headerlink" title="2、逆转数组"></a>2、逆转数组</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *sortedArray2 = [array sortedArrayUsingComparator:^<span class="hljs-built_in">NSComparisonResult</span>(<span class="hljs-keyword">id</span> obj1,<span class="hljs-keyword">id</span> obj2) &#123;<br>  <span class="hljs-comment">//逆转</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">NSOrderedDescending</span>;<br>&#125;];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;逆转数组:%@&quot;</span>,sortedArray2);<br></code></pre></td></tr></table></figure><h4 id="3、不逆转（相当于原数组）"><a href="#3、不逆转（相当于原数组）" class="headerlink" title="3、不逆转（相当于原数组）"></a>3、不逆转（相当于原数组）</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *sortedArray3 = [array sortedArrayUsingComparator:^<span class="hljs-built_in">NSComparisonResult</span>(<span class="hljs-keyword">id</span> obj1,<span class="hljs-keyword">id</span> obj2) &#123;<br>  <span class="hljs-comment">//不逆转</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">NSOrderedAscending</span>;<br>&#125;];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;不逆转(原数据):%@&quot;</span>,sortedArray3);<br></code></pre></td></tr></table></figure><h4 id="4、升序排列"><a href="#4、升序排列" class="headerlink" title="4、升序排列"></a>4、升序排列</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *sortedArray4 = [array sortedArrayUsingComparator:^<span class="hljs-built_in">NSComparisonResult</span>(<span class="hljs-keyword">id</span> obj1,<span class="hljs-keyword">id</span> obj2) &#123;<br>  <span class="hljs-comment">//升序</span><br>  <span class="hljs-built_in">NSComparisonResult</span> result = [obj1 compare: obj2];<br>  <span class="hljs-keyword">return</span> result;<br>&#125;];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;升序排列:%@&quot;</span>,sortedArray4);<br></code></pre></td></tr></table></figure><h4 id="5、降序排列"><a href="#5、降序排列" class="headerlink" title="5、降序排列"></a>5、降序排列</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *sortedArray5 = [array sortedArrayUsingComparator:^<span class="hljs-built_in">NSComparisonResult</span>(<span class="hljs-keyword">id</span> obj1, <span class="hljs-keyword">id</span> obj2) &#123;<br>  <span class="hljs-comment">//降序</span><br>  <span class="hljs-built_in">NSComparisonResult</span> result = [obj1  compare: obj2];<br>  <span class="hljs-keyword">return</span> -result;<br>&#125;];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;降序排列:%@&quot;</span>,sortedArray5);<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/08/21/h3dXjODQlcfsEp2.png" alt="image.png"></p><hr><h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h3><p><strong>数组里面存放模型，根据模型的某个属性值来对数组进行重新排序</strong></p><h4 id="1、初始化一些车辆和数组："><a href="#1、初始化一些车辆和数组：" class="headerlink" title="1、初始化一些车辆和数组："></a>1、初始化一些车辆和数组：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">Car *benz = [Car new];<br>benz.name = <span class="hljs-string">@&quot;Benz&quot;</span>;<br>benz.price = <span class="hljs-number">2000.0</span>;<br><br>Car *bmw = [Car new];<br>bmw.name = <span class="hljs-string">@&quot;BMW&quot;</span>;<br>bmw.price = <span class="hljs-number">800</span>;<br><br>Car *ferrari = [Car new];<br>ferrari.name = <span class="hljs-string">@&quot;Ferrari&quot;</span>;<br>ferrari.price = <span class="hljs-number">1200</span>;<br><br>Car *lamborghini = [Car new];<br>lamborghini.name = <span class="hljs-string">@&quot;Lamborghini&quot;</span>;<br>lamborghini.price = <span class="hljs-number">12000</span>;<br><br><span class="hljs-built_in">NSMutableArray</span> *array = @[benz,bmw,ferrari,lamborghini].mutableCopy;<br></code></pre></td></tr></table></figure><h4 id="2、排序方法"><a href="#2、排序方法" class="headerlink" title="2、排序方法"></a>2、排序方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 对数组里存放model的某个属性对数组进行重新排序</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> @param array 待排序数组</span><br><span class="hljs-comment"> @param increase 是否增序排列</span><br><span class="hljs-comment"> @param key 属性</span><br><span class="hljs-comment"> @return &lt;#return value description#&gt;</span><br><span class="hljs-comment"> */</span><br>-(<span class="hljs-built_in">NSArray</span> *)sortArray:(<span class="hljs-built_in">NSArray</span> *)array increase:(<span class="hljs-built_in">BOOL</span>)increase byKey:(<span class="hljs-built_in">NSString</span> *)key&#123;<br><br>    array = [array sortedArrayUsingComparator:<br>             ^<span class="hljs-built_in">NSComparisonResult</span>(Car *obj1, Car *obj2) &#123;<br>                 <span class="hljs-built_in">NSComparisonResult</span> result;<br>                 <span class="hljs-keyword">if</span> ([key isEqualToString:<span class="hljs-string">@&quot;price&quot;</span>]) &#123;<br>                     <span class="hljs-built_in">CGFloat</span> res1 = [[obj1 valueForKey:key] floatValue];<br>                     <span class="hljs-built_in">CGFloat</span> res2 = [[obj2 valueForKey:key] floatValue];<br>                     <span class="hljs-keyword">if</span> (increase) &#123;<br>                         <span class="hljs-keyword">if</span> (res1 &lt; res2)&#123;<br>                             result = <span class="hljs-built_in">NSOrderedAscending</span>;<br>                         &#125;<span class="hljs-keyword">else</span> &#123;<br>                             result = <span class="hljs-built_in">NSOrderedDescending</span>;<br>                         &#125;<br>                     &#125; <span class="hljs-keyword">else</span> &#123;<br>                         <span class="hljs-keyword">if</span> (res1 &lt; res2)&#123;<br>                             result = <span class="hljs-built_in">NSOrderedDescending</span>;<br>                         &#125;<span class="hljs-keyword">else</span> &#123;<br>                             result = <span class="hljs-built_in">NSOrderedAscending</span>;<br>                         &#125;<br>                     &#125;<br>                 &#125; <span class="hljs-keyword">else</span> &#123;<br>                     result = [[obj1 valueForKey:key] compare:[obj2 valueForKey:key]];<br>                     <span class="hljs-keyword">if</span> (!increase) &#123;<br>                         <span class="hljs-keyword">if</span> (result == <span class="hljs-built_in">NSOrderedDescending</span>) &#123;<br>                             result = <span class="hljs-built_in">NSOrderedAscending</span>;<br>                         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result == <span class="hljs-built_in">NSOrderedAscending</span>) &#123;<br>                             result = <span class="hljs-built_in">NSOrderedDescending</span>;<br>                         &#125;<br>                     &#125;<br>                 &#125;<br><br>                 <span class="hljs-keyword">return</span> result;<br>             &#125;].mutableCopy;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3、打印结果"><a href="#3、打印结果" class="headerlink" title="3、打印结果"></a>3、打印结果</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *sortArray;<br>sortArray = [<span class="hljs-keyword">self</span> sortArray:array increase:<span class="hljs-literal">YES</span> byKey:<span class="hljs-string">@&quot;price&quot;</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;increase by price:&quot;</span>);<br><span class="hljs-keyword">for</span> (Car *c <span class="hljs-keyword">in</span> sortArray) &#123;<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;car:%@ --&gt;price:%lf\n&quot;</span>,c.name,c.price);<br>&#125;<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;------分割线------&quot;</span>);<br><br>sortArray = [<span class="hljs-keyword">self</span> sortArray:array increase:<span class="hljs-literal">NO</span> byKey:<span class="hljs-string">@&quot;price&quot;</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;descend by price:&quot;</span>);<br><span class="hljs-keyword">for</span> (Car *c <span class="hljs-keyword">in</span> sortArray) &#123;<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;car:%@ --&gt;price:%lf\n&quot;</span>,c.name,c.price);<br>&#125;<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;------分割线------&quot;</span>);<br><br>sortArray = [<span class="hljs-keyword">self</span> sortArray:array increase:<span class="hljs-literal">YES</span> byKey:<span class="hljs-string">@&quot;name&quot;</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;increase by name:&quot;</span>);<br><span class="hljs-keyword">for</span> (Car *c <span class="hljs-keyword">in</span> sortArray) &#123;<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;car:%@ --&gt;price:%lf\n&quot;</span>,c.name,c.price);<br>&#125;<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;------分割线------&quot;</span>);<br><br>sortArray = [<span class="hljs-keyword">self</span> sortArray:array increase:<span class="hljs-literal">NO</span> byKey:<span class="hljs-string">@&quot;name&quot;</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;descend by name:&quot;</span>);<br><span class="hljs-keyword">for</span> (Car *c <span class="hljs-keyword">in</span> sortArray) &#123;<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;car:%@ --&gt;price:%lf\n&quot;</span>,c.name,c.price);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/08/21/GnWHh5xJrMVT1Pf.png" alt="image.png"></p><p><strong>Warnning:</strong> 可能有眼尖的看客发现了，<code>increase by name</code>和<code>descend by name</code>顺序不对，升序的时候Benz不应该在BMW前面吗？降序Benz在BMW后面吗？注意，这里M是大写，而e是小写，大写的ASCII码在小写前面，所以M比e前。</p><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#57;&#57;&#52;&#64;&#x31;&#x36;&#51;&#46;&#99;&#x6f;&#x6d;">&#x5f;&#x31;&#57;&#57;&#52;&#64;&#x31;&#x36;&#51;&#46;&#99;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>NSArray</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】Two Sum</title>
    <link href="/post/2djk89iu.html"/>
    <url>/post/2djk89iu.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【LeetCode】系列目录"><a href="#【LeetCode】系列目录" class="headerlink" title="【LeetCode】系列目录"></a><a href="https://adrenine.github.io/post/d305db71.html">【LeetCode】系列目录</a></h3><hr><h4 id="Q：Given-an-array-of-integers-return-indices-of-the-two-numbers-such-that-they-add-up-to-a-specific-target"><a href="#Q：Given-an-array-of-integers-return-indices-of-the-two-numbers-such-that-they-add-up-to-a-specific-target" class="headerlink" title="Q：Given an array of integers, return indices of the two numbers such that they add up to a specific target."></a>Q：Given an array of integers, return indices of the two numbers such that they add up to a specific target.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">You may assume that each input would have exactly one solution, <span class="hljs-keyword">and</span> you may <span class="hljs-keyword">not</span> use the same element twice.<br><br>Example:<br><br>Given nums = [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], target = <span class="hljs-number">9</span>,<br><br>Because nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span> + <span class="hljs-number">7</span> = <span class="hljs-number">9</span>,<br><span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>].<br></code></pre></td></tr></table></figure><span id="more"></span><hr><h4 id="E：给一个整型数组和一个数字，如果在整型数组中能有两个数字（每个数字仅可使用一次）相加和为该数字，那么请输出这两个数字在数组中的下标"><a href="#E：给一个整型数组和一个数字，如果在整型数组中能有两个数字（每个数字仅可使用一次）相加和为该数字，那么请输出这两个数字在数组中的下标" class="headerlink" title="E：给一个整型数组和一个数字，如果在整型数组中能有两个数字（每个数字仅可使用一次）相加和为该数字，那么请输出这两个数字在数组中的下标"></a>E：给一个整型数组和一个数字，如果在整型数组中能有两个数字（每个数字仅可使用一次）相加和为该数字，那么请输出这两个数字在数组中的下标</h4><h5 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">数组 nums = [<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>]<br>目标 target = <span class="hljs-number">9</span><br><span class="hljs-number">2</span>+<span class="hljs-number">7</span>=<span class="hljs-number">9</span>，所以返回<span class="hljs-number">2</span>和<span class="hljs-number">7</span>在数组中的下标，下标分别为<span class="hljs-number">0</span>和<span class="hljs-number">1</span>，所以输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><hr><h4 id="A"><a href="#A" class="headerlink" title="A:"></a>A:</h4><h5 id="Approach-1："><a href="#Approach-1：" class="headerlink" title="Approach 1："></a>Approach 1：</h5><p>最简单最先想到的应该就是遍历，外层循环从第一个元素开始，内层循环从外层循环后一个元素开始，比如[2,7,11,15]，外层循环从2开始，内层循环从7开始，一个一个遍历。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">nums</span>: [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">target</span>: <span class="hljs-type">Int</span>)</span> -&gt; [<span class="hljs-type">Int</span>] &#123;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>nums.count &#123;<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i<span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span>nums.count &#123;<br>                <span class="hljs-keyword">if</span> nums[i] <span class="hljs-operator">+</span> nums[j] <span class="hljs-operator">==</span> target &#123;<br>                    <span class="hljs-keyword">return</span> [i,j]<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> []<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Complexity-Analysis："><a href="#Complexity-Analysis：" class="headerlink" title="Complexity Analysis："></a>Complexity Analysis：</h5><ul><li>时间复杂度： O(n²)。外层循环n次，内层循环（n+1)/2次，总循环n（n+1)/2次，忽略低次项，故时间复杂度为 O(n²)。（LeetCode：572 ms）</li><li>空间复杂度：O(1)。无需额外附加空间，所以为常数次项O(1)。</li></ul><hr><h5 id="Approach-2："><a href="#Approach-2：" class="headerlink" title="Approach 2："></a>Approach 2：</h5><p>匹配问题可以通过Hash Table来解决，我们将给定数组的所有当成key，然后将对应的下标当成value组成一个新的数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>,<span class="hljs-number">7</span>:<span class="hljs-number">1</span>,<span class="hljs-number">11</span>:<span class="hljs-number">2</span>,<span class="hljs-number">15</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>然后开始遍历，将target=9减去每一个key得到一个index，如果index存在于剩余的key中，则获取当前key的value和index的value。<br>如：第一个Dictionary:[2:0],9-2=7，剩余的Dictionary存在一个key为7的Dictionary，所以获得[2：0]，[7：1]，所以当前解是：[0,1]</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">nums</span>: [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">target</span>: <span class="hljs-type">Int</span>)</span> -&gt; [<span class="hljs-type">Int</span>] &#123;<br>        <span class="hljs-keyword">var</span> dic : [<span class="hljs-type">Int</span> : <span class="hljs-type">Int</span>] <span class="hljs-operator">=</span> [:]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>nums.count &#123;<br>            dic.updateValue(i, forKey: nums[i])<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> dic &#123;<br>            <span class="hljs-keyword">let</span> index <span class="hljs-operator">=</span> target <span class="hljs-operator">-</span> key<br>            <span class="hljs-keyword">if</span> dic.keys.contains(index) <span class="hljs-operator">&amp;&amp;</span> value <span class="hljs-operator">!=</span> dic[index] &#123;<br>                <span class="hljs-keyword">return</span> [value, dic[index]<span class="hljs-operator">!</span>]<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> []<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="Complexity-Analysis：-1"><a href="#Complexity-Analysis：-1" class="headerlink" title="Complexity Analysis："></a>Complexity Analysis：</h5><ul><li>时间复杂度： O(n)。</li><li>空间复杂度：O(n)。</li></ul><p><strong>Warning：</strong> Approach 2方法存在一个问题，当数组存在两个相同数字时，且这两个数字刚好为解时，这个算法会失效。如：nums = [3,3,5],target = 6.该算法得不出正确解，因为Dictionary会将存在的key的值进行更新而不是再插入一次，所以3为key的Dictionary只有一个。</p><hr><h5 id="Approach-3："><a href="#Approach-3：" class="headerlink" title="Approach 3："></a>Approach 3：</h5><p>Approach 2是一次性将数组所有元素都转成Dictionary，但是这样就会有一个问题，当存在值相等的元素，且这俩元素刚好为解的问题，那有没有办法解决这个问题呢，当然有，不要一次性转换不就好了么，边遍历边给Dictionary加元素。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">nums</span>: [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">target</span>: <span class="hljs-type">Int</span>)</span> -&gt; [<span class="hljs-type">Int</span>] &#123;<br>        <span class="hljs-keyword">var</span> dic : [<span class="hljs-type">Int</span> : <span class="hljs-type">Int</span>] <span class="hljs-operator">=</span> [:]<br>        <span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> nums.enumerated() &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> toIndex <span class="hljs-operator">=</span> dic[target <span class="hljs-operator">-</span> value] &#123;<br>                <span class="hljs-keyword">return</span> [toIndex, index]<br>            &#125;<br>            dic[value] <span class="hljs-operator">=</span> index<span class="hljs-comment">//未命中，则加入到Dictionary中</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> []<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Complexity-Analysis：-2"><a href="#Complexity-Analysis：-2" class="headerlink" title="Complexity Analysis："></a>Complexity Analysis：</h5><ul><li>时间复杂度： O(n)。（LeetCode：40ms）</li><li>空间复杂度：O(n)。</li></ul><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#x39;&#x39;&#x34;&#x40;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#109;">&#x5f;&#x31;&#x39;&#x39;&#x34;&#x40;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CocoaPods安装与使用</title>
    <link href="/post/7ghei9e0.html"/>
    <url>/post/7ghei9e0.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>安装命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo gem install cocoapods<br></code></pre></td></tr></table></figure><p>这个需要访问墙外，若不能正常安装，请看下面介绍的换源流程。</br></p><hr><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><h3 id="（1）移除自带源"><a href="#（1）移除自带源" class="headerlink" title="（1）移除自带源"></a>（1）移除自带源</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gem sources --remove https://rubygems.org/<br></code></pre></td></tr></table></figure><span id="more"></span><p>（移除原有的自带ruby源）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ gem sources -a https:<span class="hljs-regexp">//</span>ruby.taobao.org/<br></code></pre></td></tr></table></figure><p>（换用国内淘宝源，请注意是https，http已被弃用，当然，也有用ruby中国的源的，只需将链接改成：<a href="https://gems.ruby-china.com/">https://gems.ruby-china.com/</a> 即可，区别大家自己感受）</p><h4 id="（2）换源"><a href="#（2）换源" class="headerlink" title="（2）换源"></a>（2）换源</h4><p>用下面的命令查看源是否更换</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>gem sources -l<br></code></pre></td></tr></table></figure><p>显示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">*** CURRENT SOURCES ***https:<span class="hljs-regexp">//</span>ruby.taobao.org/<br></code></pre></td></tr></table></figure><p>即更换成功</p><h4 id="（3）安装"><a href="#（3）安装" class="headerlink" title="（3）安装"></a>（3）安装</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sudo gem <span class="hljs-keyword">install</span> cocoapods<br></code></pre></td></tr></table></figure><h4 id="（4）查看版本"><a href="#（4）查看版本" class="headerlink" title="（4）查看版本"></a>（4）查看版本</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">pod <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>查看版本，检查cocoapods是否安装成功，若显示版本号，则安装成功</p><h3 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h3><p>通过命令行工具进入到项目所在目录：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">vim Podfile</span><br></code></pre></td></tr></table></figure><p>进行编辑，以导入Masonry为例：<br><img src="https://i.loli.net/2019/08/21/4nj1wq8HLJfXpck.png" alt="image.png"></p><p>第1行：确认使用平台是在iOS 10.0以上使用</br><br>第3行：将这些第三方类库用在自己建立的项目上</br><br>第5行：导入的第三方库Masonry 1.1.0版本，当然，这句也可以写成</br></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pod</span> <span class="hljs-string">&#x27;Masonry&#x27;</span><br></code></pre></td></tr></table></figure><p>不知道导哪个版本可以这样写，但是个人建议最好写上版本号，也可以用命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pod search Masonry</span><br></code></pre></td></tr></table></figure><p>查看Masonry的版本</br><br>保存关闭Podfile文件，在命令行输入：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pod <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>此时会下载第三方库到项目中。如果第三方类库有很多，可以在pod ‘Masonry’下面写下其他类库的名称，如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pod</span> <span class="hljs-string">&#x27;Masonry&#x27;</span><br>pod <span class="hljs-string">&#x27;AFNetworking&#x27;</span><br></code></pre></td></tr></table></figure><p>保存关闭install，第三方类库就会下载到项目的Pods文件夹中。到此，CocoaPods使用介绍完毕。</p><hr><h2 id="三、卸载"><a href="#三、卸载" class="headerlink" title="三、卸载"></a>三、卸载</h2><p>1、卸载命令：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo gem uninstall cocoapods<br></code></pre></td></tr></table></figure><p>2、先查看本地安装过的cocopods相关东西，命令如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$ gem list --<span class="hljs-keyword">local</span> | <span class="hljs-keyword">grep</span> cocoapods<br></code></pre></td></tr></table></figure><p>会显示如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cocoapods</span>-core (<span class="hljs-number">0</span>.<span class="hljs-number">39</span>.<span class="hljs-number">0</span>)<br><span class="hljs-attribute">cocoapods</span>-downloader (<span class="hljs-number">0</span>.<span class="hljs-number">9</span>.<span class="hljs-number">3</span>)<br><span class="hljs-attribute">cocoapods</span>-plugins (<span class="hljs-number">0</span>.<span class="hljs-number">4</span>.<span class="hljs-number">2</span>)<br><span class="hljs-attribute">cocoapods</span>-search (<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>)<br><span class="hljs-attribute">cocoapods</span>-stats (<span class="hljs-number">0</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>)<br><span class="hljs-attribute">cocoapods</span>-trunk (<span class="hljs-number">0</span>.<span class="hljs-number">6</span>.<span class="hljs-number">4</span>)<br><span class="hljs-attribute">cocoapods</span>-try (<span class="hljs-number">0</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>3、逐个删除：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo gem uninstall cocoapods-core<br></code></pre></td></tr></table></figure><h2 id="四、填坑"><a href="#四、填坑" class="headerlink" title="四、填坑"></a>四、填坑</h2><p>这就完了么，不，不管是用一个东西，还是开发一个东西，我们总会遇到一些坑，现在我们来看看使用中都可能会遇到什么坑：</p><h4 id="坑一："><a href="#坑一：" class="headerlink" title="坑一："></a>坑一：</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">[!] Oh <span class="hljs-keyword">no</span>, <span class="hljs-keyword">an</span> error occurred.<br>It appears <span class="hljs-keyword">to</span> have originated from your Podfile at <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>.<br><br>Search <span class="hljs-keyword">for</span> existing github issues similar <span class="hljs-keyword">to</span> your<span class="hljs-variable">s:</span><br>http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/CocoaPods/CocoaPods/<span class="hljs-built_in">search</span>?q=%<span class="hljs-number">2</span>FUsers%<span class="hljs-number">2</span>Fhuaqiao%<span class="hljs-number">2</span>FDesktop%<span class="hljs-number">2</span>FUserCommand1%<span class="hljs-number">2</span>FPodfile%<span class="hljs-number">3</span>A1%<span class="hljs-number">3</span>A+<span class="hljs-keyword">syntax</span>+error%<span class="hljs-number">2</span>C+unexpected+%<span class="hljs-number">27</span>%<span class="hljs-number">3</span>A%<span class="hljs-number">27</span>%<span class="hljs-number">2</span>C+expecting+end-of-<span class="hljs-built_in">input</span>%<span class="hljs-number">0</span>Aplatform+%<span class="hljs-number">3</span>A+ios+%<span class="hljs-number">0</span>A++++++++++%<span class="hljs-number">5</span>E&amp;<span class="hljs-built_in">type</span>=Issues<br><br>If none <span class="hljs-built_in">exists</span>, create <span class="hljs-keyword">a</span> ticket, with the template displayed above, <span class="hljs-keyword">on</span>:<br>http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/CocoaPods/CocoaPods/issues/<span class="hljs-keyword">new</span><br><br>Be sure <span class="hljs-keyword">to</span> <span class="hljs-keyword">first</span> <span class="hljs-keyword">read</span> the contributing guide <span class="hljs-keyword">for</span> details <span class="hljs-keyword">on</span> how <span class="hljs-keyword">to</span> properly submit <span class="hljs-keyword">a</span> ticke<span class="hljs-variable">t:</span><br>http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/CocoaPods/CocoaPods/blob/master/CONTRIBUTING.md<br></code></pre></td></tr></table></figure><p>看到第一句是不是很有喜感，解决方案：<br> You need reinstall cocoapods: so</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo gem uninstall cocoapods<br>sudo gem install cocoapods<br>pod <span class="hljs-built_in">setup</span><br></code></pre></td></tr></table></figure><h4 id="坑二："><a href="#坑二：" class="headerlink" title="坑二："></a>坑二：</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">Invalid `Podfile` <span class="hljs-symbol">file:</span> [!] Unsupported options `&#123;<span class="hljs-symbol">:exclusive=&gt;true</span>&#125;` <br><span class="hljs-keyword">for</span> target <span class="hljs-string">&#x27;CocoaPodsDemo&#x27;</span><br></code></pre></td></tr></table></figure><p>这种一般是pod install别人的工程，解决办法是将：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">target <span class="hljs-string">&#x27;mySuperApp_Tests&#x27;</span>, :<span class="hljs-function"><span class="hljs-params">exclusive</span> =&gt;</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span> <br>pod <span class="hljs-string">&#x27;mySuperApp&#x27;</span>, :<span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> <span class="hljs-string">&#x27;../&#x27;</span>end<br></code></pre></td></tr></table></figure><p>改成：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">target <span class="hljs-string">&#x27;mySuperApp_Tests&#x27;</span> <span class="hljs-keyword">do</span> pod <span class="hljs-string">&#x27;mySuperApp&#x27;</span>, :<span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> <span class="hljs-string">&#x27;../&#x27;</span> end<br></code></pre></td></tr></table></figure><h4 id="坑三："><a href="#坑三：" class="headerlink" title="坑三："></a>坑三：</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">[!] Unable <span class="hljs-keyword">to</span> <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">source</span> with url <br>`http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/CocoaPods/Specs.git` named `master`.<br></code></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/.cocoapods/</span>repos <br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CocoaPods/</span>Specs.git master<br></code></pre></td></tr></table></figure><p>还有一种报错是：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">[!] Unable to add a source with url `https:</span>//github.com/CocoaPods/Specs.git` named `master-<span class="hljs-number">1</span>`.<br>You can try adding it manually in `~/.cocoapods/repos` <span class="hljs-literal">or</span> via `pod repo add`.<br></code></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">sudo xcode-select -<span class="hljs-keyword">switch</span> <span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<br></code></pre></td></tr></table></figure><p>可以通过：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.cocoapods</span><br>du -sh *<br></code></pre></td></tr></table></figure><p>命令来查看文件大小</p><h4 id="坑四：无论是执行pod-install还是pod-update都卡在了Analyzing-dependencies不动原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下："><a href="#坑四：无论是执行pod-install还是pod-update都卡在了Analyzing-dependencies不动原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下：" class="headerlink" title="坑四：无论是执行pod install还是pod update都卡在了Analyzing dependencies不动原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下："></a>坑四：无论是执行pod install还是pod update都卡在了Analyzing dependencies不动原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pod install --verbose --no-repo-update<br>pod update --verbose --no-repo-update<br></code></pre></td></tr></table></figure><h4 id="坑五：提示找不到头文件"><a href="#坑五：提示找不到头文件" class="headerlink" title="坑五：提示找不到头文件"></a>坑五：提示找不到头文件</h4><p>1，找到TARGETS -&gt; Build Settings -&gt; SearchPaths -&gt; User Header Search Paths 在后面的空白处双击<br>2， 点击 ‘+’号，添加一个新的键为${SRCROOT}，值设置为recursive</p><h4 id="坑六：pod-install和pod-update这俩命令字面意思理解就行，一个安装，一个更新然后我们要说说Podfile-lock文件和Pods文件夹："><a href="#坑六：pod-install和pod-update这俩命令字面意思理解就行，一个安装，一个更新然后我们要说说Podfile-lock文件和Pods文件夹：" class="headerlink" title="坑六：pod install和pod update这俩命令字面意思理解就行，一个安装，一个更新然后我们要说说Podfile.lock文件和Pods文件夹："></a>坑六：pod install和pod update这俩命令字面意思理解就行，一个安装，一个更新然后我们要说说Podfile.lock文件和Pods文件夹：</h4><p>Podfile.lock ：这个文件是用来保存已经安装的Pods依赖库的版本。<br>Pods文件夹：这里边全是引用的三方类库。如果Podfile.lock文件丢失，你再使用pod install命令，并且Podfile中含有没有指定版本的类库，那你的类库就会下载最新的版本，有些比较活跃的三方项目更新很频繁，它们一旦更新方法名或者实现方式，你调用的代码就报错了，这是灾难性的。<br><strong>特别需要注意：使用pod update会更新的你Podfile.lock文件到最新版本，它们一旦更新方法名或者实现方式，你调用的代码就报错了，所以请不要手残。</strong><br>所以千万记住，无论是自己的项目，还是跑别人的源码，一定要用pod install，至于pod update，看你自己是不是要三方升级类库（我还是建议最好在Podfile中指定版本，想要升级，只需更改Podfile中的版本号，再pod install）。</p><h4 id="坑七："><a href="#坑七：" class="headerlink" title="坑七："></a>坑七：</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">sudo gem sources -a https://ruby.taobao.org/ <br><span class="hljs-keyword">Error </span>fetching https://ruby.taobao.org/:<br>server did not return a valid file (http://ruby.taobao.org/specs.4.8.gz)<br></code></pre></td></tr></table></figure><p>这真的是无妄之灾啊，网上找了半天解决办法，试过https改http，也试过：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span>. rvm pkg install openssl<br><span class="hljs-number">2</span>. rvm reinstall <span class="hljs-keyword">all</span> <span class="hljs-comment">--force</span><br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>gem sources --remove <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/rubygems.org/</span><br><span class="hljs-variable">$ </span>gem sources -a <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/ruby.taobao.org/</span><br><span class="hljs-variable">$ </span>gem sources -l*** CURRENT SOURCES ***<br></code></pre></td></tr></table></figure><p>最后问群友，群友说试试看，能不能打开这个网站，结果是公司网络权限问题，对于某宝是不能正常访问的，/气哭/气哭。</p><h4 id="坑八："><a href="#坑八：" class="headerlink" title="坑八："></a>坑八：</h4><p>在运行 “sudo gem install cocoapods” 的时候出现问题：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR: </span>While executing gem ... (Errno::EPERM)<br>Operation not permitted - /usr/bin/fuzzy_match（或者是- /usr/bin/xcodeproj之类的）<br></code></pre></td></tr></table></figure><p>则可以改为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo gem install -n <span class="hljs-regexp">/usr/</span>local/bin cocoapods<br></code></pre></td></tr></table></figure><h2 id="五、常用命令"><a href="#五、常用命令" class="headerlink" title="五、常用命令"></a>五、常用命令</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>、更新gem：<br>sudo gem <span class="hljs-keyword">update</span> --<span class="hljs-built_in">system</span><br><br><span class="hljs-number">2</span>、删除gem源：<br>gem sources --<span class="hljs-built_in">remove</span> [http<span class="hljs-variable">s:</span>//<span class="hljs-keyword">ruby</span>.taobao.org/](http<span class="hljs-variable">s:</span>//<span class="hljs-keyword">ruby</span>.taobao.org/)<br><br><span class="hljs-number">3</span>、修改gem源：<br>gem sources -<span class="hljs-keyword">a</span> [http<span class="hljs-variable">s:</span>//gems.<span class="hljs-keyword">ruby</span>-china.org](http<span class="hljs-variable">s:</span>//gems.<span class="hljs-keyword">ruby</span>-china.org/)<br><br><span class="hljs-number">4</span>、查看gem源是否是最新的：<br>gem sources -<span class="hljs-keyword">l</span><br><br><span class="hljs-number">5</span>、升级cocoapods：<br>sudo gem install -n /usr/local/bin cocoapods --<span class="hljs-keyword">pre</span><br><br><span class="hljs-number">6</span>、查看升级后的cocoapods版本：<br>pod --<span class="hljs-keyword">version</span><br><br></code></pre></td></tr></table></figure><h2 id="六、使用总结"><a href="#六、使用总结" class="headerlink" title="六、使用总结"></a>六、使用总结</h2><ul><li>第一步，创建项目；</li><li>第二步，创建Podfile文件；</li><li>第三步，填写第三方库信息到podfile文件并保存;</li><li>第四步，安装第三方库，退出，用xcworkspace文件打开，这步非常关键，而且只能用这个打开，不是以前的xcodeproj文件了，不然会提示第三方库找不到;</li><li>第五步，导入头文件，开始使用。</li></ul><hr><p><strong>【参考】</strong></p><ul><li><a href="http://www.jianshu.com/p/b64b4fd08d3c">最新Mac OS X 10.11.1 安装cocoapods及使用详解</a></li><li><a href="http://www.jianshu.com/p/6e5c0f78200a">CocoaPods的安装使用和常见问题</a></li></ul><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#57;&#x39;&#x34;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;">&#95;&#x31;&#57;&#x39;&#x34;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>CocoaPods</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UILabel富文本的使用</title>
    <link href="/post/2ui9pf8c.html"/>
    <url>/post/2ui9pf8c.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="1、常见的属性及说明"><a href="#1、常见的属性及说明" class="headerlink" title="1、常见的属性及说明"></a>1、常见的属性及说明</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSFontAttributeName</span>  <span class="hljs-comment">//字体</span><br><span class="hljs-built_in">NSParagraphStyleAttributeName</span>  <span class="hljs-comment">//段落格式 </span><br><span class="hljs-built_in">NSForegroundColorAttributeName</span>  <span class="hljs-comment">//字体颜色</span><br><span class="hljs-built_in">NSBackgroundColorAttributeName</span>  <span class="hljs-comment">//背景颜色</span><br><span class="hljs-built_in">NSStrikethroughStyleAttributeName</span>  <span class="hljs-comment">//删除线格式</span><br><span class="hljs-built_in">NSUnderlineStyleAttributeName</span>  <span class="hljs-comment">//下划线格式</span><br><span class="hljs-built_in">NSStrokeColorAttributeName</span>  <span class="hljs-comment">//删除线颜色</span><br><span class="hljs-built_in">NSStrokeWidthAttributeName</span>  <span class="hljs-comment">//删除线宽度</span><br><span class="hljs-built_in">NSShadowAttributeName</span>  <span class="hljs-comment">//阴影</span><br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="2、常见方法："><a href="#2、常见方法：" class="headerlink" title="2、常见方法："></a>2、常见方法：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//为某一范围内文字设置多个属性</span><br>- (<span class="hljs-keyword">void</span>)setAttributes:(<span class="hljs-built_in">NSDictionary</span> *)attrs range:(<span class="hljs-built_in">NSRange</span>)range;<br><span class="hljs-comment">//为某一范围内文字添加某个属性</span><br>- (<span class="hljs-keyword">void</span>)addAttribute:(<span class="hljs-built_in">NSString</span> *)name value:(<span class="hljs-keyword">id</span>)value range:(<span class="hljs-built_in">NSRange</span>)range;<br><span class="hljs-comment">//为某一范围内文字添加多个属性</span><br>- (<span class="hljs-keyword">void</span>)addAttributes:(<span class="hljs-built_in">NSDictionary</span> *)attrs range:(<span class="hljs-built_in">NSRange</span>)range;<br><span class="hljs-comment">//移除某范围内的某个属性</span><br>- (<span class="hljs-keyword">void</span>)removeAttribute:(<span class="hljs-built_in">NSString</span> *)name range:(<span class="hljs-built_in">NSRange</span>)range;<br></code></pre></td></tr></table></figure><p>更多方法和属性说明详见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMutableAttributedString_Class/Reference/Reference.html#//apple_ref/doc/uid/TP40003689">苹果官方说明文档</a>。</p><h3 id="3、使用示例："><a href="#3、使用示例：" class="headerlink" title="3、使用示例："></a>3、使用示例：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSString</span> *str = <span class="hljs-string">@&quot;犯我中华者，虽远必诛！&quot;</span>;<br><span class="hljs-built_in">NSMutableAttributedString</span> *attrStr = [[<span class="hljs-built_in">NSMutableAttributedString</span> alloc] initWithString:str];<br><span class="hljs-comment">/*说明：NSAttributedString也能设置，与NSMutableAttributedString的关系类似于NSArray和NSMutableArray*/</span><br></code></pre></td></tr></table></figure><p>（1）、添加字体和设置字体的范围</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[attrStr addAttribute:<span class="hljs-built_in">NSFontAttributeName</span> value: [<span class="hljs-built_in">UIFont</span> systemFontOfSize:<span class="hljs-number">20.0</span>f] range:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)];  <span class="hljs-comment">//字体大小为20.0f</span><br>[attrStr addAttribute:<span class="hljs-built_in">NSFontAttributeName</span> value: [<span class="hljs-built_in">UIFont</span> boldSystemFontOfSize:<span class="hljs-number">20.0</span>f] range:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)];  <span class="hljs-comment">//字体大小为20.0f并且加粗</span><br><br></code></pre></td></tr></table></figure><p>（2）、添加文字颜色</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[attrStr addAttribute:<span class="hljs-built_in">NSForegroundColorAttributeName</span> value: [<span class="hljs-built_in">UIColor</span> redColor] range:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>)];<br><br></code></pre></td></tr></table></figure><p>（3）、添加下划线</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[attrStr addAttribute:<span class="hljs-built_in">NSUnderlineStyleAttributeName</span> value: [<span class="hljs-built_in">NSNumber</span> numberWithInteger:<span class="hljs-built_in">NSUnderlineStyleSingle</span>] range:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>)];<br></code></pre></td></tr></table></figure><p>（4）、设置段落样式</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSMutableParagraphStyle</span> *paragraph = [[<span class="hljs-built_in">NSMutableParagraphStyle</span> alloc] init];<br><span class="hljs-comment">//行间距</span><br>paragraph.lineSpacing = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//段落间距</span><br>paragraph.paragraphSpacing = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//对齐方式</span><br>paragraph.alignment = <span class="hljs-built_in">NSTextAlignmentLeft</span>;<br><span class="hljs-comment">//指定段落开始的缩进像素</span><br>paragraph.firstLineHeadIndent = <span class="hljs-number">30</span>;<br><span class="hljs-comment">//调整全部文字的缩进像素paragraph.headIndent = 10;</span><br></code></pre></td></tr></table></figure><p>（5）、添加段落设置</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[attrStr addAttribute:<span class="hljs-built_in">NSParagraphStyleAttributeName</span> value:paragraph range:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, [str length])];<br></code></pre></td></tr></table></figure><p>（6）、添加链接<br>label添加链接注意：label链接是可以显示出来，但是不能点击，而textView是可以点击的，因为里面有shouldInteractWithURL代理方法回调。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSString</span> *urlStr = <span class="hljs-string">@&quot;www.baidu.com&quot;</span>;<br><span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:urlStr];<br>[attrStr addAttribute:<span class="hljs-built_in">NSLinkAttributeName</span> value:url range:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">2</span>, <span class="hljs-number">7</span>)];<br></code></pre></td></tr></table></figure><p>（7）、一次性搞定：设字号为20，字体颜色为红色</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSDictionary</span> *attDict = [<span class="hljs-built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: [<span class="hljs-built_in">UIFont</span> systemFontOfSize:<span class="hljs-number">20.0</span>],<span class="hljs-built_in">NSFontAttributeName</span>, [<span class="hljs-built_in">UIColor</span> redColor],<span class="hljs-built_in">NSForegroundColorAttributeName</span>,<br>  <span class="hljs-literal">nil</span>];<br><span class="hljs-built_in">NSMutableAttributedString</span> *AttributedStr = [[<span class="hljs-built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="hljs-string">@&quot;犯我华夏者，虽远必诛！&quot;</span> attributes:attDict];<br></code></pre></td></tr></table></figure><h3 id="4、label其他一些常用属性："><a href="#4、label其他一些常用属性：" class="headerlink" title="4、label其他一些常用属性："></a>4、label其他一些常用属性：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//创建label</span><br><span class="hljs-built_in">UILabel</span> *label = [[<span class="hljs-built_in">UILabel</span> alloc] initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">60</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">0</span>)];<br><span class="hljs-comment">//设置背景颜色</span><br>label.backgroundColor = [<span class="hljs-built_in">UIColor</span> lightGrayColor];<br><span class="hljs-comment">//自动换行</span><br>label.numberOfLines = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//设置label的富文本</span><br>label.attributedText = attrStr;<br><span class="hljs-comment">//label高度自适应</span><br>[label sizeToFit];<br><br><span class="hljs-comment">//打印高度</span><br><span class="hljs-built_in">CGFloat</span> height = label.frame.size.height;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;height = %f&quot;</span>,height);<br></code></pre></td></tr></table></figure><p>**<br>PS:设置sizeToFit之后是可以取出label的高度的，这样做label高度自适应。但是如果你用第三方框架（如：Masonry）给其加约束，因为约束优先级最高，所以这句会失效<br>**</p><h3 id="5、设置行间距"><a href="#5、设置行间距" class="headerlink" title="5、设置行间距"></a>5、设置行间距</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSString</span> *textStr = <span class="hljs-string">@&quot;:设置sizeToFit之后是可以取出label的高度的，这样做label高度自适应。但是如果你用第三方框架（如：Masonry）给其加约束，因为约束优先级最高，所以这句会失效&quot;</span>;  <br><span class="hljs-built_in">UIFont</span> *textFont = [<span class="hljs-built_in">UIFont</span> systemFontOfSize:<span class="hljs-number">14</span>];  <br><span class="hljs-built_in">CGSize</span> textSize = [textStr sizeWithFont:textFont constrainedToSize:<span class="hljs-built_in">CGSizeMake</span>(bounds.size.width - <span class="hljs-number">40</span>, QZONE_SCREEN_HEIGHT)];  <br><span class="hljs-built_in">UILabel</span> *openMicPrivilegeTipsLabel = [[<span class="hljs-built_in">UILabel</span> alloc] initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, textSize.width, textSize.height)];  <br>openMicPrivilegeTipsLabel.textColor = DefaultDescriptionText2ColorInDefaultTheme;  <br>openMicPrivilegeTipsLabel.text = textStr;  <br>openMicPrivilegeTipsLabel.backgroundColor = [<span class="hljs-built_in">UIColor</span> clearColor];  <br>openMicPrivilegeTipsLabel.textAlignment = <span class="hljs-built_in">UITextAlignmentLeft</span>;  <br>openMicPrivilegeTipsLabel.font = [<span class="hljs-built_in">UIFont</span> systemFontOfSize:<span class="hljs-number">14</span>];  <br>openMicPrivilegeTipsLabel.numberOfLines = <span class="hljs-number">0</span>;  <br><br><span class="hljs-comment">// 调整行间距  </span><br><span class="hljs-built_in">NSMutableAttributedString</span> *attributedString = [[<span class="hljs-built_in">NSMutableAttributedString</span> alloc] initWithString:textStr];  <br><span class="hljs-built_in">NSMutableParagraphStyle</span> *paragraphStyle = [[<span class="hljs-built_in">NSMutableParagraphStyle</span> alloc] init];  <br>[paragraphStyle setLineSpacing:<span class="hljs-number">6</span>];  <br>[attributedString addAttribute:<span class="hljs-built_in">NSParagraphStyleAttributeName</span> value:paragraphStyle range:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, [textStr length])];  <br>openMicPrivilegeTipsLabel.attributedText = attributedString;  <br><br>[_tipsBG addSubview:openMicPrivilegeTipsLabel];  <br>[openMicPrivilegeTipsLabel sizeToFit];  <br></code></pre></td></tr></table></figure><h3 id="6、联系方式"><a href="#6、联系方式" class="headerlink" title="6、联系方式"></a>6、联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#57;&#57;&#x34;&#64;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#109;">&#x5f;&#x31;&#57;&#57;&#x34;&#64;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>UILabel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UIAlertController的使用</title>
    <link href="/post/a92aa92a.html"/>
    <url>/post/a92aa92a.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><p>由于UIAlertView在iOS 9中已经被废弃，我们找到UIAlertController来代替它来实现弹出框的功能。</p><h3 id="UIAlertController"><a href="#UIAlertController" class="headerlink" title="UIAlertController"></a>UIAlertController</h3><p>在iOS8中，UIAlertController在功能上是和UIAlertView以及UIActionSheet相同的，UIAlertController以一种模块化替换的方式来代替这两货的功能和作用。是使用对话框(alert)还是使用上拉菜单(action sheet)，就取决于在创建控制器时，您是如何设置首选样式的。</p><span id="more"></span><h4 id="默认对话框"><a href="#默认对话框" class="headerlink" title="默认对话框"></a>默认对话框</h4><p>您可以比较一下两种不同的创建对话框的代码，创建基础UIAlertController的代码和创建UIAlertView的代码非常相似：<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIAlertController</span> *alertController = [<span class="hljs-built_in">UIAlertController</span> alertControllerWithTitle: <span class="hljs-string">@&quot;标题&quot;</span><br>  message:<span class="hljs-string">@&quot;这个是UIAlertController的默认样式&quot;</span> preferredStyle:<span class="hljs-built_in">UIAlertControllerStyleAlert</span>];<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> alertController <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertController</span>(title:<span class="hljs-string">&quot;标题&quot;</span>, message: <span class="hljs-string">&quot;这个是UIAlertController的默认样式&quot;</span>, preferredStyle:<br>  <span class="hljs-type">UIAlertControllerStyle</span>.<span class="hljs-type">Alert</span>)<br></code></pre></td></tr></table></figure><p>同创建UIAlertView相比，我们无需指定代理，也无需在初始化过程中指定按钮。不过要特别注意第三个参数，要确定您选择的是对话框样式还是上拉菜单样式。<br>通过创建UIAlertAction的实例，您可以将动作按钮添加到控制器上。UIAlertAction由标题字符串、样式以及当用户选中该动作时运行的代码块组成。通过UIAlertActionStyle，您可以选择如下三种动作样式：常规(default)、取消(cancel)以及警示(destruective)。<br>为了实现原来我们在创建UIAlertView时创建的按钮效果，我们只需创建这两个动作按钮并将它们添加到控制器上即可。<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIAlertAction</span> *cancelAction = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:<span class="hljs-string">@&quot;取消&quot;</span><br>  style:<span class="hljs-built_in">UIAlertActionStyleCancel</span> handler:<span class="hljs-literal">nil</span>];<br><span class="hljs-built_in">UIAlertAction</span> *okAction = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:<span class="hljs-string">@&quot;好的&quot;</span><br>  style:<span class="hljs-built_in">UIAlertActionStyleDefault</span> handler:<span class="hljs-literal">nil</span>];<br><br>[alertController addAction:cancelAction];<br>[alertController addAction:okAction];<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift">varcancelAction <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertAction</span>(title:<span class="hljs-string">&quot;取消&quot;</span>,<br>  style: <span class="hljs-type">UIAlertActionStyle</span>.<span class="hljs-type">Cancel</span>, handler: <span class="hljs-literal">nil</span>)<br>varokAction <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertAction</span>(title:<span class="hljs-string">&quot;好的&quot;</span>,<br>  style: <span class="hljs-type">UIAlertActionStyle</span>.<span class="hljs-type">Default</span>, handler: <span class="hljs-literal">nil</span>)<br>alertController.addAction(cancelAction)<br>alertController.addAction(okAction)<br></code></pre></td></tr></table></figure><p>最后，我们只需显示这个对话框视图控制器即可：<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-keyword">self</span> presentViewController:alertController animated:<span class="hljs-literal">YES</span> completion:<span class="hljs-literal">nil</span>];<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">self</span>.presentViewController(alertController, animated:<span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2887980-979e2d28c68def5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIAlertController默认样式"></p><p>按钮显示的次序取决于它们添加到对话框控制器上的次序。一般来说，根据苹果官方制定的《iOS 用户界面指南》，在拥有两个按钮的对话框中，您应当将取消按钮放在左边。要注意，取消按钮是唯一的，如果您添加了第二个取消按钮，那么你就会得到如下的一个运行时异常：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">*Terminating app due to uncaught exception<br>‘<span class="hljs-built_in">NSInternalInconsistencyException</span>’, reason: ‘<span class="hljs-built_in">UIAlertController</span> can only<br>have one action with a style of <span class="hljs-built_in">UIAlertActionStyleCancel</span>’<br></code></pre></td></tr></table></figure><hr><h4 id="“警示”样式"><a href="#“警示”样式" class="headerlink" title="“警示”样式"></a>“警示”样式</h4><p>什么是“警示”样式呢？我们先不着急回答这个问题，先来看一下下面关于“警示”样式的简单示例。在这个示例中，我们将前面的示例中的“好的”按钮替换为了“重置”按钮。<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIAlertAction</span> *resetAction = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:<span class="hljs-string">@&quot;重置&quot;</span><br>  style:<span class="hljs-built_in">UIAlertActionStyleDestructive</span> handler:<span class="hljs-literal">nil</span>];<br>[alertController addAction:resetAction];<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> resetAction <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertAction</span>(title:<span class="hljs-string">&quot;重置&quot;</span>,<br>  style: <span class="hljs-type">UIAlertActionStyle</span>.<span class="hljs-type">Destructive</span>, handler: <span class="hljs-literal">nil</span>)<br>alertController.addAction(resetAction)<br></code></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2887980-63d0329524c35765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="“警示”样式"></p><p>可以看出，我们新增的那个“重置”按钮变成了红色。根据苹果官方的定义，“警示”样式的按钮是用在可能会改变或删除数据的操作上。因此用了红色的醒目标识来警示用户。</p><hr><h3 id="文本对话框"><a href="#文本对话框" class="headerlink" title="文本对话框"></a>文本对话框</h3><p>UIAlertController<br>极大的灵活性意味着您不必拘泥于内置样式。以前我们只能在默认视图、文本框视图、密码框视图、登录和密码输入框视图中选择，现在我们可以向对话框中添加任意数目的UITextField对象，并且可以使用所有的UITextField特性。当您向对话框控制器中添加文本框时，您需要指定一个用来配置文本框的代码块。<br>举个栗子吧，要重新建立原来的登录和密码样式对话框，我们可以向其中添加两个文本框，然后用合适的占位符来配置它们，最后将密码输入框设置使用安全文本输入。<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIAlertController</span> *alertController = [<span class="hljs-built_in">UIAlertController</span> alertControllerWithTitle:<br>  <span class="hljs-string">@&quot;文本对话框&quot;</span>message:<span class="hljs-string">@&quot;登录和密码对话框示例&quot;</span><br>  preferredStyle:<span class="hljs-built_in">UIAlertControllerStyleAlert</span>];<br>[alertController addTextFieldWithConfigurationHandler:<br>  ^(<span class="hljs-built_in">UITextField</span> *textField)&#123;<br>    textField.placeholder = <span class="hljs-string">@&quot;登录&quot;</span>;<br>&#125;];<br><br>[alertController addTextFieldWithConfigurationHandler:<br>  ^(<span class="hljs-built_in">UITextField</span> *textField) &#123;<br>    textField.placeholder = <span class="hljs-string">@&quot;密码&quot;</span>;<br>    textField.secureTextEntry = <span class="hljs-literal">YES</span>;<br>&#125;];<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift">alertController.addTextFieldWithConfigurationHandler &#123;<br>  (textField: <span class="hljs-type">UITextField</span>!) -&gt; <span class="hljs-type">Voidin</span><br>  textField.placeholder <span class="hljs-operator">=</span><span class="hljs-string">&quot;登录&quot;</span><br>&#125;<br><br>alertController.addTextFieldWithConfigurationHandler &#123;<br>  (textField: <span class="hljs-type">UITextField</span>!) -&gt; <span class="hljs-type">Voidin</span><br>  textField.placeholder <span class="hljs-operator">=</span><span class="hljs-string">&quot;密码&quot;</span><br>  textField.secureTextEntry <span class="hljs-operator">=</span><span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在“好的”按钮按下时，我们让程序读取文本框中的值。<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIAlertAction</span> *okAction = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:<br>  <span class="hljs-string">@&quot;好的&quot;</span>style:<span class="hljs-built_in">UIAlertActionStyleDefault</span> handler:<br>  ^(<span class="hljs-built_in">UIAlertAction</span> *action) &#123;<br>    <span class="hljs-built_in">UITextField</span> *login = alertController.textFields.firstObject;<br>    <span class="hljs-built_in">UITextField</span> *password = alertController.textFields.lastObject;<br>    ...<br>&#125;];<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> okAction <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertAction</span>(title:<span class="hljs-string">&quot;好的&quot;</span>, style: <span class="hljs-type">UIAlertActionStyle</span>.<span class="hljs-type">Default</span>) &#123;<br>  (action: <span class="hljs-type">UIAlertAction</span>!) -&gt; <span class="hljs-type">Voidin</span><br>  <span class="hljs-keyword">var</span> login <span class="hljs-operator">=</span> alertController.textFields<span class="hljs-operator">?</span>.first <span class="hljs-keyword">as</span> <span class="hljs-type">UITextField</span><br>  <span class="hljs-keyword">var</span> password <span class="hljs-operator">=</span> alertController.textFields<span class="hljs-operator">?</span>.last <span class="hljs-keyword">as</span> <span class="hljs-type">UITextField</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想要实现UIAlertView中的委托方法alertViewShouldEnableOtherButton:方法的话可能会有一些复杂。假定我们要让“登录”文本框中至少有3个字符才能激活“好的”按钮。很遗憾的是，在UIAlertController中并没有相应的委托方法，因此我们需要向“登录”文本框中添加一个Observer。Observer模式定义对象间的一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新。我们可以在构造代码块中添加如下的代码片段来实现。<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[alertController addTextFieldWithConfigurationHandler:<br>  ^(<span class="hljs-built_in">UITextField</span> *textField)&#123;<br>    ...<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span><br>      selector:<span class="hljs-keyword">@selector</span>(alertTextFieldDidChange:) name:<br>      <span class="hljs-built_in">UITextFieldTextDidChangeNotification</span> object:textField];<br>&#125;];<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift">alertController.addTextFieldWithConfigurationHandler &#123;<br>  (textField: <span class="hljs-type">UITextField</span>!) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span><br>  <span class="hljs-operator">...</span><br>  <span class="hljs-type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="hljs-keyword">self</span>, selector:<br>    <span class="hljs-type">Selector</span>(<span class="hljs-string">&quot;alertTextFieldDidChange:&quot;</span>), name:<br>    <span class="hljs-type">UITextFieldTextDidChangeNotification</span>, object: textField)<br>&#125;<br></code></pre></td></tr></table></figure><p>当视图控制器释放的时候我们需要移除这个Observer，我们通过在每个按钮动作的handler代码块（还有其他任何可能释放视图控制器的地方）中添加合适的代码来实现它。比如说在okAction这个按钮动作中：<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIAlertAction</span> *okAction = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:<br>  <span class="hljs-string">@&quot;好的&quot;</span>style:<span class="hljs-built_in">UIAlertActionStyleDefault</span> handler:<br>  ^(<span class="hljs-built_in">UIAlertAction</span> *action) &#123;<br>    ...<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="hljs-keyword">self</span><br>    name:<span class="hljs-built_in">UITextFieldTextDidChangeNotification</span> object:<span class="hljs-literal">nil</span>];<br>&#125;];<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> okAction <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertAction</span>(title:<span class="hljs-string">&quot;好的&quot;</span>, style: <span class="hljs-type">UIAlertActionStyle</span>.<span class="hljs-type">Default</span>) &#123;<br>  (action: <span class="hljs-type">UIAlertAction</span>!) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span><br>  <span class="hljs-operator">...</span><br>  <span class="hljs-type">NSNotificationCenter</span>.defaultCenter().removeObserver(<span class="hljs-keyword">self</span>, name:<br>  <span class="hljs-type">UITextFieldTextDidChangeNotification</span>, object: <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在显示对话框之前，我们要冻结“好的”按钮<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">okAction.enabled = <span class="hljs-literal">NO</span>;<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">okAction.enabled <span class="hljs-operator">=</span><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>接下来，在通知观察者（notification observer）中，我们需要在激活按钮状态前检查“登录”文本框的内容。<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)alertTextFieldDidChange:(<span class="hljs-built_in">NSNotification</span> *)notification&#123;<br>  <span class="hljs-built_in">UIAlertController</span> *alertController =<br>    (<span class="hljs-built_in">UIAlertController</span> *)<span class="hljs-keyword">self</span>.presentedViewController;<br>  <span class="hljs-keyword">if</span>(alertController) &#123;<br>    <span class="hljs-built_in">UITextField</span> *login = alertController.textFields.firstObject;<br>    <span class="hljs-built_in">UIAlertAction</span> *okAction = alertController.actions.lastObject;<br>    okAction.enabled = login.text.length &gt; <span class="hljs-number">2</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">alertTextFieldDidChange</span>(<span class="hljs-params">notification</span>: <span class="hljs-type">NSNotification</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> alertController <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.presentedViewController <span class="hljs-keyword">as</span> <span class="hljs-type">UIAlertController</span>?<br>  <span class="hljs-keyword">if</span>(alertController <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span>) &#123;<br>    <span class="hljs-keyword">var</span> login <span class="hljs-operator">=</span> alertController<span class="hljs-operator">!</span>.textFields<span class="hljs-operator">?</span>.first <span class="hljs-keyword">as</span> <span class="hljs-type">UITextField</span><br>    <span class="hljs-keyword">var</span> okAction <span class="hljs-operator">=</span> alertController<span class="hljs-operator">!</span>.actions.last <span class="hljs-keyword">as</span> <span class="hljs-type">UIAlertAction</span><br>    okAction.enabled <span class="hljs-operator">=</span> countElements(login.text) <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2887980-c4bb0a2ff79226f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登录和密码对话框示例"></p><p>好了，现在对话框的“好的”按钮被冻结了，输入3个以上的字符“登录”文本框才能点击“好的”。</p><h4 id="上拉菜单"><a href="#上拉菜单" class="headerlink" title="上拉菜单"></a>上拉菜单</h4><p>当需要给用户展示一系列选择的时候（选择恐惧症患者杀手），上拉菜单就能够派上大用场了。和对话框不同，上拉菜单的展示形式和设备大小有关。在iPhone上（紧缩宽度），上拉菜单从屏幕底部升起。在iPad上（常规宽度），上拉菜单以弹出框的形式展现。<br>创建上拉菜单的方式和创建对话框的方式非常类似，唯一的区别是它们的形式。<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIAlertController</span> *alertController = [<span class="hljs-built_in">UIAlertController</span> alertControllerWithTitle:<br>  <span class="hljs-string">@&quot;保存或删除数据&quot;</span>message:<span class="hljs-string">@&quot;删除数据将不可恢复&quot;</span><br>  preferredStyle: <span class="hljs-built_in">UIAlertControllerStyleActionSheet</span>];<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift">varalertController <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertController</span>(title:<span class="hljs-string">&quot;保存或删除数据&quot;</span>,<br>  message:<span class="hljs-string">&quot;删除数据将不可恢复&quot;</span>,<br>  preferredStyle: <span class="hljs-type">UIAlertControllerStyle</span>.<span class="hljs-type">ActionSheet</span>)<br></code></pre></td></tr></table></figure><p>添加按钮动作的方式和对话框相同。<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIAlertAction</span> *cancelAction = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:<span class="hljs-string">@&quot;取消&quot;</span><br>  style:<span class="hljs-built_in">UIAlertActionStyleCancel</span> handler:<span class="hljs-literal">nil</span>];<br><span class="hljs-built_in">UIAlertAction</span> *deleteAction = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:<span class="hljs-string">@&quot;删除&quot;</span><br>  style:<span class="hljs-built_in">UIAlertActionStyleDestructive</span> handler:<span class="hljs-literal">nil</span>];<br><span class="hljs-built_in">UIAlertAction</span> *archiveAction = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:<span class="hljs-string">@&quot;保存&quot;</span><br>  style:<span class="hljs-built_in">UIAlertActionStyleDefault</span> handler:<span class="hljs-literal">nil</span>];<br><br>[alertController addAction:cancelAction];<br>[alertController addAction:deleteAction];<br>[alertController addAction:archiveAction];<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift">varcancelAction <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertAction</span>(title:<span class="hljs-string">&quot;取消&quot;</span>,<br>  style: <span class="hljs-type">UIAlertActionStyle</span>.<span class="hljs-type">Cancel</span>, handler: <span class="hljs-literal">nil</span>)<br>vardeleteAction <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertAction</span>(title:<span class="hljs-string">&quot;删除&quot;</span>,<br>  style: <span class="hljs-type">UIAlertActionStyle</span>.<span class="hljs-type">Destructive</span>, handler: <span class="hljs-literal">nil</span>)<br>vararchiveAction <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertAction</span>(title:<span class="hljs-string">&quot;保存&quot;</span>,<br>  style: <span class="hljs-type">UIAlertActionStyle</span>.<span class="hljs-type">Default</span>, handler: <span class="hljs-literal">nil</span>)<br><br>alertController.addAction(cancelAction)<br>alertController.addAction(deleteAction)<br>alertController.addAction(archiveAction)<br></code></pre></td></tr></table></figure><p>您不能在上拉菜单中添加文本框，如果您强行作死添加了文本框，那么就会荣幸地得到一个运行时异常：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">*Terminating app due to uncaught exception<br>‘<span class="hljs-built_in">NSInternalInconsistencyException</span>’, reason: ‘Text fields can only be<br>added to an alert controller of style <span class="hljs-built_in">UIAlertControllerStyleAlert</span>’<br></code></pre></td></tr></table></figure><p>同样，简单的异常说明，我们也不多说了。<br>接下来我们就可以在iPhone或者其他紧缩宽度的设备上展示了，不出我们所料，运行得很成功。<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-keyword">self</span> presentViewController:alertController animated:<span class="hljs-literal">YES</span> completion:<span class="hljs-literal">nil</span>];<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">self</span>.presentViewController(alertController, animated:<span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2887980-8bcf868c43cecbd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上拉菜单效果"></p><p>如果上拉菜单中有“取消”按钮的话，那么它永远都会出现在菜单的底部，不管添加的次序是如何（就是这么任性）。其他的按钮将会按照添加的次序从上往下依次显示。《iOS 用户界面指南》要求所有的“毁坏”样式按钮都必须排名第一（红榜嘛，很好理解的，对不对？）。<br>别激动得太早，我们现在还有一个很严重的问题，这个问题隐藏得比较深。当我们使用iPad或其他常规宽度的设备时，就会得到一个运行时异常：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">Terminating app due to uncaught exception ‘<span class="hljs-built_in">NSGenericException</span>’, reason:<br>‘<span class="hljs-built_in">UIPopoverPresentationController</span><br>(&lt;_uialertcontrolleractionsheetregularpresentationcontroller:<br><span class="hljs-number">0x7fc619588110</span>=<span class="hljs-string">&quot;&quot;</span>&gt;) should have a non-<span class="hljs-literal">nil</span> sourceView or barButtonItem<br>set before the presentation occurs.’<br></code></pre></td></tr></table></figure><p>就如我们之前所说，在常规宽度的设备上，上拉菜单是以弹出框的形式展现。弹出框必须要有一个能够作为源视图或者栏按钮项目的描点(anchor point)。由于在本例中我们是使用了常规的UIButton来触发上拉菜单的，因此我们就将其作为描点。<br>在iOS 8中我们不再需要小心翼翼地计算出弹出框的大小，UIAlertController将会根据设备大小自适应弹出框的大小。并且在iPhone或者紧缩宽度的设备中它将会返回nil值。配置该弹出框的代码如下：<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIPopoverPresentationController</span> *popover =<br>  alertController.popoverPresentationController;<br><span class="hljs-keyword">if</span>(popover)&#123;<br>  popover.sourceView = sender;<br>  popover.sourceRect = sender.bounds;<br>  popover.permittedArrowDirections = <span class="hljs-built_in">UIPopoverArrowDirectionAny</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> popover <span class="hljs-operator">=</span> alertController.popoverPresentationController<br><span class="hljs-keyword">if</span>(popover <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span>)&#123;<br>  popover<span class="hljs-operator">?</span>.sourceView <span class="hljs-operator">=</span> sender<br>  popover<span class="hljs-operator">?</span>.sourceRect <span class="hljs-operator">=</span> sender.bounds<br>  popover<span class="hljs-operator">?</span>.permittedArrowDirections <span class="hljs-operator">=</span> <span class="hljs-type">UIPopoverArrowDirection</span>.<span class="hljs-keyword">Any</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2887980-fccfd786fe461f0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上拉菜单效果"></p><p>UIPopoverPresentationController类同样也是在iOS 8中新出现的类，用来替换UIPopoverController的。这个时候上拉菜单是以一个固定在源按钮上的弹出框的形式显示的。<br>要注意UIAlertController在使用弹出框的时候自动移除了取消按钮。用户通过点击弹出框的外围部分来实现取消操作，因此取消按钮便不再必需。</p><h4 id="释放对话框控制器"><a href="#释放对话框控制器" class="headerlink" title="释放对话框控制器"></a>释放对话框控制器</h4><p>通常情况下，当用户选中一个动作后对话框控制器将会自行释放。不过您仍然可以在需要的时候以编程方式释放它，就像释放其他视图控制器一样。您应当在应用程序转至后台运行时移除对话框或者上拉菜单。假定我们正在监听UIApplicationDidEnterBackgroundNotification通知消息，我们可以在observer中释放任何显示出来的视图控制器。（参考在viewDidLoad方法中设立observer的示例代码）。<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)didEnterBackground:(<span class="hljs-built_in">NSNotification</span> *)notification &#123;<br>  [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="hljs-keyword">self</span><br>name:<span class="hljs-built_in">UITextFieldTextDidChangeNotification</span> object:<span class="hljs-literal">nil</span>];<br>  [<span class="hljs-keyword">self</span>.presentedViewController dismissViewControllerAnimated:<span class="hljs-literal">NO</span><br>completion:<span class="hljs-literal">nil</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>swift版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">didEnterackground</span>(<span class="hljs-params">notification</span>: <span class="hljs-type">NSNotification</span>)</span>&#123;<br>  <span class="hljs-type">NSNotificationCenter</span>.defaultCenter().removeObserver(<span class="hljs-keyword">self</span>,<br>name: <span class="hljs-type">UITextFieldTextDidChangeNotification</span>, object: <span class="hljs-literal">nil</span>)<br>  <span class="hljs-keyword">self</span>.presentedViewController<span class="hljs-operator">?</span>.dismissViewControllerAnimated(<span class="hljs-literal">false</span>,<br>completion: <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，要保证运行安全我们同样要确保移除所有的文本框observer。</p><hr><p>附上以前我们使用UIAlertView实现的一些功能：</p><h4 id="UIAlertView"><a href="#UIAlertView" class="headerlink" title="UIAlertView"></a>UIAlertView</h4><p>初始化和显示一个带有“取消”和“好的”按钮的对话框视图。<br>Objective-C版本：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIAlertView</span> *alertview = [[<span class="hljs-built_in">UIAlertView</span> alloc] initWithTitle:<span class="hljs-string">@&quot;标题&quot;</span><br>  message:<span class="hljs-string">@&quot;这个是UIAlertView的默认样式&quot;</span>delegate:<span class="hljs-keyword">self</span> cancelButtonTitle:<span class="hljs-string">@&quot;取消&quot;</span><br>  otherButtonTitles:<span class="hljs-string">@&quot;好的&quot;</span>, <span class="hljs-literal">nil</span>];<br>[alertview show];<br></code></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2887980-fb35d164ecb61b00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIAlertView的默认样式"></p><p>swift版本和Objective-C版本不同，在swift中，alertView的初始化只允许创建拥有一个取消按钮的对话框视图。或许您可以看到带有otherButtonTitles的init方法，但是很遗憾，这个方法是没有办法通过编译的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">var alertView = <span class="hljs-built_in">UIAlertView</span>(title:<span class="hljs-string">&quot;标题&quot;</span>, message:<span class="hljs-string">&quot;这个是UIAlertView的默认样式&quot;</span>,<br>  delegate: <span class="hljs-keyword">self</span>, cancelButtonTitle:<span class="hljs-string">&quot;取消&quot;</span>)<br>alertView.show()<br></code></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2887980-e99696d6eff26b13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="swift版本的UIAlertView"></p><p>要能够创建和上面Objective-C版本相同的对话框视图，我们可以采取曲线救国的方法，虽然麻烦了些，但是我们为了目的可以不择手段的，是吧？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">varalertView = <span class="hljs-built_in">UIAlertView</span>()<br>alertView.delegate = <span class="hljs-keyword">self</span><br>alertView.title =<span class="hljs-string">&quot;标题&quot;</span><br>alertView.message =<span class="hljs-string">&quot;这个是UIAlertView的默认样式&quot;</span><br>alertView.addButtonWithTitle(<span class="hljs-string">&quot;取消&quot;</span>)<br>alertView.addButtonWithTitle(<span class="hljs-string">&quot;好的&quot;</span>)<br>alertView.show()<br></code></pre></td></tr></table></figure><p>您也可以通过更改UIAlertView的alertViewStyle属性来实现输入文字、密码甚至登录框的效果。<br><img src="http://upload-images.jianshu.io/upload_images/2887980-9d548203db643571.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIAlertView文本对话框"></p><p><img src="http://upload-images.jianshu.io/upload_images/2887980-337326628931dcec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIAlertView密码对话框"></p><p><img src="http://upload-images.jianshu.io/upload_images/2887980-6b87cd485f29312f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIAlertView登录对话框"></p><p>UIAlertViewDelegate协议拥有响应对话框视图的按钮动作的回调方法。还有当文本框内容改变时，调用alertViewShouldEnableOtherButton:方法可以让按钮动态地可用或者不可用。<br>以上UIAlertView仅供参考，不建议加以使用。</p><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#57;&#57;&#x34;&#64;&#x31;&#x36;&#51;&#46;&#99;&#111;&#109;">&#95;&#x31;&#57;&#57;&#x34;&#64;&#x31;&#x36;&#51;&#46;&#99;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>UIAlertController</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Runtime基础（二）</title>
    <link href="/post/c63ec63e.html"/>
    <url>/post/c63ec63e.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="Runtime是什么"><a href="#Runtime是什么" class="headerlink" title="Runtime是什么"></a>Runtime是什么</h3><p>Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的。比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[receiver message];<br><span class="hljs-comment">// 底层运行时会被编译器转化为：</span><br>objc_msgSend(receiver, selector)<br><span class="hljs-comment">// 如果其还有参数比如：</span><br>[receiver message:(<span class="hljs-keyword">id</span>)arg...];<br><span class="hljs-comment">// 底层运行时会被编译器转化为：</span><br>objc_msgSend(receiver, selector, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="为什么需要Runtime"><a href="#为什么需要Runtime" class="headerlink" title="为什么需要Runtime"></a>为什么需要Runtime</h3><p>Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。</p><p>因此，编译器是不够的，我们还需要一个运行时系统(Runtime system)来处理编译后的代码。</p><p>Runtime 基本是用 C 和汇编写的，由此可见苹果为了动态系统的高效而做出的努力。苹果和 GNU 各自维护一个开源的 Runtime 版本，这两个版本之间都在努力保持一致。</p><h3 id="Runtime-的作用"><a href="#Runtime-的作用" class="headerlink" title="Runtime 的作用"></a>Runtime 的作用</h3><p>OC 在三种层面上与 Runtime 系统进行交互：</p><h4 id="1-通过-Objective-C-源代码"><a href="#1-通过-Objective-C-源代码" class="headerlink" title="1.通过 Objective-C 源代码"></a>1.通过 Objective-C 源代码</h4><p>只需要编写 OC 代码，Runtime 系统自动在幕后搞定一切，调用方法，编译器会将 OC 代码转换成运行时代码，在运行时确定数据结构和函数。</p><h4 id="2-通过-Foundation-框架的-NSObject-类定义的方法"><a href="#2-通过-Foundation-框架的-NSObject-类定义的方法" class="headerlink" title="2.通过 Foundation 框架的 NSObject 类定义的方法"></a>2.通过 Foundation 框架的 NSObject 类定义的方法</h4><p>Cocoa 程序中绝大部分类都是 NSObject 类的子类，所以都继承了 NSObject 的行为。(NSProxy 类时个例外，它是个抽象超类)<br>    一些情况下，NSObject 类仅仅定义了完成某件事情的模板，并没有提供所需要的代码。例如 - description方法，该方法返回类内容的字符串表示，该方法主要用来调试程序。NSObject类并不知道子类的内容，所以它只是返回类的名字和对象的地址，NSObject的子类可以重新实现。<br>    还有一些NSObject的方法可以从Runtime系统中获取信息，允许对象进行自我检查。例如：</p><ul><li><em>class方法返回对象的类；</em></li><li><em>isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类和是否是当前类的成员变量)；</em></li><li><em>respondsToSelector: 检查对象能否响应指定的消息；</em></li><li><em>conformsToProtocol:检查对象是否实现了指定协议类的方法；</em></li><li><em>methodForSelector: 返回指定方法实现的地址。</em></li></ul><h4 id="3-通过对-Runtime-库函数的直接调用"><a href="#3-通过对-Runtime-库函数的直接调用" class="headerlink" title="3.通过对 Runtime 库函数的直接调用"></a>3.通过对 Runtime 库函数的直接调用</h4><p>Runtime 系统是具有公共接口的动态共享库。头文件存放于/usr/include/objc目录下，这意味着我们使用时只需要引入objc/Runtime.h头文件即可。<br>    许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，你在写 Objc 代码时一般不会用到这些 C 语言函数。<br>Runtime的相关术语</p><h5 id="1-SEL"><a href="#1-SEL" class="headerlink" title="1). SEL"></a>1). SEL</h5><p>它是selector在 Objc 中的表示(Swift 中是 Selector 类)。selector 是方法选择器，其实作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，<strong>注意 Objc 在相同的类中不会有命名相同的两个方法。</strong> selector 对方法名进行包装，以便找到对应的方法实现。它的数据结构是：<br><code>typedef struct objc_selector *SEL;</code><br>我们可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器器命令@selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。<br>注意：不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。</p><h5 id="2-id"><a href="#2-id" class="headerlink" title="2). id"></a>2). id</h5><p>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_object *<span class="hljs-keyword">id</span>;<br><span class="hljs-keyword">struct</span> objc_object &#123;<br>      Class isa;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上定义，看到 objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。</br><br><strong>注意：isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型还是需要用对象的 -class 方法。PS:KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型。</strong></p><h5 id="3-Class"><a href="#3-Class" class="headerlink" title="3). Class"></a>3). Class</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_class *Class;<br></code></pre></td></tr></table></figure><p>Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> objc_class &#123;<br>    Class isa  OBJC_ISA_AVAILABILITY;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !__OBJC2__</span><br>    Class super_class                                        OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name                                         OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> version                                             OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> info                                                OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125; OBJC2_UNAVAILABLE;<br></code></pre></td></tr></table></figure><p>从 objc_class 可以看到，一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。</p><p>其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 成员变量列表</span><br><span class="hljs-keyword">struct</span> objc_ivar_list &#123;<br>    <span class="hljs-keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __LP64__</span><br>    <span class="hljs-keyword">int</span> space                                                OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">/* variable length structure */</span><br>    <span class="hljs-keyword">struct</span> objc_ivar ivar_list[<span class="hljs-number">1</span>]                            OBJC2_UNAVAILABLE;<br>&#125;                                                            OBJC2_UNAVAILABLE;<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 方法列表</span><br><span class="hljs-keyword">struct</span> objc_method_list &#123;<br>    <span class="hljs-keyword">struct</span> objc_method_list *obsolete                        OBJC2_UNAVAILABLE;<br><br>    <span class="hljs-keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __LP64__</span><br>    <span class="hljs-keyword">int</span> space                                                OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">/* variable length structure */</span><br>    <span class="hljs-keyword">struct</span> objc_method method_list[<span class="hljs-number">1</span>]                        OBJC2_UNAVAILABLE;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可见，我们可以动态修改 *methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。</p><p>objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。</p><p>值得注意的时，objc_class 中也有一个 isa 指针，这说明 Objc 类本身也是一个对象。为了处理类和对象的关系，Runtime 库创建了一种叫做 Meta Class(元类) 的东西，类对象所属的类就叫做元类。Meta Class 表述了类对象本身所具备的元数据。</p><p>我们所熟悉的类方法，就源自于 Meta Class。我们可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。</p><p>当你发出一个类似 <a href="%E7%B1%BB%E6%96%B9%E6%B3%95">NSObject alloc</a> 的消息时，实际上，这个消息被发送给了一个类对象(Class Object)，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类(Root Meta Class)的实例。所有元类的 isa 指针最终都指向根元类。</p><p>所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。</p><p>最后 objc_class 中还有一个 objc_cache ，缓存，它的作用很重要，后面会提到。</p><h5 id="4-Method"><a href="#4-Method" class="headerlink" title="4). Method"></a>4). Method</h5><p>Method 代表类中某个方法的类型</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_method *Method;<br><span class="hljs-keyword">struct</span> objc_method &#123;<br>    SEL method_name                                          OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">char</span> *method_types                                       OBJC2_UNAVAILABLE;<br>    IMP method_imp                                           OBJC2_UNAVAILABLE;<br>&#125;<br></code></pre></td></tr></table></figure><p>objc_method 存储了方法名，方法类型和方法实现：</p><p>方法名类型为 SEL<br>方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型<br>method_imp 指向了方法的实现，本质是一个函数指针<br>Ivar<br>Ivar 是表示成员变量的类型。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_ivar *Ivar;<br><span class="hljs-keyword">struct</span> objc_ivar &#123;<br>    <span class="hljs-keyword">char</span> *ivar_name                                          OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">char</span> *ivar_type                                          OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __LP64__</span><br>    <span class="hljs-keyword">int</span> space                                                OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 ivar_offset 是基地址偏移字节</p><h5 id="5-IMP"><a href="#5-IMP" class="headerlink" title="5). IMP"></a>5). IMP</h5><p>IMP在objc.h中的定义是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">id</span> (*IMP)(<span class="hljs-keyword">id</span>, SEL, ...);<br></code></pre></td></tr></table></figure><p>它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。</p><p>如果得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。</p><p>你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id和 SEL 参数就能确定唯一的方法实现地址。</p><p>而一个确定的方法也只有唯一的一组 id 和 SEL 参数。</p><h5 id="6-Cache"><a href="#6-Cache" class="headerlink" title="6). Cache"></a>6). Cache</h5><p>Cache 定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_cache *Cache<br><span class="hljs-keyword">struct</span> objc_cache &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask <span class="hljs-comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;<br>    Method buckets[<span class="hljs-number">1</span>]                                        OBJC2_UNAVAILABLE;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Cache 为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在 Cache 中查找。</p><p>Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。</p><h5 id="7-Property"><a href="#7-Property" class="headerlink" title="7). Property"></a>7). Property</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_property *Property;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_property *objc_property_t;<span class="hljs-comment">//这个更常用</span><br></code></pre></td></tr></table></figure><p>可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">objc_property_t *class_copyPropertyList(Class cls, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *outCount)<br>objc_property_t *protocol_copyPropertyList(Protocol *proto, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *outCount)<br></code></pre></td></tr></table></figure><p>注意：<br>返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-comment">/** 姓名 */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-comment">/** age */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">int</span> age;<br><span class="hljs-comment">/** weight */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">double</span> weight;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>以上是一个 Person 类，有3个属性。让我们用上述方法获取类的运行时属性。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> outCount = <span class="hljs-number">0</span>;<br><br>objc_property_t *properties = class_copyPropertyList([Person <span class="hljs-keyword">class</span>], &amp;outCount);<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d&quot;</span>, outCount);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; outCount; i++) &#123;<br>  <span class="hljs-built_in">NSString</span> *name = @(property_getName(properties[i]));<br>  <span class="hljs-built_in">NSString</span> *attributes = @(property_getAttributes(properties[i]));<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@--------%@&quot;</span>, name, attributes);<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">test[<span class="hljs-number">2321</span>:<span class="hljs-number">451525</span>] <span class="hljs-number">3</span><br>test[<span class="hljs-number">2321</span>:<span class="hljs-number">451525</span>] name--------T<span class="hljs-string">@&quot;NSString&quot;</span>,&amp;,N,V_name<br>test[<span class="hljs-number">2321</span>:<span class="hljs-number">451525</span>] age--------Ti,N,V_age<br>test[<span class="hljs-number">2321</span>:<span class="hljs-number">451525</span>] weight--------Td,N,V_weight<br></code></pre></td></tr></table></figure><p>property_getName 用来查找属性的名称，返回 c 字符串。property_getAttributes 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">objc_property_t class_getProperty(Class cls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)<br>objc_property_t protocol_getProperty(Protocol *proto, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-built_in">BOOL</span> isRequiredProperty, <span class="hljs-built_in">BOOL</span> isInstanceProperty)<br></code></pre></td></tr></table></figure><p>class_getProperty 和 protocol_getProperty 通过给出属性名在类和协议中获得属性的引用。<br>Runtime与消息</p><p>一些 Runtime 术语讲完了，接下来就要说到消息了。体会苹果官方文档中的 messages aren’t bound to method implementations until Runtime。消息直到运行时才会与方法实现进行绑定。<br>这里要清楚一点，objc_msgSend 方法看清来好像返回了数据，其实objc_msgSend 从不返回数据，而是你的方法在运行时实现被调用后才会返回数据。下面详细叙述消息发送的步骤：</p><p>首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。<br>检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。<br>如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。<br>如果 cache 找不到就找类的方法列表中是否有对应的方法。<br>如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。<br>如果还找不到，就要开始进入动态方法解析了，后面会提到。<br>在消息的传递中，编译器会根据情况在</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">objc_msgSend ， objc_msgSend_stret ， objc_msgSendSuper ， objc_msgSendSuper_stret ```<br>这四个方法中选择一个调用。如果消息是传递给父类，那么会调用名字带有 Super 的函数，如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数。<br>方法中的隐藏参数<br><br>**疑问：**<br>我们经常用到关键字 <span class="hljs-keyword">self</span> ，但是 <span class="hljs-keyword">self</span> 是如何获取当前方法的对象呢？<br>其实，这也是 Runtime 系统的作用，<span class="hljs-keyword">self</span> 实在方法运行时被动态传入的。<br><br>当 objc_msgSend 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数：<br><br>接受消息的对象(<span class="hljs-keyword">self</span> 所指向的内容，当前方法的对象指针)<br>方法选择器(_cmd 指向的内容，当前方法的 SEL 指针)<br>因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们时在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。<br><br>这两个参数中， <span class="hljs-keyword">self</span>更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。<br><br>这时我们可能会想到另一个关键字 <span class="hljs-keyword">super</span> ，实际上 <span class="hljs-keyword">super</span> 关键字接收到消息时，编译器会创建一个 objc_super 结构体：<br><br>```objectivec<br><span class="hljs-keyword">struct</span> objc_super &#123; <span class="hljs-keyword">id</span> receiver; Class <span class="hljs-keyword">class</span>; &#125;;]<br></code></pre></td></tr></table></figure><p>这个结构体指明了消息应该被传递给特定的父类。 receiver 仍然是 self 本身，当我们想通过 [super class] 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 objc_msgSendSuper 函数。只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 object_getClass()， 接着底层编译器将代码转换为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向 self 的 id 指针，与调用 [self class] 相同，所以我们得到的永远都是 self 的类型。因此你会发现：</p><p>// 这句话并不能获取父类的类型，只能获取当前类的类型名<br>NSLog(@”%@”, NSStringFromClass([super class]));<br>获取方法地址<br>NSObject 类中有一个实例方法：methodForSelector，你可以用它来获取某个方法选择器对应的 IMP ，举个例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">void</span> (*<span class="hljs-keyword">setter</span>)(<span class="hljs-keyword">id</span>, SEL, <span class="hljs-built_in">BOOL</span>);<br><span class="hljs-keyword">int</span> i;<br><br><span class="hljs-keyword">setter</span> = (<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">id</span>, SEL, <span class="hljs-built_in">BOOL</span>))[target<br>    methodForSelector:<span class="hljs-keyword">@selector</span>(setFilled:)];<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span> ; i++ )<br>    <span class="hljs-keyword">setter</span>(targetList[i], <span class="hljs-keyword">@selector</span>(setFilled:), <span class="hljs-literal">YES</span>);<br></code></pre></td></tr></table></figure><p>当方法被当做函数调用时，两个隐藏参数也必须明确给出，上面的例子调用了1000次函数，你也可以尝试给 target 发送1000次 setFilled: 消息会花多久。</p><p>虽然可以更高效的调用方法，但是这种做法很少用，除非时需要持续大量重复调用某个方法的情况，才会选择使用以免消息发送泛滥。</p><p>注意：<br>methodForSelector:方法是由 Runtime 系统提供的，而不是 Objc 自身的特性<br>动态方法解析<br>你可以动态提供一个方法实现。如果我们使用关键字 @dynamic 在类的实现文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认为我们生成这个属性的 setter 和 getter 方法了，需要我们自己提供。</p><p>@dynamic propertyName;<br>这时，我们可以通过分别重载 resolveInstanceMethod: 和 resolveClassMethod: 方法添加实例方法实现和类方法实现。</p><p>当 Runtime 系统在 Cache 和类的方法列表(包括父类)中找不到要执行的方法时，Runtime 会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给我们一次动态添加方法实现的机会。我们需要用 class_addMethod 函数完成向特定类添加特定方法实现的操作：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">void</span> dynamicMethodIMP(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>, SEL _cmd) &#123;<br>    <span class="hljs-comment">// implementation ....</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span></span><br>+ (<span class="hljs-built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL &#123;<br>    <span class="hljs-keyword">if</span> (aSEL == <span class="hljs-keyword">@selector</span>(resolveThisMethodDynamically)) &#123;<br>          class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="hljs-string">&quot;v@:&quot;</span>);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> resolveInstanceMethod:aSEL];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>上面的例子为 resolveThisMethodDynamically 方法添加了实现内容，就是 dynamicMethodIMP 方法中的代码。其中 “v@:” 表示返回值和参数，这个符号表示的含义见：Type Encoding</p><p>注意：<br>动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让该方法选择器被传送到转发机制，就让 resolveInstanceMethod: 方法返回 NO。<br>消息转发</p><h5 id="1-重定向"><a href="#1-重定向" class="headerlink" title="1.重定向"></a>1.重定向</h5><p>消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;<br>    <span class="hljs-keyword">if</span>(aSelector == <span class="hljs-keyword">@selector</span>(mysteriousMethod:))&#123;<br>        <span class="hljs-keyword">return</span> alternateObject;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> forwardingTargetForSelector:aSelector];<br>&#125;<br></code></pre></td></tr></table></figure><p>如果此方法返回 nil 或者 self，则会计入消息转发机制(forwardInvocation:)，否则将向返回的对象重新发送消息。</p><h5 id="2-转发"><a href="#2-转发" class="headerlink" title="2.转发"></a>2.转发</h5><p>当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 forwardInvocation: 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation &#123;<br>    <span class="hljs-keyword">if</span> ([someOtherObject respondsToSelector:<br>            [anInvocation selector]])<br>        [anInvocation invokeWithTarget:someOtherObject];<br>    <span class="hljs-keyword">else</span><br>        [<span class="hljs-keyword">super</span> forwardInvocation:anInvocation];<br>&#125;<br></code></pre></td></tr></table></figure><p>唯一参数是个 NSInvocation 类型的对象，该对象封装了原始的消息和消息的参数。我们可以实现 forwardInvocation: 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。</p><p>注意：参数 anInvocation 是从哪来的？<br>在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。<br>当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 forwardInvocation: 消息通知该对象。每个对象都继承了 forwardInvocation: 方法。但是， NSObject 中的方法实现只是简单的调用了 doesNotRecognizeSelector:。通过实现自己的 forwardInvocation: 方法，我们可以将消息转发给其他对象。</p><p>forwardInvocation: 方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的“吃掉”某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。</p><p>注意：<br>forwardInvocation:方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果我们向往一个对象将一个消息转发给其他对象时，要确保这个对象不能有该消息的所对应的方法。否则，forwardInvocation:将不可能被调用。<br>转发和多继承<br>转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者“继承”过来一样。</p><p>这使得在不同继承体系分支下的两个类可以实现“继承”对方的方法，在上图中 Warrior 和 Diplomat 没有继承关系，但是 Warrior 将 negotiate 消息转发给了 Diplomat 后，就好似 Diplomat 是 Warrior 的超类一样。</p><p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。<br>转发与继承</p><p>虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑继承体系，不会考虑转发链。</p><p> Warrior 对象被问到是否能响应 negotiate消息：</p><p>if ( [aWarrior respondsToSelector:@selector(negotiate)] )<br>    …<br>回答当然是 NO， 尽管它能接受 negotiate 消息而不报错，因为它靠转发消息给 Diplomat 类响应消息。</p><p>如果你就是想要让别人以为 Warrior 继承到了 Diplomat 的 negotiate 方法，你得重新实现 respondsToSelector: 和 isKindOfClass: 来加入你的转发算法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">BOOL</span>)respondsToSelector:(SEL)aSelector &#123;<br>    <span class="hljs-keyword">if</span> ( [<span class="hljs-keyword">super</span> respondsToSelector:aSelector] ) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Here, test whether the aSelector message can     *</span><br><span class="hljs-comment">         * be forwarded to another object and whether that  *</span><br><span class="hljs-comment">         * object can respond to it. Return YES if it can.  */</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了 respondsToSelector: 和 isKindOfClass: 之外，instancesRespondToSelector: 中也应该写一份转发算法。如果使用了协议，conformsToProtocol: 同样也要加入到这一行列中。</p><p>如果一个对象想要转发它接受的任何远程消息，它得给出一个方法标签来返回准确的方法描述 methodSignatureForSelector:，这个方法会最终响应被转发的消息。从而生成一个确定的 NSInvocation 对象描述消息和消息参数。这个方法最终响应被转发的消息。它需要像下面这样实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSMethodSignature</span>*)methodSignatureForSelector:(SEL)selector &#123;<br>    <span class="hljs-built_in">NSMethodSignature</span>* signature = [<span class="hljs-keyword">super</span> methodSignatureForSelector:selector];<br>    <span class="hljs-keyword">if</span> (!signature) &#123;<br>       signature = [surrogate methodSignatureForSelector:selector];<br>    &#125;<br>    <span class="hljs-keyword">return</span> signature;<br>&#125;<br></code></pre></td></tr></table></figure><p>健壮的实例变量(Non Fragile ivars)</p><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量了。当一个类被编译时，实例变量的内存布局就形成了，它表明访问类的实例变量的位置。实例变量一次根据自己所占空间而产生位移：</p><p>上图左是 NSObject 类的实例变量布局。右边是我们写的类的布局。这样子有一个很大的缺陷，就是缺乏拓展性。哪天苹果更新了 NSObject 类的话，就会出现问题：</p><p>我们自定义的类的区域和父类的区域重叠了。只有苹果将父类改为以前的布局才能拯救我们，但这样导致它们不能再拓展它们的框架了，因为成员变量布局被固定住了。在脆弱的实例变量(Fragile ivar)环境下，需要我们重新编译继承自 Apple 的类来恢复兼容。如果是健壮的实例变量的话，如下图：</p><p>在健壮的实例变量下，编译器生成的实例变量布局跟以前一样，但是当 Runtime 系统检测到与父类有部分重叠时它会调整你新添加的实例变量的位移，那样你再子类中新添加的成员变量就被保护起来了。</p><p>注意：<br>在健壮的实例变量下，不要使用 siof(SomeClass)，而是用 class_getInstanceSize([SomeClass class]) 代替；也不要使用  offsetof(SomeClass, SomeIvar)，而要使用 ivar_getOffset(class_getInstanceVariable([SomeClass class], “SomeIvar”)) 来代替。<br>总结<br>我们让自己的类继承自 NSObject 不仅仅是因为基类有很多复杂的内存分配问题，更是因为这使得我们可以享受到 Runtime 系统带来的便利。</p><p>虽然平时我们很少会考虑一句简单的调用方法，发送消息底层所做的复杂的操作，但深入理解 Runtime 系统的细节使得我们可以利用消息机制写出功能更强大的代码。<br>runtime实现的机制是什么,怎么用，一般用于干嘛. 你还能记得你所使用的相关的头文件或者某些方法的名称吗？</p><p>需要导入&lt;objc/message.h&gt;&lt;objc/runtime.h&gt;<br>runtime，运行时机制，它是一套C语言库<br>实际上我们编写的所有OC代码，最终都是转成了runtime库的东西，比如类转成了runtime库里面的结构体等数据类型，方法转成了runtime库里面的C语言函数，平时调方法都是转成了objc_msgSend函数（所以说OC有个消息发送机制）<br>因此，可以说runtime是OC的底层实现，是OC的幕后执行者<br>有了runtime库，能做什么事情呢？runtime库里面包含了跟类、成员变量、方法相关的API，比如获取类里面的所有成员变量，为类动态添加成员变量，动态改变类的方法实现，为类动态添加新的方法等<br>因此，有了runtime，想怎么改就怎么改<br>Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？</p><p>这题目主要考察的是runtime如何交换方法。先在分类中添加一个方法,注意不能重写系统方法,会覆盖</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+(<span class="hljs-built_in">NSString</span> *)myLog &#123;<br><br>  <span class="hljs-comment">// 这里写打印行号,什么方法,哪个类调用等等</span><br><br>&#125;<br><br><span class="hljs-comment">// 加载分类到内存的时候调用</span><br>+(<span class="hljs-keyword">void</span>)load &#123;<br>  <span class="hljs-comment">// 获取imageWithName方法地址</span><br>  Method description = class_getClassMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(description));<br><br>  <span class="hljs-comment">// 获取imageWithName方法地址</span><br>  Method myLog = class_getClassMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(myLog));<br><br>  <span class="hljs-comment">// 交换方法地址，相当于交换实现方式</span><br>  method_exchangeImplementations(description, myLog);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-如何让-Category-支持属性？"><a href="#3-如何让-Category-支持属性？" class="headerlink" title="3.如何让 Category 支持属性？"></a>3.如何让 Category 支持属性？</h5><h6 id="1-使用runtime可以实现"><a href="#1-使用runtime可以实现" class="headerlink" title="1).使用runtime可以实现"></a>1).使用runtime可以实现</h6><p>头文件</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">test</span>)</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><br><span class="hljs-keyword">@end</span><br><br>.m文件<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">test</span>)</span><br><br><span class="hljs-comment">// 定义关联的key</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key = <span class="hljs-string">&quot;name&quot;</span>;<br><br>-(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-comment">// 根据关联的key，获取关联的值。</span><br><br>   <span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, key);<br><br>&#125;<br><br>-(<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>  <span class="hljs-comment">// 第一个参数：给哪个对象添加关联</span><br>  <span class="hljs-comment">// 第二个参数：关联的key，通过这个key获取</span><br>  <span class="hljs-comment">// 第三个参数：关联的value</span><br>  <span class="hljs-comment">// 第四个参数:关联的策略</span><br>  objc_setAssociatedObject(<span class="hljs-keyword">self</span>, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>&#125;<br></code></pre></td></tr></table></figure><p>Toll-Free Bridging 是什么？什么情况下会使用？</p><p>Toll-Free Bridging用于在Foundation对象与Core Foundation对象之间交换数据,俗称桥接</p><p>在ARC环境下,Foundation对象转成 Core Foundation对象</p><ul><li>使用__bridge桥接以后ARC会自动管理2个对象</li><li>使用__bridge_retained桥接需要手动释放Core Foundation对象</li><li>在ARC环境下, Core Foundation对象转成 Foundation对象</li><li>使用__bridge桥接,如果Core Foundation对象被释放,Foundation对象也同时不能使用了,需要手动管理Core Foundation对象</li><li>使用__bridge_transfer桥接,系统会自动管理2个对象<br>performSelector:withObject:afterDelay: 内部大概是怎么实现的，有什么注意事项么？</li></ul><p>创建一个定时器,时间结束后系统会使用runtime通过方法名称(Selector本质就是方法名称)去方法列表中找到对应的方法实现并调用方法<br>注意事项<br>调用performSelector:withObject:afterDelay:方法时,先判断希望调用的方法是否存在respondsToSelector:<br>这个方法是异步方法,必须在主线程调用,在子线程调用永远不会调用到想调用的方法<br>什么是 Method Swizzle（黑魔法），什么情况下会使用？</p><p>在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法Method Swizzle。<br>Method swizzling指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变——通过改变类的调度表（dispatch table）中选择器到最终函数间的映射关系。<br>在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。<br>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。<br>我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP，<br>我们可以利用 class_replaceMethod 来修改类，<br>我们可以利用 method_setImplementation 来直接设置某个方法的IMP，<br>归根结底，都是偷换了selector的IMP<br>能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</p><ul><li>不能向编译后得到的类中增加实例变量；</li><li>能向运行时创建的类中添加实例变量；</li></ul><p>解释如下：<br>因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；<br>运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。<br>为什么其他语言里叫函数调用， objective c里则是给对象发消息（或者谈下对runtime的理解）</p><p>先来看看怎么理解发送消息的含义：<br>[receiver message]会被编译器转化为：<br>objc_msgSend(receiver, selector)<br>如果消息含有参数，则为：<br>objc_msgSend(receiver, selector, arg1, arg2, …)<br>如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。<br>现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送message这条消息，而receive将要如何响应这条消息，那就要看运行时发生的情况来决定了。<br>OC 的 Runtime 铸就了它动态语言的特性，Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。可以使用runtime的一系列方法实现。<br>顺便附上OC中一个类的数据结构 /usr/include/objc/runtime.h<br>struct objc_class {    </p><p>Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object     </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"> <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !__OBJC2__    </span><br>     Class super_class<br>OBJC2_UNAVAILABLE; <span class="hljs-comment">// 父类</span><br>     <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name<br>OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类名     </span><br>     <span class="hljs-keyword">long</span> version<br>OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类的版本信息，默认为0     </span><br>     <span class="hljs-keyword">long</span> info<br>OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类信息，供运行期使用的一些位标识     </span><br>     <span class="hljs-keyword">long</span> instance_size<br>OBJC2_UNAVAILABLE; <span class="hljs-comment">// 该类的实例变量大小     </span><br>     <span class="hljs-keyword">struct</span> objc_ivar_list *ivars<br>OBJC2_UNAVAILABLE; <span class="hljs-comment">// 该类的成员变量链表     </span><br>     <span class="hljs-keyword">struct</span> objc_method_list **methodLists<br>OBJC2_UNAVAILABLE; <span class="hljs-comment">// 方法定义的链表     </span><br>     <span class="hljs-keyword">struct</span> objc_cache *cache<br>OBJC2_UNAVAILABLE; <span class="hljs-comment">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method       Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。     </span><br>    <span class="hljs-keyword">struct</span> objc_protocol_list *protocols<br>OBJC2_UNAVAILABLE; <span class="hljs-comment">// 协议链表     </span><br> <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>&#125; OBJC2_UNAVAILABLE;<br>OC中一个类的对象实例的数据结构（/usr/include/objc/objc.h）:<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_class *Class;      <span class="hljs-comment">/// Represents an instance of a class.      struct objc_object &#123;          </span><br>    Class isa  <br>OBJC_ISA_AVAILABILITY;      <br>&#125;;      <span class="hljs-comment">/// A pointer to an instance of a class.      </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_object *<span class="hljs-keyword">id</span>;<br></code></pre></td></tr></table></figure><p>向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。<br>然后再来看看消息发送的函数：objc_msgSend函数<br>在引言中已经对objc_msgSend进行了一点介绍，看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：<br>检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain,release 这些函数了。<br>检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。<br>如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。<br>如果 cache 找不到就找一下方法分发表。<br>如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。<br>如果还找不到就要开始进入动态方法解析了，后面会提到。<br>后面还有：<br>动态方法解析resolveThisMethodDynamically<br>消息转发forwardingTargetForSelector<br>runtime如何实现weak属性？</p><h6 id="2-通过关联属性来实现："><a href="#2-通过关联属性来实现：" class="headerlink" title="2).通过关联属性来实现："></a>2).通过关联属性来实现：</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 声明一个weak属性，这里假设delegate，其实weak关键字可以不使用，</span><br><span class="hljs-comment">// 因为我们重写了getter/setter方法</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-keyword">id</span> delegate;<br>- (<span class="hljs-keyword">id</span>)delegate &#123;<br>  <span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-string">@&quot;__delegate__key&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 指定使用OBJC_ASSOCIATION_ASSIGN，官方注释是：</span><br><span class="hljs-comment">// Specifies a weak reference to the associated object.</span><br><span class="hljs-comment">// 也就是说对于对象类型，就是weak了</span><br>- (<span class="hljs-keyword">void</span>)setDelegate:(<span class="hljs-keyword">id</span>)delegate &#123;<br>  objc_setAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-string">@&quot;__delegate__key&quot;</span>, delegate, OBJC_ASSOCIATION_ASSIGN);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-通过objc-storeWeak函数来实现，不过这种方式几乎没有遇到有人这么使用过，因为这里不细说了。"><a href="#3-通过objc-storeWeak函数来实现，不过这种方式几乎没有遇到有人这么使用过，因为这里不细说了。" class="headerlink" title="3).通过objc_storeWeak函数来实现，不过这种方式几乎没有遇到有人这么使用过，因为这里不细说了。"></a>3).通过objc_storeWeak函数来实现，不过这种方式几乎没有遇到有人这么使用过，因为这里不细说了。</h6><h5 id="4-runtime如何通过selector找到对应的IMP地址？"><a href="#4-runtime如何通过selector找到对应的IMP地址？" class="headerlink" title="4.runtime如何通过selector找到对应的IMP地址？"></a>4.runtime如何通过selector找到对应的IMP地址？</h5><p>每个selector都与对应的IMP是一一对应的关系，通过selector就可以直接找到对应的IMP：<br>objc_msgForward函数是做什么的，直接调用它将会发生什么？</p><p>_objc_msgForward是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。<br>IMP msgForward =  _objc_msgForward;<br>如果手动调用objcmsgForward，将跳过查找IMP的过程，而是直接触发“消息转发”，进入如下流程：</p><p>•    第一步：+ (BOOL)resolveInstanceMethod:(SEL)sel实现方法，指定是否动态添加方法。若返回NO，则进入下一步，若返回YES，则通过class_addMethod函数动态地添加方法，消息得到处理，此流程完毕。</p><p>•    第二步：在第一步返回的是NO时，就会进入- (id)forwardingTargetForSelector:(SEL)aSelector方法，这是运行时给我们的第二次机会，用于指定哪个对象响应这个selector。不能指定为self。若返回nil，表示没有响应者，则会进入第三步。若返回某个对象，则会调用该对象的方法。</p><p>•    第三步：若第二步返回的是nil，则我们首先要通过- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector指定方法签名，若返回nil，则表示不处理。若返回方法签名，则会进入下一步。</p><p>•    第四步：当第三步返回方法方法签名后，就会调用- (void)forwardInvocation:(NSInvocation *)anInvocation方法，我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等</p><p>•    第五步：若没有实现- (void)forwardInvocation:(NSInvocation *)anInvocation方法，那么会进入- (void)doesNotRecognizeSelector:(SEL)aSelector方法。若我们没有实现这个方法，那么就会crash，然后提示打不到响应的方法。到此，动态解析的流程就结束了。<br>runtime如何实现weak变量的自动置nil？</p><p>runtime对注册的类会进行布局，对于weak对象会放入一个hash表中。 用weak指向的对象内存地址作为key，当此对象的引用计数为0的时候会dealloc。假如weak指向的对象内存地址是a，那么就会以a为键，在这个 weak 表中搜索，找到所有以a为键的weak对象，从而设置为nil。<br>weak修饰的指针默认值是nil（在Objective-C中向nil发送消息是安全的）<br>动态绑定</p><p>在运行时确定要调用的方法,动态绑定将调用方法的确定也推迟到运行时。在编译时，方法的调用并不和代码绑定在一起，只有在消实发送出来之后，才确定被调用的代码。通过动态类型和动态绑定技术，代码每次执行都可以得到不同的结果。运行时因子负责确定消息的接收者和被调用的方法。运行时的消息分发机制为动态绑定提供支持。当向一个动态类型确定了的对象发送消息时，运行环境系统会通过接收者的isa指针定位对象的类，并以此为起点确定被调用的方法，方法和消息是动态绑定的。而且，不必在Objective-C 代码中做任何工作，就可以自动获取动态绑定的好处。在每次发送消息时，特别是当消息的接收者是动态类型已经确定的对象时，动态绑定就会例行而透明地发生</p><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#57;&#57;&#x34;&#x40;&#x31;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;">&#95;&#49;&#57;&#57;&#x34;&#x40;&#x31;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>Runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Runtime基础（一）</title>
    <link href="/post/20f2ery1.html"/>
    <url>/post/20f2ery1.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h3 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h3><p>RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。<br>对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。<br>OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。<br>只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。</p><span id="more"></span><p>Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是：</p><ul><li>1、通过 Objective-C 源代码；</li><li>2、通过 Foundation 框架的NSObject类定义的方法；</li><li>3、通过对 runtime 函数的直接调用。<br>大部分情况下你就只管写你的objectivec代码就行，runtime 系统自动在幕后辛勤劳作着。<!-- more --><h3 id="二、runtime的具体实现"><a href="#二、runtime的具体实现" class="headerlink" title="二、runtime的具体实现"></a>二、runtime的具体实现</h3>我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。每一个oc的方法，底层必然有一个与之对应的runtime方法。<img src="https://i.loli.net/2019/08/21/yZW6DM2HdIEUAK3.png" alt="image.png"></li></ul><p>当我们用OC写下这样一段代码<br><code>[tableView cellForRowAtIndexPath:indexPath];</code><br>在编译时RunTime会将上述代码转化成[发送消息]<br><code>objectivec_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath);</code></p><h3 id="三、常见方法"><a href="#三、常见方法" class="headerlink" title="三、常见方法"></a>三、常见方法</h3><h4 id="1、获取属性列表"><a href="#1、获取属性列表" class="headerlink" title="1、获取属性列表"></a>1、获取属性列表</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//People.h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSUInteger</span> age;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//People.m</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span>() </span>&#123;<br>    <span class="hljs-built_in">NSString</span> *aaa;<br>&#125;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *fatherName;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">People</span> </span>&#123;<br>    <span class="hljs-built_in">NSString</span> *bbb;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//获取所有属性</span><br>-(<span class="hljs-keyword">void</span>)getAllProperty &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    objectivec_property_t *propertyList = class_copyPropertyList([People <span class="hljs-keyword">class</span>], &amp;count);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;count; i++) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *propertyName = property_getName(propertyList[i]);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;property----&gt;%@&quot;</span>, [<span class="hljs-built_in">NSString</span> stringWithUTF8String:propertyName]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>打印结果：</strong></p><p><img src="https://i.loli.net/2019/08/21/neDMvfJCUkmg9Wq.png" alt="image.png"></p><p><strong>结论：</strong></p><ul><li>1）、不管是在.h文件中定义的属性还是在.m文件中定义的属性，都可以通过获取属性列表方法来进行获取；</li><li>2）、成员变量不同于属性，不能通过该方法来获取;</li><li>3）、先输出的是.m文件中的属性，然后才是.h文件中的属性，并且是按照属性定义的先后顺序来保存。</li></ul><h4 id="2、获取方法列表"><a href="#2、获取方法列表" class="headerlink" title="2、获取方法列表"></a>2、获取方法列表</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//People.h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *name;<br><br>-(<span class="hljs-keyword">void</span>)iPrintName;<br>+(<span class="hljs-keyword">void</span>)cPrintName;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//People.m</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span>() </span>&#123;<br>    <span class="hljs-built_in">NSString</span> *aaa;<br>&#125;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *fatherName;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">People</span> </span>&#123;<br>    <span class="hljs-built_in">NSString</span> *bbb;<br>&#125;<br><br><span class="hljs-comment">//-(void)printName &#123;</span><br><span class="hljs-comment">//    </span><br><span class="hljs-comment">//&#125;</span><br><br>+(<span class="hljs-keyword">void</span>)cPrintName &#123;<br><br>&#125;<br><br>-(<span class="hljs-keyword">void</span>)printAge &#123;<br><br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//获取方法（不包括类方法）列表</span><br>-(<span class="hljs-keyword">void</span>)getAllMethod &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    Method *methodList = class_copyMethodList([People <span class="hljs-keyword">class</span>], &amp;count);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;count; i++) &#123;<br>        Method method = methodList[i];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;method----&gt;%@&quot;</span>, <span class="hljs-built_in">NSStringFromSelector</span>(method_getName(method)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/08/21/TQiIh1t9cKwXDnJ.png" alt="image.png"></p><p><strong>结论：</strong></p><ul><li>1）、类方法不能通过这个函数去获取到；</li><li>2）、只有在.m文件中实现了的方法才能被获取到，在.h文件中定义了，但是.m中没有实现的并不能获取到；</li><li>3）、对于使用@property定义的属性，会自动生成setter和getter方法，同样能被这个方法获取到；</li><li>4）、.m实现中还隐藏了一个.cxx_destruct也就是oc中常见delloc方法；</li><li>5）、保存顺序是优先保存用户在.m文件中实现的，其次是.m属性自动生成的getter和setter方法，然后是隐藏的delloc方法，最后是.h属性自动生成的getter和setter方法。</li></ul><h4 id="3、获取成员变量列表"><a href="#3、获取成员变量列表" class="headerlink" title="3、获取成员变量列表"></a>3、获取成员变量列表</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//People.h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span> : <span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-built_in">NSString</span> *cccc;<br>&#125;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *name;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//People.m</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span>() </span>&#123;<br>    <span class="hljs-built_in">NSString</span> *aaa;<br>&#125;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *fatherName;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">People</span> </span>&#123;<br>    <span class="hljs-built_in">NSString</span> *bbb;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">-(void)getAllIvar&#123;<br>    unsigned <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>    Ivar *ivarList = <span class="hljs-keyword">class</span><span class="hljs-constructor">_copyIvarList([People <span class="hljs-params">class</span>], &amp;<span class="hljs-params">count</span>)</span>;<br>    <span class="hljs-keyword">for</span> (unsigned <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;count; i++) &#123;<br>        Ivar myIvar = ivarList<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>        const <span class="hljs-built_in">char</span> *ivarName = ivar<span class="hljs-constructor">_getName(<span class="hljs-params">myIvar</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;Ivar----&gt;%@&quot;</span>, [NSString <span class="hljs-params">stringWithUTF8String</span>:<span class="hljs-params">ivarName</span>])</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>打印结果：</strong><br><img src="https://i.loli.net/2019/08/21/bC6O84Y312oStDj.png" alt="image.png"><br><strong>结论：</strong><br>1）、成员变量的保存是从.h文件开始，然后才是.m文件中的成员变量；<br>2）、用@property 定义的属性，会自动生成以_开头的成员变量，也是先保存.h文件生成的，再保存.m文件生成的。</p><hr><h4 id="4、获取协议列表"><a href="#4、获取协议列表" class="headerlink" title="4、获取协议列表"></a>4、获取协议列表</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//People.h</span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">PeopleDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><br>-(<span class="hljs-keyword">void</span>)people;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-comment">//@property (nonatomic, weak) id &lt;PeopleDelegate&gt; delegate;</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//People.m</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span>()</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *fatherName;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">People</span></span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//ViewController.m</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()&lt;<span class="hljs-title">PeopleDelegate</span>,<span class="hljs-title">UITabBarDelegate</span>,<span class="hljs-title">UITableViewDataSource</span>&gt;</span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    [<span class="hljs-keyword">self</span> getProtocal];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//获取协议列表</span><br>-(<span class="hljs-keyword">void</span>)getProtocal &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    __<span class="hljs-keyword">unsafe_unretained</span> Protocol **protocolList = class_copyProtocolList([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], &amp;count);  <span class="hljs-comment">//这里变成了self</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;count; i++) &#123;<br>        Protocol *myProtocal = protocolList[i];<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *protocolName = protocol_getName(myProtocal);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;protocol----&gt;%@&quot;</span>, [<span class="hljs-built_in">NSString</span> stringWithUTF8String:protocolName]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>打印结果：</strong></p><p><img src="https://i.loli.net/2019/08/21/VUpTAiWzDuFtnm5.png" alt="image.png"></p><p><strong>结论：</strong></p><ul><li>1）、只要声明遵循该协议，在引用的时候，就能获取到该类包含的协议列表，哪怕你没有指定代理的对象，也没有去实现协议的方法</li></ul><h4 id="5、获取类方法与实例方法以及方法交换"><a href="#5、获取类方法与实例方法以及方法交换" class="headerlink" title="5、获取类方法与实例方法以及方法交换"></a>5、获取类方法与实例方法以及方法交换</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//People.h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *name;<br><br>-(<span class="hljs-keyword">void</span>)printInstanceMethod;<br>+(<span class="hljs-keyword">void</span>)printClassMethod;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//People.m</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span>()</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *fatherName;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">People</span></span><br>-(<span class="hljs-keyword">void</span>)printInstanceMethod&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;我是实例方法&quot;</span>);<br>&#125;<br><br>+(<span class="hljs-keyword">void</span>)printClassMethod &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;我是类方法&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">-(<span class="hljs-keyword">void</span>)getMethod &#123;<br><br>    People * p1 = [[People alloc] init];<br><br>    Method m1 = class_getInstanceMethod([p1 <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(printInstanceMethod));<br>    Method m2 = class_getClassMethod([People <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(printClassMethod));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;测试前：&quot;</span>);<br>    [p1 printInstanceMethod];<br>    [People printClassMethod];<br><br>    method_exchangeImplementations(m1, m2);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;测试后：&quot;</span>);<br>    [p1 printInstanceMethod];<br>    [People printClassMethod];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>打印结果</strong></p><p><img src="https://i.loli.net/2019/08/21/8LrYoyXu1sibGAB.png" alt="image.png"></p><h4 id="6、添加方法"><a href="#6、添加方法" class="headerlink" title="6、添加方法"></a>6、添加方法</h4><p>当项目中，需要继承某一个类（subclass），但是父类中并没有提供我需要的调用方法，而我又不清楚父类中某些方法的具体实现；或者，我需要为这个类写一个分类（category），在这个分类中，我可能需要替换/新增某个方法（注意：不推荐在分类中重写方法，而且也无法通过 super 来获取所谓父类的方法）。大致在这两种情况下，我们可以通过 class_addMethod 来实现我们想要的效果。<a href="http://www.jianshu.com/p/390b20a36d83">参考</a></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//Car+MyCar.h</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Car+MyCar.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objectivec/runtime.h&gt;</span></span><br><br><span class="hljs-keyword">void</span> startEngine(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>, SEL _cmd, <span class="hljs-built_in">NSString</span> *brand) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;my %@ car starts the engine&quot;</span>, brand);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Car</span> (<span class="hljs-title">MyCar</span>)</span><br><br>+ (<span class="hljs-built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;<br>    <span class="hljs-keyword">if</span> (sel == <span class="hljs-keyword">@selector</span>(drive)) &#123;<br>        class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], sel, (IMP)startEngine, <span class="hljs-string">&quot;v@:@&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> resolveInstanceMethod:sel];<br>&#125;<br></code></pre></td></tr></table></figure><p>不习惯C语言代码可以替换成以下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"> - (<span class="hljs-keyword">void</span>)startEngine:(<span class="hljs-built_in">NSString</span> *)brand &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;my %@ car starts the engine&quot;</span>, brand);<br> &#125;<br><br> + (<span class="hljs-built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;<br>     <span class="hljs-keyword">if</span> (sel == <span class="hljs-keyword">@selector</span>(drive)) &#123;<br>       class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], sel, class_getMethodImplementation(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(startEngine:)), <span class="hljs-string">&quot;v@:@&quot;</span>);<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>     &#125;<br>     <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> resolveInstanceMethod:sel];<br> &#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">-(<span class="hljs-keyword">void</span>)addMethod &#123;<br>    Car *c = [[Car alloc] init];<br>    [c performSelector:<span class="hljs-keyword">@selector</span>(drive) withObject:<span class="hljs-string">@&quot;BMW&quot;</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure><p>解释：<br>在 Objective-C 中，正常的调用方法是通过消息机制（message）来实现的，那么如果类中没有找到发送的消息方法，系统就会进入找不到该方法的处理流程中，如果在这个流程中，我们加入我们所需要的新方法，就能实现运行过程中的动态添加了。这个流程或者说机制，就是 Objective-C 的 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/objectivecRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1">Message Forwarding</a> 。<br>这个机制中所涉及的方法主要有两个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;<span class="hljs-comment">//实例方法</span><br>+ (<span class="hljs-built_in">BOOL</span>)resolveClassMethod:(SEL)sel;<span class="hljs-comment">//类方法</span><br></code></pre></td></tr></table></figure><p>这个函数在 runtime 环境下，如果没有找到该方法的实现的话就会执行。第一行判断的是传入的 SEL 名称是否匹配，接着调用 class_addMethod 方法，传入相应的参数。其中第三个参数传入的是我们添加的 C 语言函数的实现，也就是说，第三个参数的名称要和添加的具体函数名称一致。第四个参数指的是函数的返回值以及参数内容。</p><p>结果：</p><p><img src="https://i.loli.net/2019/08/21/8LrYoyXu1sibGAB.png" alt="image.png"></p><h3 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h3><p><strong>一开始我以为class_addMethod和class_replaceMethod就等同于method_exchangeImplementations，但是看了下面的代码才发现，其实这俩的适用条件是不一样的，当方法没有实现的时候才能使用class_addMethod和class_replaceMethod套装，但是当方法已存在的时候，就需要使用method_exchangeImplementations，这点从if (didAddMethod)这个判定就可见一斑。</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+(<span class="hljs-keyword">void</span>)load&#123;<br>    <span class="hljs-built_in">NSString</span> *className = <span class="hljs-built_in">NSStringFromClass</span>(<span class="hljs-keyword">self</span>.class);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;classname %@&quot;</span>, className);<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        <span class="hljs-comment">//要特别注意你替换的方法到底是哪个性质的方法</span><br>        <span class="hljs-comment">// When swizzling a Instance method, use the following:</span><br>        <span class="hljs-comment">//        Class class = [self class];</span><br><br>        <span class="hljs-comment">// When swizzling a class method, use the following:</span><br>        Class <span class="hljs-keyword">class</span> = object_getClass((<span class="hljs-keyword">id</span>)<span class="hljs-keyword">self</span>);<br><br>        SEL originalSelector = <span class="hljs-keyword">@selector</span>(systemMethod_PrintLog);<br>        SEL swizzledSelector = <span class="hljs-keyword">@selector</span>(ll_imageName);<br><br>        Method originalMethod = class_getInstanceMethod(<span class="hljs-keyword">class</span>, originalSelector);<br>        Method swizzledMethod = class_getInstanceMethod(<span class="hljs-keyword">class</span>, swizzledSelector);<br><br>        <span class="hljs-built_in">BOOL</span> didAddMethod =<br>        class_addMethod(<span class="hljs-keyword">class</span>,<br>                        originalSelector,<br>                        method_getImplementation(swizzledMethod),<br>                        method_getTypeEncoding(swizzledMethod));<br><br>        <span class="hljs-keyword">if</span> (didAddMethod) &#123;<br>            class_replaceMethod(<span class="hljs-keyword">class</span>,<br>                                swizzledSelector,<br>                                method_getImplementation(originalMethod),<br>                                method_getTypeEncoding(originalMethod));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            method_exchangeImplementations(originalMethod, swizzledMethod);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>Runtime博大精深，看的越深入，感觉越懵 T_T，浅显的认知，欢迎大家提意见</strong></p><p><a href="https://github.com/SuAdrenine/RuntimeDemo">Demo</a></p><hr><p><strong>资料</strong><br><a href="http://gcblog.github.io/2016/04/16/runtime%E8%AF%A6%E8%A7%A3/#more">runtime详解</a><br><a href="http://www.jianshu.com/p/88d11bb12ba1">runtime奇技淫巧系列</a><br><a href="http://www.jianshu.com/p/ab966e8a82e2">OC最实用的runtime总结，面试、工作你看我就足够了！</a></p><h3 id="五、联系方式"><a href="#五、联系方式" class="headerlink" title="五、联系方式"></a>五、联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#x39;&#57;&#x34;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#111;&#109;">&#x5f;&#x31;&#x39;&#57;&#x34;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>Runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode系列目录</title>
    <link href="/post/d305db71.html"/>
    <url>/post/d305db71.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h4 id="nbsp-nbsp-【iOS-Sharing】系列目录"><a href="#nbsp-nbsp-【iOS-Sharing】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS Sharing】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjuia973.html">【iOS Sharing】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS笔记】系列目录"><a href="#nbsp-nbsp-【iOS笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【靠谱程序员】系列目录"><a href="#nbsp-nbsp-【靠谱程序员】系列目录" class="headerlink" title="&nbsp;&nbsp;【靠谱程序员】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS警告与报错】系列目录"><a href="#nbsp-nbsp-【iOS警告与报错】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS警告与报错】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2m9iu6d.html">【iOS警告与报错】系列目录</a></h4><h4 id="nbsp-nbsp-【开发笔记】系列目录"><a href="#nbsp-nbsp-【开发笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【开发笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【Leet-Code】系列目录"><a href="#nbsp-nbsp-【Leet-Code】系列目录" class="headerlink" title="&nbsp;&nbsp;【Leet Code】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/d305db71.html">【Leet Code】系列目录</a></h4><h4 id="nbsp-nbsp-【Coding】系列目录"><a href="#nbsp-nbsp-【Coding】系列目录" class="headerlink" title="&nbsp;&nbsp;【Coding】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ab23a973.html">【Coding】系列目录</a></h4><hr><h3 id="【LeetCode】系列目录"><a href="#【LeetCode】系列目录" class="headerlink" title="【LeetCode】系列目录"></a>【LeetCode】系列目录</h3><h4 id="nbsp-nbsp-【-1】Two-Sum"><a href="#nbsp-nbsp-【-1】Two-Sum" class="headerlink" title="&nbsp;&nbsp;【#1】Two Sum"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/2djk89iu.html">【#1】Two Sum</a></h4><h4 id="nbsp-nbsp-【-2】Add-Two-Numbers"><a href="#nbsp-nbsp-【-2】Add-Two-Numbers" class="headerlink" title="&nbsp;&nbsp;【#2】Add Two Numbers"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/c65eh7y4.html">【#2】Add Two Numbers</a></h4><h4 id="nbsp-nbsp-【-3】Longest-Substring-Without-Repeating-Characters"><a href="#nbsp-nbsp-【-3】Longest-Substring-Without-Repeating-Characters" class="headerlink" title="&nbsp;&nbsp;【#3】Longest Substring Without Repeating Characters"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/8b62jk96.html">【#3】Longest Substring Without Repeating Characters</a></h4><h4 id="nbsp-nbsp-【-4】Midian-of-Two-Sorted-Arrays"><a href="#nbsp-nbsp-【-4】Midian-of-Two-Sorted-Arrays" class="headerlink" title="&nbsp;&nbsp;【#4】Midian of Two Sorted Arrays"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/98g2fd04.html">【#4】Midian of Two Sorted Arrays</a></h4><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#57;&#x34;&#64;&#49;&#x36;&#x33;&#46;&#99;&#111;&#x6d;">&#x5f;&#49;&#x39;&#57;&#x34;&#64;&#49;&#x36;&#x33;&#46;&#99;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Appearance的使用</title>
    <link href="/post/hl6o7p52.html"/>
    <url>/post/hl6o7p52.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><p>iOS 5及其以后提供了一个比较强大的工具UIAppearance，我们通过UIAppearance设置一些UI的全局效果，这样就可以很方便的实现UI的自定义效果又能最简单的实现统一界面风格，但是需要注意使用细则：</p><p><strong>1、控件遵守了UIAppearance协议，才能对控件进行appearance设置<br>2、只有被UI_APPEARANCE_SELECTOR这个宏修饰的属性才能使用appearance进行设置，其他属性则不具备该功能<br>3、appearance设置需要在该控制显示之前设置完成，否则可能无效</strong></p><span id="more"></span><p>它提供如下两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-keyword">id</span>)appearance;<br></code></pre></td></tr></table></figure><p>这个方法是统一全部改，比如你设置UINavigationBar的tintColor，你可以这样写：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[[<span class="hljs-built_in">UINavigationBar</span> appearance] setTintColor:myColor];<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-keyword">id</span>)appearanceWhenContainedIn:(Class &lt;&gt;)ContainerClass,...<br></code></pre></td></tr></table></figure><p>这个方法可设置某个类的改变，例如：<br>设置UIBarButtonItem 在UINavigationBar、UIPopoverController、UITabbar中的效果，就可以这样写：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[[<span class="hljs-built_in">UIBarButtonItem</span> appearanceWhenContainedIn:[<span class="hljs-built_in">UINavigationBar</span> <span class="hljs-keyword">class</span>], [<span class="hljs-built_in">UIPopoverController</span> <span class="hljs-keyword">class</span>], [<span class="hljs-built_in">UITabbar</span> <span class="hljs-keyword">class</span>], <span class="hljs-literal">nil</span>] setTintColor:myColor];<br></code></pre></td></tr></table></figure><p>请注意:<strong>使用appearance设置UI效果最好采用全局的设置，在所有界面初始化前开始设置，否则可能失效。</strong></p><p>具体UI外观修改如下：</p><h3 id="修改导航栏背景"><a href="#修改导航栏背景" class="headerlink" title="修改导航栏背景"></a>修改导航栏背景</h3><p>代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UINavigationBar</span> * appearance = [<span class="hljs-built_in">UINavigationBar</span> appearance];<br><span class="hljs-built_in">UIImage</span> *navBgImg =[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;bgImage&quot;</span>];<br><br>[appearance setBackgroundImage:navBgImg forBarMetrics: <span class="hljs-built_in">UIBarMetricsDefault</span>];<br></code></pre></td></tr></table></figure><hr><h3 id="标签栏（UITabbar）"><a href="#标签栏（UITabbar）" class="headerlink" title="标签栏（UITabbar）"></a>标签栏（UITabbar）</h3><p>代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UITabBar</span> *appearance = [<span class="hljs-built_in">UITabBar</span> appearance];<br><span class="hljs-comment">//设置背景图片</span><br>[appearance setBackgroundImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;bgImage&quot;</span>]];<br><span class="hljs-comment">//设置选择item的背景图片</span><br><span class="hljs-built_in">UIImage</span> * selectedImage =[[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;sliderImage&quot;</span>] resizableImageWithCapInsets:<span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)] ;<br>[appearance setSelectionIndicatorImage:selectedImage];<br></code></pre></td></tr></table></figure><hr><h3 id="分段控件（UISegmentControl）"><a href="#分段控件（UISegmentControl）" class="headerlink" title="分段控件（UISegmentControl）"></a>分段控件（UISegmentControl）</h3><p>代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UISegmentedControl</span> *appearance = [<span class="hljs-built_in">UISegmentedControl</span> appearance];<br><br><span class="hljs-comment">//Segmenteg正常背景</span><br>[appearance setBackgroundImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;image&quot;</span>] forState:<span class="hljs-built_in">UIControlStateNormal</span> barMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];<br><br><span class="hljs-comment">//Segmente选中背景</span><br>[appearance setBackgroundImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;bgImage&quot;</span>] forState:<span class="hljs-built_in">UIControlStateSelected</span> barMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Segmente左右都未选中时的分割线</span><br><span class="hljs-comment">BarMetrics表示navigation bar的状态，UIBarMetricsDefault 表示</span><br><span class="hljs-comment">portrait状态（44pixel height），UIBarMetricsLandscapePhone</span><br><span class="hljs-comment">表示landscape状态（32pixel height</span><br><span class="hljs-comment">*/</span><br><br>[appearance setDividerImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;line&quot;</span>] forLeftSegmentState:<span class="hljs-built_in">UIControlStateNormal</span> rightSegmentState:<span class="hljs-built_in">UIControlStateNormal</span> barMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];<br><br>[appearance setDividerImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;line&quot;</span>] forLeftSegmentState:<span class="hljs-built_in">UIControlStateSelected</span> rightSegmentState:<span class="hljs-built_in">UIControlStateNormal</span> barMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];<br><br>[appearance setDividerImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;line&quot;</span>] forLeftSegmentState:<span class="hljs-built_in">UIControlStateNormal</span> rightSegmentState:<span class="hljs-built_in">UIControlStateSelected</span> barMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];<br><br><span class="hljs-comment">//字体</span><br><span class="hljs-built_in">NSDictionary</span> *textAtt1 = @&#123;<br><span class="hljs-built_in">NSFontAttributeName</span>: [<span class="hljs-built_in">UIFont</span> systemFontOfSize:<span class="hljs-number">18</span>], <span class="hljs-built_in">NSForegroundColorAttributeName</span>: [<span class="hljs-built_in">UIColor</span> blueColor], <span class="hljs-built_in">NSShadowAttributeName</span>: [<span class="hljs-built_in">UIColor</span> whiteColor]&#125;;<br><br>[appearance setTitleTextAttributes:textAtt1 forState:<span class="hljs-number">1</span>];<br><br><span class="hljs-built_in">NSDictionary</span> *textAtt2 = @&#123;<br><span class="hljs-built_in">NSFontAttributeName</span>: [<span class="hljs-built_in">UIFont</span> systemFontOfSize:<span class="hljs-number">18</span>], <span class="hljs-built_in">NSForegroundColorAttributeName</span>: [<span class="hljs-built_in">UIColor</span> blueColor], <span class="hljs-built_in">NSShadowAttributeName</span>: [<span class="hljs-built_in">UIColor</span> whiteColor]&#125;;<br><br>[appearance setTitleTextAttributes:textAtt2 forState:<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><hr><h3 id="UIBarbutton"><a href="#UIBarbutton" class="headerlink" title="UIBarbutton"></a>UIBarbutton</h3><p>注意：<strong>UIBarbutton有leftBarButton，rightBarButton和backBarButton，其中backBarButton由于带有箭头，需要单独设置。barButton背景设置是ios6.0及以后的，而backbutton是ios5.0及以后的，这里要注意！</strong></p><p>代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//修改导航条上的UIBarButtonItem</span><br><span class="hljs-built_in">UIBarButtonItem</span> *appearance = [<span class="hljs-built_in">UIBarButtonItem</span> appearanceWhenContainedIn: [<span class="hljs-built_in">UINavigationBar</span> <span class="hljs-keyword">class</span>], <span class="hljs-literal">nil</span>];<br><br><span class="hljs-comment">//设置导航栏的字体包括backBarButton和leftBarButton，rightBarButton的字体</span><br><span class="hljs-built_in">NSDictionary</span> *textAttributes = @&#123;<br><span class="hljs-built_in">NSFontAttributeName</span>: [<span class="hljs-built_in">UIFont</span> systemFontOfSize:<span class="hljs-number">18</span>], <span class="hljs-built_in">NSForegroundColorAttributeName</span>: [<span class="hljs-built_in">UIColor</span> blueColor], <span class="hljs-built_in">NSShadowAttributeName</span>: [<span class="hljs-built_in">UIColor</span> whiteColor]&#125;;<br><br>[appearance setTitleTextAttributes:textAttributes forState:<span class="hljs-number">1</span>];<br><span class="hljs-comment">//forState为0时为下正常状态，为1时为点击状态。</span><br><br><span class="hljs-comment">//修改leftBarButton，rightBarButton背景效果</span><br>[appearance setBackgroundImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;image&quot;</span>] forState:<span class="hljs-built_in">UIControlStateNormal</span> style:<span class="hljs-built_in">UIBarButtonItemStyleBordered</span> barMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];<br><br>[appearance setBackgroundImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;image&quot;</span>] forState:<span class="hljs-built_in">UIControlStateHighlighted</span> style:<span class="hljs-built_in">UIBarButtonItemStyleBordered</span> barMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];<br><br><span class="hljs-comment">//backBarButton需要单独设置背景效果，只能在ios6.0以后才能用</span><br>[appearance setBackButtonBackgroundImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;bgImage&quot;</span>] forState:<span class="hljs-number">0</span> barMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];<br><br>[appearance setBackButtonBackgroundImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;image&quot;</span>] forState:<span class="hljs-number">1</span> barMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];<br><br>[appearance setBackButtonforBarMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];<br></code></pre></td></tr></table></figure><h3 id="工具栏（UIToolbar）"><a href="#工具栏（UIToolbar）" class="headerlink" title="工具栏（UIToolbar）"></a>工具栏（UIToolbar）</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIToolbar</span> *appearance = [<span class="hljs-built_in">UIToolbar</span> appearance];<br><span class="hljs-comment">//样式和背景二选一即可，看需求了</span><br><span class="hljs-comment">//样式（黑色半透明，不透明等）设置</span><br>[appearance setBarStyle:<span class="hljs-built_in">UIBarStyleBlackTranslucent</span>];<br><span class="hljs-comment">//背景设置</span><br>[appearance setBackgroundImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;bgImage&quot;</span>] forToolbarPosition:<span class="hljs-built_in">UIToolbarPositionAny</span> barMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];<br></code></pre></td></tr></table></figure><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#x39;&#57;&#x34;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;">&#95;&#x31;&#x39;&#57;&#x34;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS笔记</tag>
      
      <tag>UIAppearance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【iOS Sharing】KVO、消息转发等</title>
    <link href="/post/a3bdc258.html"/>
    <url>/post/a3bdc258.html</url>
    
    <content type="html"><![CDATA[<h2 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1、开发中逆向传值的方式有哪些？"><a href="#1、开发中逆向传值的方式有哪些？" class="headerlink" title="1、开发中逆向传值的方式有哪些？"></a><a href="#h3-1">1、开发中逆向传值的方式有哪些？</a></h3><h3 id="2、开发中方法延迟执行的方式有哪些？"><a href="#2、开发中方法延迟执行的方式有哪些？" class="headerlink" title="2、开发中方法延迟执行的方式有哪些？"></a><a href="#h3-2">2、开发中方法延迟执行的方式有哪些？</a></h3><h3 id="3、说一说KVO在重写NSKVONotifying对象的setter方法中，添加了哪两个关键方法？"><a href="#3、说一说KVO在重写NSKVONotifying对象的setter方法中，添加了哪两个关键方法？" class="headerlink" title="3、说一说KVO在重写NSKVONotifying对象的setter方法中，添加了哪两个关键方法？"></a><a href="#h3-3">3、说一说KVO在重写NSKVONotifying对象的setter方法中，添加了哪两个关键方法？</a></h3><h3 id="4、如何实现一个完整的单例？"><a href="#4、如何实现一个完整的单例？" class="headerlink" title="4、如何实现一个完整的单例？"></a><a href="#h3-4">4、如何实现一个完整的单例？</a></h3><h3 id="5、iOS消息转发流程"><a href="#5、iOS消息转发流程" class="headerlink" title="5、iOS消息转发流程"></a><a href="#h3-5">5、iOS消息转发流程</a></h3><span id="more"></span><hr><h3 id='h3-1'>1、开发中逆向传值的方式有哪些？</h3><ul><li>代理</li><li>通知</li><li>单例</li><li>block</li><li>KVO</li></ul><h3 id='h3-2'>2、开发中方法延迟执行的方式有哪些？</h3><h4 id='h3-h4-1'> (1)、performSelector</h4>此方法是一种非阻塞的执行方式，未找到取消执行的方法。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(delayMethod) withObject:<span class="hljs-literal">nil</span><span class="hljs-comment">/*可传任意类型参数*/</span> afterDelay:<span class="hljs-number">1.0</span>];<br></code></pre></td></tr></table></figure><h4 id='h3-h4-2'> (2)、NSTimer</h4>此方法是一种非阻塞的执行方式，取消执行方法：`- (void)invalidate;`<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSTimer</span> *timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(delayMethod) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">NO</span>];<br></code></pre></td></tr></table></figure><h4 id='h3-h4-3'> (3)、NSThread的sleep</h4>此方法是一种阻塞执行方式，建议放在子线程中执行，否则会卡住界面。但有时还是需要阻塞执行，如进入欢迎界面需要沉睡3秒才进入主界面时。没有找到取消执行方式。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">[<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1.0</span>];<br></code></pre></td></tr></table></figure><h4 id='h3-h4-4'>(4)、GCD</h4>此方法可以在参数中选择执行的线程，是一种非阻塞执行方式。没有找到取消执行方式。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">dispatch_time_t delayTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">1.0</span><span class="hljs-comment">/*延迟执行时间*/</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>));<br><br>dispatch_after(delayTime, dispatch_get_main_queue(), ^&#123;<br>    [weakSelf delayMethod];<br>&#125;);`<br></code></pre></td></tr></table></figure><h3 id='h3-3'>3、说一说KVO在重写NSKVONotifying对象的setter方法中，添加了哪两个关键方法？</h3>答：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc">-(<span class="hljs-keyword">void</span>)willChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br>-(<span class="hljs-keyword">void</span>)didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br></code></pre></td></tr></table></figure><hr><h3 id='h3-4'>4、如何实现一个完整的单例？</h3>答：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;SingletonSample.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SingletonSample</span>()&lt;<span class="hljs-title">NSCopying</span>&gt;</span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SingletonSample</span></span><br>+(<span class="hljs-keyword">instancetype</span>)sharedInstance<br>&#123;<br>    <span class="hljs-keyword">static</span> SingletonSample *instance = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        instance = [[<span class="hljs-keyword">super</span> allocWithZone:<span class="hljs-literal">NULL</span>] init];<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br>+(<span class="hljs-keyword">instancetype</span>)allocWithZone:(<span class="hljs-keyword">struct</span> _NSZone *)zone<br>&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> sharedInstance];<br>&#125;<br><br>-(<span class="hljs-keyword">id</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><hr><h3 id="h3-5">5、iOS消息转发流程</h3>答：</br>消息转发机制基本分为三个步骤：</br><ul><li>1、动态方法解析</li><li>2、备用接受者</li><li>3、完整转发</li></ul><p><a href="https://github.com/Adrenine/ForwardInvocation">完整代码</a></p><p><img src="https://i.loli.net/2019/03/29/5c9dd0956f0fd.png" alt="流程"></p><p>类方法：<br><img src="https://i.loli.net/2019/05/29/5cee5315b51d941052.png" alt="类方法"></p><p>实例方法：<br><img src="https://i.loli.net/2019/05/29/5cee534017cc838683.png" alt="实例方法"></p><p>详细流程：<br><img src="https://i.loli.net/2019/03/29/5c9dcfbd2b74c.jpg" alt="详细流程"></p><p>感谢大佬提供的图片。</p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#57;&#52;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;">&#x5f;&#49;&#x39;&#57;&#52;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS Sharing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS Sharing</tag>
      
      <tag>知识点</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【iOS Sharing】UIView相关</title>
    <link href="/post/c37a4bbd.html"/>
    <url>/post/c37a4bbd.html</url>
    
    <content type="html"><![CDATA[<h2 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-setNeedsLayout、layoutIfNeeded与layoutSubviews区别？"><a href="#1-setNeedsLayout、layoutIfNeeded与layoutSubviews区别？" class="headerlink" title="1. setNeedsLayout、layoutIfNeeded与layoutSubviews区别？"></a><a href="#h3-1">1. setNeedsLayout、layoutIfNeeded与layoutSubviews区别？</a></h3><h3 id="2-UIView与CALayer的区别？"><a href="#2-UIView与CALayer的区别？" class="headerlink" title="2. UIView与CALayer的区别？"></a><a href="#h3-2">2. UIView与CALayer的区别？</a></h3><h3 id="3-loadView什么时候被调用？它有什么作用？默认实现是怎么样的？"><a href="#3-loadView什么时候被调用？它有什么作用？默认实现是怎么样的？" class="headerlink" title="3. loadView什么时候被调用？它有什么作用？默认实现是怎么样的？"></a><a href="#h3-3">3. loadView什么时候被调用？它有什么作用？默认实现是怎么样的？</a></h3><h3 id="4-UIViewController的完整生命周期？"><a href="#4-UIViewController的完整生命周期？" class="headerlink" title="4. UIViewController的完整生命周期？"></a><a href="#h3-4">4. UIViewController的完整生命周期？</a></h3><h3 id="5-UIView动画支持的属性有哪些？"><a href="#5-UIView动画支持的属性有哪些？" class="headerlink" title="5. UIView动画支持的属性有哪些？"></a><a href="#h3-5">5. UIView动画支持的属性有哪些？</a></h3><span id="more"></span><hr><h3 id="h3-1">1. setNeedsLayout、layoutIfNeeded与layoutSubviews区别？</h3><h3 id="1-、setNeedsLayout"><a href="#1-、setNeedsLayout" class="headerlink" title="(1)、setNeedsLayout"></a>(1)、setNeedsLayout</h3><p>用于更新视图以及其子视图布局，不会立即更新，是一个异步方法，需要在主线程调用。该方法将视图以及其子视图标记，在下一个更新周期执行更新操作，不知道具体更新时间。</p><p>关于<code>setNeedsLayout</code>，官方文档描述如下：</p><blockquote><p>Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.</p></blockquote><h3 id="2-、layoutIfNeeded"><a href="#2-、layoutIfNeeded" class="headerlink" title="(2)、layoutIfNeeded"></a>(2)、layoutIfNeeded</h3><p>用于更新视图以及其子视图布局，立即更新，不会等待更新周期，从根视图开始更新视图子树，若无待更新的布局，直接退出。</p><p>关于<code>layoutIfNeeded</code>，官方文档描述如下：</p><blockquote><p>Use this method to force the view to update its layout immediately. When using Auto Layout, the layout engine updates the position of views as needed to satisfy changes in constraints. Using the view that receives the message as the root view, this method lays out the view subtree starting at the root. If no layout updates are pending, this method exits without modifying the layout or calling any layout-related callbacks.</p></blockquote><h3 id="3-、layoutSubviews"><a href="#3-、layoutSubviews" class="headerlink" title="(3)、layoutSubviews"></a>(3)、layoutSubviews</h3><p>一般是在<code>autoresizing</code>或者 <code>constraint-based</code>的情况下重写此方法。常用场景是当视图不是使用frame初始化的时候，我们可以在此方法进行一些精细化布局。如子视图相对于父视图使用约束布局，子视图init时，不具有frame直到约束建立，因为不知道约束建立完成时机，而我们又确实需要frame进行一些计算，为确保计算时拿到的frame不为空，此时，我们可以将计算的过程放于此，并配合<code>setNeedsLayout</code>或者<code>layoutIfNeeded</code>进行视图刷新。</p><p>关于<code>layoutSubviews</code>，官方文档描述如下：</p><blockquote><p>Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.</p></blockquote><blockquote><p>You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.</p></blockquote><h3 id="h3-2">2. UIView与CALayer的区别？</h3><ul><li>UIView可以响应事件，CALayer不可以响应事件</li><li>一个 Layer 的 frame 是由它的 anchorPoint,position,bounds,和 transform 共同决定的，而一个 View 的 frame 只是简单的返回 Layer的 frame</li><li>UIView主要是对显示内容的管理而 CALayer 主要侧重显示内容的绘制</li><li>在做 iOS 动画的时候，修改非 RootLayer的属性（譬如位置、背景色等）会默认产生隐式动画，而修改UIView则不会。</li></ul><h3 id="h3-3">3. loadView什么时候被调用？它有什么作用？默认实现是怎么样的？</h3><h3 id="1）、什么时候被调用？"><a href="#1）、什么时候被调用？" class="headerlink" title="1）、什么时候被调用？"></a>1）、什么时候被调用？</h3><p>每次访问UIViewController的view(比如controller.view、self.view)而且view为nil，loadView方法就会被调用。</p><h3 id="2）、有什么作用？"><a href="#2）、有什么作用？" class="headerlink" title="2）、有什么作用？"></a>2）、有什么作用？</h3><p>loadView方法是用来负责创建UIViewController的view</p><h3 id="3）、默认实现是怎样的？"><a href="#3）、默认实现是怎样的？" class="headerlink" title="3）、默认实现是怎样的？"></a>3）、默认实现是怎样的？</h3><p>默认实现即<code>[super loadView]</code>里面做了什么事情。</p><h4 id="a-、-它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view"><a href="#a-、-它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view" class="headerlink" title="a)、 它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view"></a>a)、 它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view</h4><ul><li>如果在初始化UIViewController指定了xib文件名，就会根据传入的xib文件名加载对应的xib文件<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">[[MyViewController alloc] initWithNibName:<span class="hljs-string">@&quot;MyViewController&quot;</span> bundle:<span class="hljs-literal">nil</span>];<br></code></pre></td></tr></table></figure></li><li>如果没有明显地传xib文件名，就会加载跟UIViewController同名的xib文件<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">[[MyViewController alloc] init]; <span class="hljs-comment">// 加载MyViewController.xib</span><br></code></pre></td></tr></table></figure><h4 id="b-、如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性，大致如下"><a href="#b-、如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性，大致如下" class="headerlink" title="b) 、如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性，大致如下"></a>b) 、如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性，大致如下</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.view = [[<span class="hljs-built_in">UIView</span> alloc] initWithFrame:[<span class="hljs-built_in">UIScreen</span> mainScreen].applicationFrame];<br><br></code></pre></td></tr></table></figure><code>[super loadView]</code>里面就大致完成a)和b)中叙述的内容</li></ul><p><strong>Tips:</strong></br><br>若要自己重写<code>loadView</code>方法，此时为节省开销，应避免调用<code>[super loadView]</code>方法。</p><h3 id="h3-4">4. UIViewController的完整生命周期？</h3><p>按照执行顺序排列：</p><ul><li><code>init</code>初始化ViewController</li><li><code>loadView</code>当view需要被展示而它却是nil时，viewController会调用该方法。如果代码维护View的话需要重写此方法，使用xib维护View的话不用重写。</li><li><code>viewDidLoad</code>执行完loadView后继续执行viewDidLoad，loadView时还没有view，而viewDidLoad时view已经创建好了。</li><li><code>viewWillAppear</code>视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了;</li><li><code>viewDidAppear</code>视图已在屏幕上渲染完成 当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反;</li><li><code>viewWillDisappear</code>视图将被从屏幕上移除之前执行</li><li><code>viewDidDisappear</code>视图已经被从屏幕上移除，用户看不到这个视图了</li><li><code>viewWillUnload</code>如果当前有能被释放的view，系统会调用viewWillUnload方法来释放view</li><li><code>viewDidUnload</code>当系统内存吃紧的时候会调用该方法，在iOS 3.0之前didReceiveMemoryWarning是释放无用内存的唯一方式，但是iOS 3.0及以后viewDidUnload方法是更好的方式。在该方法中将所有IBOutlet（无论是property还是实例变量）置为nil（系统release view时已经将其release掉了）。在该方法中释放其他与view有关的对象、其他在运行时创建（但非系统必须）的对象、在viewDidLoad中被创建的对象、缓存数据等。一般认为viewDidUnload是viewDidLoad的镜像，因为当view被重新请求时，viewDidLoad还会重新被执行。</li><li><code>dealloc</code>视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放.关于viewDidUnload ：在发生内存警告的时候如果本视图不是当前屏幕上正在显示的视图的话，viewDidUnload将会被执行，本视图的所有子视图将被销毁以释放内存,此时开发者需要手动对viewLoad、viewDidLoad中创建的对象释放内存。因为当这个视图再次显示在屏幕上的时候，viewLoad、viewDidLoad 再次被调用，以便再次构造视图。</li></ul><h3 id="h3-5">5. UIView动画支持的属性有哪些？</h3><ul><li>frame: 位置和大小</li><li>bounds</li><li>center</li><li>transform</li><li>alpha</li><li>backgroundColor</li><li>contentStretch</li></ul><p>基本用法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-keyword">void</span>)animateWithDuration:(<span class="hljs-built_in">NSTimeInterval</span>)duration <br>                      delay:(<span class="hljs-built_in">NSTimeInterval</span>)delay <br>                    options:(<span class="hljs-built_in">UIViewAnimationOptions</span>)options <br>                 animations:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-keyword">void</span>))animations <br>                 completion:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">BOOL</span> finished))completion;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>duration ：整个动画持续的时间</li><li>delay：动画在多久之后开始，值为 0 表示代码执行到这里后动画立刻开始</li><li>options：一些有关动画的设置，例如想要动画刚开始比较快，到快结束时比较慢，都在这里设置。</li><li>animations：在这个 block 中写入你想要执行的代码即可。block 中对视图的动画属性所做的改变都会生成动画</li><li>completion：动画完成后会调用，finished 表示动画是否成功执行完毕。可以将动画执行完成后需要执行的代码写在这里</li></ul><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#x39;&#57;&#x34;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;">&#x5f;&#x31;&#x39;&#57;&#x34;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS Sharing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS Sharing</tag>
      
      <tag>知识点</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【iOS Sharing】NSUserDefaults相关</title>
    <link href="/post/b47d7b2b.html"/>
    <url>/post/b47d7b2b.html</url>
    
    <content type="html"><![CDATA[<h2 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-NSUserDefaults-能够存储哪些类型的数据？可以存储可变数据类型吗？可以存储自定义数据类型吗？"><a href="#1-NSUserDefaults-能够存储哪些类型的数据？可以存储可变数据类型吗？可以存储自定义数据类型吗？" class="headerlink" title="1. NSUserDefaults 能够存储哪些类型的数据？可以存储可变数据类型吗？可以存储自定义数据类型吗？"></a><a href="#h3-1">1. NSUserDefaults 能够存储哪些类型的数据？可以存储可变数据类型吗？可以存储自定义数据类型吗？</a></h3><h3 id="2-NSUserDefaults-没有存储-key-的时候默认返回什么？"><a href="#2-NSUserDefaults-没有存储-key-的时候默认返回什么？" class="headerlink" title="2. NSUserDefaults 没有存储 key 的时候默认返回什么？"></a><a href="#h3-2">2. NSUserDefaults 没有存储 key 的时候默认返回什么？</a></h3><h3 id="3-NSUserDefaults-存取操作是什么？它将数据存在何处？并且它是如何保持数据一致性的"><a href="#3-NSUserDefaults-存取操作是什么？它将数据存在何处？并且它是如何保持数据一致性的" class="headerlink" title="3. NSUserDefaults 存取操作是什么？它将数据存在何处？并且它是如何保持数据一致性的?"></a><a href="#h3-3">3. NSUserDefaults 存取操作是什么？它将数据存在何处？并且它是如何保持数据一致性的?</a></h3><h3 id="4-NSUserDefaults-旧数据总能被新设置的替换吗？"><a href="#4-NSUserDefaults-旧数据总能被新设置的替换吗？" class="headerlink" title="4. NSUserDefaults 旧数据总能被新设置的替换吗？"></a><a href="#h3-4">4. NSUserDefaults 旧数据总能被新设置的替换吗？</a></h3><h3 id="5-NSUserDefaults-性能如何"><a href="#5-NSUserDefaults-性能如何" class="headerlink" title="5. NSUserDefaults 性能如何?"></a><a href="#h3-5">5. NSUserDefaults 性能如何?</a></h3><span id="more"></span><hr><h3 id="h3-1">1. NSUserDefaults 能够存储哪些类型的数据？可以存储可变数据类型吗？可以存储自定义数据类型吗？</h3><h3 id="（1）可存储的数据类型"><a href="#（1）可存储的数据类型" class="headerlink" title="（1）可存储的数据类型"></a>（1）可存储的数据类型</h3><ul><li>NSNumber（NSInteger、float、double、bool）</li><li>NSString</li><li>NSDate</li><li>NSData</li><li>NSArray</li><li>NSDictionary</li></ul><h3 id="（2）可以，但是取出来是不可变类型"><a href="#（2）可以，但是取出来是不可变类型" class="headerlink" title="（2）可以，但是取出来是不可变类型"></a>（2）可以，但是取出来是不可变类型</h3><p>可以将可变数据类型存入，但是取出来的时候，数据类型会变成不可变</p><h3 id="（3）不可以"><a href="#（3）不可以" class="headerlink" title="（3）不可以"></a>（3）不可以</h3><p>自定义数据类型, 例如自定义模型, 需要先转成 <code>NSData</code> 类型才能存储</p><h3 id="h3-2">2. NSUserDefaults 没有存储 key 的时候默认返回什么？</h3><ul><li>当获取对象时，默认返回<code>nil</code></li><li>当获取数字时，默认返回0</li><li>当获取bool类型时，默认返回false</li></ul><h3 id="h3-3">3. NSUserDefaults 存取操作是什么？它将数据存在何处？并且它是如何保持数据一致性的? </h3><h3 id="（1）存取方式"><a href="#（1）存取方式" class="headerlink" title="（1）存取方式"></a>（1）存取方式</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//存</span><br>[[<span class="hljs-built_in">NSUserDefaults</span> standardUserDefaults] setObject:value forKey:<span class="hljs-string">@&quot;key&quot;</span>];<br></code></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//取</span><br><span class="hljs-keyword">id</span> value = [[<span class="hljs-built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:<span class="hljs-string">@&quot;key&quot;</span>];<br></code></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//强制同步数据</span><br>[[<span class="hljs-built_in">NSUserDefaults</span> standardUserDefaults] synchronize];<br></code></pre></td></tr></table></figure><p>关于 <code>NSUserDefaults</code>, 官方文档有这么一段话: </p><blockquote><p>At runtime, you use NSUserDefaults objects to read the defaults that your app uses from a user’s defaults database. NSUserDefaults caches the information to avoid having to open the user’s defaults database each time you need a default value. When you set a default value, it’s changed synchronously within your process, and asynchronously to persistent storage and other processes.</p></blockquote><p>NSUserDefaults 会将访问到的 key 和 value 缓存到内存中, 下次访问时, 如果缓存中命中这个 key, 就直接访问, 如果没有命中, 再从文件中载入, 会时不时调用 <code>synchronize</code> 来保证数据的一致性, 但是这个操作非实时的, 为了防止数据丢失, 我们应该在对重要的数据保存时使用<code>synchornize</code>方法强制写入, 但也不要过于频繁, 毕竟频繁访问数据库影响性能</p><h3 id="（2）存储位置"><a href="#（2）存储位置" class="headerlink" title="（2）存储位置"></a>（2）存储位置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 沙盒下<br>AppData/Library/Preferences/Bundle\ Identifier.plist<br></code></pre></td></tr></table></figure><h3 id="h3-4">4. NSUserDefaults 旧数据总能被新设置的替换吗？</h3>并不一定, 在使用 `registerDefaults` 来注册默认时, 旧值不一定被替换<p>官方注释:</p><blockquote><p>adds the registrationDictionary to the last item in every search list. This means that after NSUserDefaults has looked for a value in every other valid location, it will look in registered defaults, making them useful as a “fallback” value. Registered defaults are never stored between runs of an application, and are visible only to the application that registers them. Default values from Defaults Configuration Files will automatically be registered.</p></blockquote><p>大致是说, 当应用内没有这个值时, 这个值将作为默认值存在, 如果这个 key 已经存在, 那么这个值将作为备用, 并且当 app 再次启动, 这个默认值并不会替换已经存在的值, 我们用几行代码来说明</p><ol><li><p>首先</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions &#123;<br>    <br>    <span class="hljs-built_in">NSDictionary</span> *defaultValues = [<span class="hljs-built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="hljs-string">@&quot;blue&quot;</span>, <span class="hljs-string">@&quot;color&quot;</span>, <span class="hljs-literal">nil</span>];   <br>    [[<span class="hljs-built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:defaultValues];  <br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;  <br></code></pre></td></tr></table></figure></li><li><p>当 app 第一次 run 时, NSUserDefaults 会把 @”color” = @”blue” 写入 plist 中, 然后比如在 app 内调用了</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">[[<span class="hljs-built_in">NSUserDefaults</span> standardUserDefaults] setObject:<span class="hljs-string">@&quot;red&quot;</span> forKey:<span class="hljs-string">@&quot;color&quot;</span>];  <br></code></pre></td></tr></table></figure><p>这时 NSUserDefaults 里 @”color” = @”red”</p></li><li><p>退出 app, 杀掉后台, 第1步里的 <code>registerDefaults</code> 还是会被调用, 但它会查到 @”color” key 已存在, 并不会把 @”blue” 写进去</p></li><li><p>将 <code>registerDefaults</code> 修改为</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSDictionary</span> *defaultValues = [<span class="hljs-built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="hljs-string">@&quot;black&quot;</span>, <span class="hljs-string">@&quot;color&quot;</span>,<span class="hljs-string">@&quot;tomson&quot;</span>, <span class="hljs-string">@&quot;username&quot;</span>,<span class="hljs-literal">nil</span>];   <br>[[<span class="hljs-built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:defaultValues]; <br></code></pre></td></tr></table></figure><p>这时, NSUserDefaults 内 @”color” 依然为 @”red”, 但多了 @”username” = @”tomson”</p></li></ol><h3 id="h3-5">5. NSUserDefaults 性能如何? </h3><p>从性能上分析, 缓存的机制带来了一定的性能提升, 通过一些网上的文章了解到在10万个key的情况下, 通过<code>NSUserDefaults</code>来读取value是1ms级别的, 然而当你从plist文件中直接读取, 需要100ms的级别开销, 但是写是个相反的结果, 要是你写1个10万条数据到plist文件中是1s级别的开销，而同时写入10万条<code>NSUserDefaults</code>键值对则需要10s级别的延迟. 我们都知道在创建key/value时, 程序需要在内存中也创建一个相应的映射关系, 然后系统会时不时调用<code>synchronsize</code>方法同步数据, 很多的方法会导致创建key/value pair被阻塞</p><p>总的来说, 使用<code>NSUserDefaults</code>是比较高效的, 但是不能大量的将数据通过 NSUserDefaults 中</p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#57;&#x39;&#x34;&#x40;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#x6d;">&#95;&#x31;&#57;&#x39;&#x34;&#x40;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS Sharing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS Sharing</tag>
      
      <tag>知识点</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【iOS Sharing】属性相关</title>
    <link href="/post/24c266ba.html"/>
    <url>/post/24c266ba.html</url>
    
    <content type="html"><![CDATA[<h2 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1、atomic关键字内部使用的是什么锁？"><a href="#1、atomic关键字内部使用的是什么锁？" class="headerlink" title="1、atomic关键字内部使用的是什么锁？"></a><a href="#h3-1">1、atomic关键字内部使用的是什么锁？</a></h3><h3 id="2、-property-copy-NSMutableArray-array这样声明属性会出现什么问题？"><a href="#2、-property-copy-NSMutableArray-array这样声明属性会出现什么问题？" class="headerlink" title="2、@property(copy)NSMutableArray *array这样声明属性会出现什么问题？"></a><a href="#h3-2">2、@property(copy)NSMutableArray *array这样声明属性会出现什么问题？</a></h3><h3 id="3、什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#3、什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="3、什么情况使用 weak 关键字，相比 assign 有什么不同？"></a><a href="#h3-3">3、什么情况使用 weak 关键字，相比 assign 有什么不同？</a></h3><h3 id="4、weak属性需要在dealloc中置nil么？"><a href="#4、weak属性需要在dealloc中置nil么？" class="headerlink" title="4、weak属性需要在dealloc中置nil么？"></a><a href="#h3-4">4、weak属性需要在dealloc中置nil么？</a></h3><h3 id="5、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#5、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="5、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a><a href="#h3-5">5、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</a></h3><span id="more"></span><hr><h3 id="h3-1">1、atomic关键字内部使用的是什么锁？</h3>答：</br><p><strong>首先了解一些基本概念:</strong> </p><ul><li><p>临界区：指的是一块对公共资源进行访问的代码，并非一种机制或是算法。</p></li><li><p>自旋锁：是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</p></li><li><p>互斥锁（Mutex）：是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区而达成。</p></li><li><p>读写锁：是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁) 用于解决多线程对公共资源读写问题。读操作可并发重入，写操作是互斥的。 读写锁通常用互斥锁、条件变量、信号量实现。</p></li><li><p>信号量（semaphore）：是一种更高级的同步机制，互斥锁可以说是semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。</p></li><li><p>条件锁：就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行。</p></li><li><p>死锁：指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去，这些永远在互相等待的进程称为死锁进程。</p></li><li><p>轮询（Polling）：一种CPU决策如何提供周边设备服务的方式，又称“程控输出入”。轮询法的概念是，由CPU定时发出询问，依序询问每一个周边设备是否需要其服务，有即给予服务，服务结束后再问下一个周边，接着不断周而复始。</p></li></ul><p><strong>锁的类型：</strong></p><ul><li><p>互斥锁</p><ul><li>NSLock</li><li>pthread_mutex</li><li>pthread_mutex(recursive)递归锁</li><li>@synchronized</li></ul></li><li><p>自旋锁</p><ul><li>OSSpinLock</li><li>os_unfair_lock</li></ul></li><li><p>读写锁</p><ul><li>pthread_rwlock</li></ul></li><li><p>递归锁</p><ul><li><p>NSRecursiveLock</p></li><li><p>pthread_mutex(recursive)（见上）</p></li></ul></li><li><p>条件锁</p><ul><li>NSCondition</li><li>NSConditionLock</li></ul></li><li><p>信号量</p><ul><li>dispatch_semaphore</li></ul></li></ul><p><img src="https://i.loli.net/2019/04/04/5ca5a766b143c.png" alt="time"> </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//<span class="hljs-number">10000000</span><br>OSSpinLock:                 <span class="hljs-number">112.38</span> ms<br>dispatch_semaphore:         <span class="hljs-number">160.37</span> ms<br>os_unfair_lock:             <span class="hljs-number">208.87</span> ms<br>pthread_mutex:              <span class="hljs-number">302.07</span> ms<br>NSCondition:                <span class="hljs-number">320.11</span> ms<br>NSLock:                     <span class="hljs-number">331.80</span> ms<br>pthread_rwlock:             <span class="hljs-number">360.81</span> ms<br>pthread_mutex(recursive):   <span class="hljs-number">512.17</span> ms<br>NSRecursiveLock:            <span class="hljs-number">667.55</span> ms<br>NSConditionLock:            <span class="hljs-number">999.91</span> ms<br>@synchronized:             <span class="hljs-number">1654.92</span> ms<br><br>//<span class="hljs-number">1000</span><br>OSSpinLock:                   <span class="hljs-number">0.02</span> ms<br>dispatch_semaphore:           <span class="hljs-number">0.03</span> ms<br>os_unfair_lock:               <span class="hljs-number">0.04</span> ms<br>pthread_mutex:                <span class="hljs-number">0.06</span> ms<br>NSLock:                       <span class="hljs-number">0.06</span> ms<br>pthread_rwlock:               <span class="hljs-number">0.07</span> ms<br>NSCondition:                  <span class="hljs-number">0.07</span> ms<br>pthread_mutex(recursive):     <span class="hljs-number">0.09</span> ms<br>NSRecursiveLock:              <span class="hljs-number">0.12</span> ms<br>NSConditionLock:              <span class="hljs-number">0.18</span> ms<br>@synchronized:                <span class="hljs-number">0.33</span> ms<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/04/5ca5a77ed27d7.jpg" alt="atomic"></p><p>atomic使用的是自旋锁，主要用于赋值操作等轻量操作（散列表，引用计数，弱引用指针赋值），而互斥锁一般都是锁线程，比如单例。</p><hr><h4 id="h4-1">OC method简单介绍</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_method *Method;<br><span class="hljs-keyword">struct</span> objc_method &#123;<br>    SEL method_name OBJC2_UNAVAILABLE;  <span class="hljs-comment">//方法名</span><br>    <span class="hljs-keyword">char</span> *method_types OBJC2_UNAVAILABLE;   <span class="hljs-comment">//方法类型</span><br>    IMP method_imp OBJC2_UNAVAILABLE;   <span class="hljs-comment">//方法实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>objc_method 存储了方法名，方法类型和方法实现。</p><h4 id="h4-2">SEL 方法名类型</h4><p>方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型<br>method_imp 指向了方法的实现，本质是一个函数指针<br>Ivar<br>Ivar 是表示成员变量的类型。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_ivar *Ivar;<br><span class="hljs-keyword">struct</span> objc_ivar &#123;<br>    <span class="hljs-keyword">char</span> *ivar_name OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">char</span> *ivar_type OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">int</span> ivar_offset OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __LP64__</span><br>    <span class="hljs-keyword">int</span> space OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 ivar_offset 是基地址偏移字节</p><h4 id="h4-3">IMP</h4><p>IMP在objc.h中的定义是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">id</span> (*IMP)(<span class="hljs-keyword">id</span>, SEL, ...);<br></code></pre></td></tr></table></figure><p>它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的，而 IMP 这个函数指针就指向了这个方法的实现。</p><hr><h3 id="h3-2">2、@property(copy)NSMutableArray *array这样声明属性会出现什么问题？</h3>答：<ul><li>NSMutableArray经过copy修饰后是NSArray（不可变数组）。如果对经copy修饰后的可变数组进行增删改的操作，实际上是在操作不可变数组，从而会引起程序异常，引起Crash。</li><li>不写原子性修饰词默认使用atomic，而atomic性能比nonatomic差很多。</li></ul><h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="浅拷贝：指针拷贝，不生成新对象"><a href="#浅拷贝：指针拷贝，不生成新对象" class="headerlink" title="浅拷贝：指针拷贝，不生成新对象"></a>浅拷贝：指针拷贝，不生成新对象</h4><ul><li>不可变对象的不可变拷贝</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *array = [<span class="hljs-built_in">NSArray</span> array];<br><br><span class="hljs-comment">//相同地址        </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,array);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,[array <span class="hljs-keyword">copy</span>]);<br><br><span class="hljs-comment">// __NSArray0 (不可变数组)      </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([[array <span class="hljs-keyword">copy</span>] <span class="hljs-keyword">class</span>]));<br></code></pre></td></tr></table></figure><p>输出：<br><img src="https://i.loli.net/2019/04/12/5cb024c78c620.png" alt="在这里插入图片描述"></p><hr><h4 id="深拷贝：生成一个新对象，对象内容相同（-除浅拷贝那种情况，其他都是深拷贝）"><a href="#深拷贝：生成一个新对象，对象内容相同（-除浅拷贝那种情况，其他都是深拷贝）" class="headerlink" title="深拷贝：生成一个新对象，对象内容相同（ 除浅拷贝那种情况，其他都是深拷贝）"></a>深拷贝：生成一个新对象，对象内容相同（ 除浅拷贝那种情况，其他都是深拷贝）</h4><ul><li>可变对象的可变拷贝 </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSMutableArray</span> *mutArray = [<span class="hljs-built_in">NSMutableArray</span> array];<br><br><span class="hljs-comment">//输出不同地址   </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,mutArray);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,[mutArray mutableCopy]);<br><br><span class="hljs-comment">// __NSArrayM （可变数组）</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([[mutArray mutableCopy] <span class="hljs-keyword">class</span>]));<br></code></pre></td></tr></table></figure><p>输出：<br><img src="https://i.loli.net/2019/04/12/5cb0253253451.png" alt="在这里插入图片描述"></p><ul><li><p>可变对象的不可变拷贝    </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSMutableArray</span> *mutArray = [<span class="hljs-built_in">NSMutableArray</span> array];<br><span class="hljs-comment">//不同地址      </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,mutArray);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,[mutArray <span class="hljs-keyword">copy</span>]);<br><br><span class="hljs-comment">// __NSArray0</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([[mutArray <span class="hljs-keyword">copy</span>] <span class="hljs-keyword">class</span>]));<br></code></pre></td></tr></table></figure><p>输出：<br><img src="https://i.loli.net/2019/04/12/5cb0257999966.png" alt="在这里插入图片描述"></p></li><li><p>不可变对象的可变拷贝    </p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *array = [<span class="hljs-built_in">NSArray</span> array];<br><br><span class="hljs-comment">//不同对象  </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,array);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>,[array mutableCopy]);<br><span class="hljs-comment">// __NSArrayM    </span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([[array mutableCopy] <span class="hljs-keyword">class</span>]));<br></code></pre></td></tr></table></figure><p>输出：<br><img src="https://i.loli.net/2019/04/12/5cb025b3269ed.png" alt="在这里插入图片描述"></p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><strong>除不可变对象的不可变拷贝为浅拷贝，其余都是深拷贝</strong><br><img src="https://i.loli.net/2019/04/12/5cb026d4b7035.png" alt="在这里插入图片描述"></p><hr><h3 id="h3-3">3、什么情况使用 weak 关键字，相比 assign 有什么不同？</h3><h3 id="（1-、什么情况下使用weak："><a href="#（1-、什么情况下使用weak：" class="headerlink" title="（1)、什么情况下使用weak："></a>（1)、什么情况下使用weak：</h3><ul><li>在ARC中修饰代理</li><li>使用@IBOutlet连接控件</li><li>当block会造成循环引用</li></ul><h3 id="（2-、与assign的不同"><a href="#（2-、与assign的不同" class="headerlink" title="（2)、与assign的不同"></a>（2)、与assign的不同</h3><p>assign可以用于非对象类型，而weak必须用于对象类型</p><hr><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>修饰变量类型的区别</br><br>weak 只可以修饰对象。如果修饰基本数据类型，编译器会报错-“Property with ‘weak’ attribute must be of object type”。<br>assign 可修饰对象，和基本数据类型。当需要修饰对象类型时，MRC时代使用unsafe_unretained。当然，unsafe_unretained也可能产生野指针，所以它名字是”unsafe_”。</li></ul><ul><li>是否产生野指针的区别</br><br>weak 不会产生野指针问题。因为weak修饰的对象释放后（引用计数器值为0），指针会自动被置nil，之后再向该对象发消息也不会崩溃。 weak是安全的。<br>assign 如果修饰对象，会产生野指针问题；如果修饰基本数据类型则是安全的。修饰的对象释放后，指针不会自动被置空，此时向对象发消息会崩溃。</li></ul><h4 id="相似"><a href="#相似" class="headerlink" title="相似"></a>相似</h4><p>都可以修饰对象类型，但是assign修饰对象会存在问题。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>assign</strong> 适用于基本数据类型如int,float,struct等值类型，不适用于引用类型。因为值类型会被放入栈中，遵循先进后出原则，由系统负责管理栈内存。而引用类型会被放入堆中，需要我们自己手动管理内存或通过ARC管理。</br></p><p><strong>weak</strong> 适用于delegate和block等引用类型，不会导致野指针问题，也不会循环引用，比较安全。</p><h3 id="h3-4">4、weak属性需要在dealloc中置nil么？</h3><p>在ARC中，无论是strong修饰的对象还是weak修饰的对象，都不再需要在dealloc中将对象置为nil，编译器会自动帮我们处理，即使编译器不帮助我们处理，在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p><h3 id="h3-5">5、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><ul><li>原子性 – atomic</li><li>读写权限 – readwrite</li><li>内存管理 – 基础数据类型（assign），对象（strong）</li></ul><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#x31;&#57;&#x39;&#52;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;">&#x5f;&#x31;&#57;&#x39;&#52;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS Sharing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS Sharing</tag>
      
      <tag>知识点</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【iOS Sharing】block相关</title>
    <link href="/post/53c5562c.html"/>
    <url>/post/53c5562c.html</url>
    
    <content type="html"><![CDATA[<h3 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h3><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-block的循环引用是如何造成的？"><a href="#1-block的循环引用是如何造成的？" class="headerlink" title="1. block的循环引用是如何造成的？"></a><a href="#h3-1">1. block的循环引用是如何造成的？</a></h3><h3 id="2-使用UIAnimation的block回调时，需不需要使用-weak避免循环引用？为什么？"><a href="#2-使用UIAnimation的block回调时，需不需要使用-weak避免循环引用？为什么？" class="headerlink" title="2. 使用UIAnimation的block回调时，需不需要使用__weak避免循环引用？为什么？"></a><a href="#h3-2">2. 使用UIAnimation的block回调时，需不需要使用__weak避免循环引用？为什么？</a></h3><h3 id="3-block属性是否可以用strong修饰？"><a href="#3-block属性是否可以用strong修饰？" class="headerlink" title="3. block属性是否可以用strong修饰？"></a><a href="#h3-3">3. block属性是否可以用strong修饰？</a></h3><h3 id="4-什么场景下才需要对变量使用-block"><a href="#4-什么场景下才需要对变量使用-block" class="headerlink" title="4. 什么场景下才需要对变量使用__block?"></a><a href="#h3-4">4. 什么场景下才需要对变量使用__block?</a></h3><h3 id="5-block-修改捕获变量除了用-block-还可以怎么做？有哪些局限性？"><a href="#5-block-修改捕获变量除了用-block-还可以怎么做？有哪些局限性？" class="headerlink" title="5. block 修改捕获变量除了用 __block 还可以怎么做？有哪些局限性？"></a><a href="#h3-5">5. block 修改捕获变量除了用 __block 还可以怎么做？有哪些局限性？</a></h3><span id="more"></span><hr><h3 id="h3-1">1. block的循环引用是如何造成的？</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">------------Light.h------------<br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Light</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *color;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^block)(<span class="hljs-keyword">void</span>);<br><span class="hljs-keyword">@end</span><br><br>------------Light.m------------<br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Light.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Light</span></span><br><span class="hljs-keyword">@end</span><br><br>------------main.m------------<br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Light.h&quot;</span></span><br><br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        Light *loveLight = [Light alloc] init];<br>        loveLight.color = <span class="hljs-string">@&quot;green&quot;</span>;<br>        <br>        loveLight.block = ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,loveLight.color);<br>        &#125;;<br>        <br>        loveLight.block();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在上面的代码中创建了一个Light（光）类，并声明两个属性color（颜色）及block。然后我们实例化一个对象loveLight并对其属性赋值，实现并调用block，造成循环引用。<br>然后我们通过clang代码，了解这段代码内部的部分实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  Light *loveLight;<br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, Light *_loveLight, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : loveLight(_loveLight) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(<span class="hljs-keyword">struct</span> __main_block_impl_0 *__cself) &#123;<br>    Light *loveLight = __cself-&gt;loveLight; <span class="hljs-comment">// bound by copy</span><br>    <span class="hljs-built_in">NSLog</span>((<span class="hljs-built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_yf_3v_c713x5898zz9d49t0rd140000gn_T_main_81cd17_mi_1,((<span class="hljs-built_in">NSString</span> *(*)(<span class="hljs-keyword">id</span>, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((<span class="hljs-keyword">id</span>)loveLight, sel_registerName(<span class="hljs-string">&quot;color&quot;</span>)));<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    _Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;loveLight, (<span class="hljs-keyword">void</span>*)src-&gt;loveLight, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>&#125;<br><br>...后省略<br></code></pre></td></tr></table></figure><p>通过clang后的源码我们可以知道：</p><ul><li>对象的创建本身就是强引用（默认strong修饰）。</li><li>对象对block属性赋值，在ARC下,block作为返回值时或者赋值给一个strong/copy修饰的对象会自动调用copy，<strong>loveLight强引用block</strong>。</li><li>对象的block在其内部捕获了对象本身，block在自动调用copy的时候，_Block_object_assign（clang源码最后一行）会根据捕获变量的所有权修饰符，来对变量的引用计数进行操作。此处loveLight本身是strong修饰，则引用计数+1，<strong>block强引用loveLight对象</strong>。</li><li>所以双方互相引用，造成了循环引用。</li></ul><p>同时面试中面试官还可能会询问你如何检测到内存泄漏，我们可以通过Instruments中的Leaks进行检测，也可以选择facebook发布的FBRetainCycleDetector内存泄漏检测工具。</p><hr><h3 id="h3-2">2. 使用UIView Animation的block回调时，是否需要考虑循环引用的问题？为什么？</h3><p>首先UIView Animation使用时，不需要考虑循环引用的问题。</p><p>UIKit将动画直接集成到UIView的类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持，并以类方法的形式提供接口。</p><p>而block造成循环引用的主要原因是对象与block的相互持有，UIView Animation的block本身处于类方法中，在使用时并不属于调用控制器。同时控制器也无法强引用一个类，所以不会造成循环引用的问题。</p><hr><h3 id="h3-3">3. block属性是否可以用strong修饰？</h3><p><del>block属性可以使用strong属性修饰符修饰，但是不推荐，会有内存泄漏的隐患。</del></p><p><del>首先，ARC中block用copy属性修饰符修饰是MRC时代延续的产物，提醒开发者可能存在的内存问题。同时copy的确是可以用strong来替代的。</del></p><p><del>我们都知道block在OC中有三种类型：</del><br><del>- _NSConcreateGlobalBlock 全局的静态block，不会访问任何外部变量。</del><br><del>- _NSConcreateStackBlock 栈区的block，当函数返回时会被销毁。</del><br><del>- _NSConcreateMallocBlock 堆区的block，当引用计数为0时被销毁。</del></p><p><del>block在MRC下可以存在于全局区、栈区和堆区，而在ARC下，block会自动从栈区拷贝到堆区（除了裸写block实现块），所以只存在于全局区和堆区。<br>所以对于栈区block，MRC下处于栈区，想在作用域外调用就得copy到堆区；ARC则自动copy堆区。</del></p><p><del>那么这个时候问题就来了，strong属性修饰符并不能拷贝，就会有野指针错区的可能，造成Crash。这种情况很少见，但是不代表不可能发生，所以最好还是使用copy属性修饰符。</del></p><p><strong>此处感谢@buaacyg的评论反馈，同时也对撰文的不严谨深表歉意。</strong></p><p>更正：</p><p>针对Block属性修饰符的问题在撰写的时候的确没有考虑周全，我们将在以下予以更正和解答。<br>首先，在以下情形中block会自动从栈拷贝到堆：</p><ul><li>1、当 block 调用 copy 方法时，如果 block 在栈上，会被拷贝到堆上；</li><li>2、当 block 作为函数返回值时，编译器自动将 block 作为 _Block_copy 函数，效果等同于直接调用 copy 方法；</li><li>3、当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于直接调用 copy 方法；</li><li>4、当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;</li></ul><p>那针对上述自动拷贝的情况我们做一个实验：</p><p>ARC下strong修饰block，且不引用外部变量，block类型为__NSGlobalBlock<br><img src="https://i.loli.net/2019/04/29/5cc6a1e28d862.png"><br>ARC下strong修饰block，引入外部变量，block类型为__NSMallocBlock<br><img src="https://i.loli.net/2019/04/29/5cc6a1e28f584.png"></p><p>所以由此就可以理解为ARC下strong修饰的block并没有处于栈区的可能，也就不存在作用域结束栈区内容销毁野指针的问题了。<br>但是为了保证修饰符和block特性的一致性，使用copy修饰符仍然是最为合适的。</p><hr><h3 id="h3-4">4. 什么场景下才需要对变量使用__block?</h3><p>赋值场景下使用__block，使用场景下不需要。<br>我们来对比下赋值场景和使用场景</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//赋值场景</span><br><span class="hljs-built_in">NSMutableArray</span> *__block array = <span class="hljs-literal">nil</span>;<br><br><span class="hljs-keyword">void</span>(^Block)(<span class="hljs-keyword">void</span>) = ^&#123;<br>    array = [<span class="hljs-built_in">NSMutableArray</span> array];<br>&#125;;<br><br>Block();<br>    <br><span class="hljs-comment">//使用场景</span><br><span class="hljs-built_in">NSMultableArray</span> *array = [<span class="hljs-built_in">NSMultableArray</span> array];<br><br><span class="hljs-keyword">void</span>(^Block)() = ^&#123;<br>    [array addObject:<span class="hljs-string">@&quot;1&quot;</span>];<br>&#125;;<br><br>Block();<br></code></pre></td></tr></table></figure><hr><h3 id="h3-5">5. block 修改捕获变量除了用 __block 还可以怎么做？有哪些局限性？</h3><ul><li>将变量声明为全局的或利用<code>static</code>修饰</li><li>也可以把变量声明为类的成员变量或者属性，访问同样不需要 <code>__block</code></li></ul><p><code>__block</code> 修饰的局部变量会随着 block 销毁而销毁，内存管理与 block 同步，全局/局部静态/全局静态，存在于程序的整个生命周期，成员变量的生命周期由其类控制</p><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#57;&#52;&#64;&#49;&#54;&#x33;&#46;&#x63;&#111;&#x6d;">&#x5f;&#49;&#x39;&#57;&#52;&#64;&#49;&#54;&#x33;&#46;&#x63;&#111;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS Sharing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS Sharing</tag>
      
      <tag>知识点</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【iOS Sharing】网络相关</title>
    <link href="/post/cacc0796.html"/>
    <url>/post/cacc0796.html</url>
    
    <content type="html"><![CDATA[<h2 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-Scoket-连接和-HTTP-连接的区别"><a href="#1-Scoket-连接和-HTTP-连接的区别" class="headerlink" title="1. Scoket 连接和 HTTP 连接的区别"></a><a href="#h3-1">1. Scoket 连接和 HTTP 连接的区别</a></h3><h3 id="2-关于-HTTP-的请求-GET-和-POST-的区别"><a href="#2-关于-HTTP-的请求-GET-和-POST-的区别" class="headerlink" title="2. 关于 HTTP 的请求 GET 和 POST 的区别"></a><a href="#h3-2">2. 关于 HTTP 的请求 GET 和 POST 的区别</a></h3><h3 id="3-HTTPS-加密过程与原理"><a href="#3-HTTPS-加密过程与原理" class="headerlink" title="3. HTTPS 加密过程与原理"></a><a href="#h3-3">3. HTTPS 加密过程与原理</a></h3><h3 id="4-Socket-原理"><a href="#4-Socket-原理" class="headerlink" title="4. Socket 原理"></a><a href="#h3-4">4. Socket 原理</a></h3><h3 id="5-关于-TCP-的慢启动特性"><a href="#5-关于-TCP-的慢启动特性" class="headerlink" title="5. 关于 TCP 的慢启动特性"></a><a href="#h3-5">5. 关于 TCP 的慢启动特性</a></h3><span id="more"></span><hr><h3 id="3-1">1. Scoket 连接和 HTTP 连接的区别</h3><ul><li>HTTP 协议是基于 TCP 连接的，是应用层协议，主要解决如何包装数据。Socket 是对 TCP/IP 协议的封装，Socket 本身并不是协议，而是一个调用接口（API），通过 Socket，我们才能使用 TCP/IP 协议<ul><li>HTTP：短连接，客户端向服务器发送一次请求，服务器响应后连接断开，节省资源。服务器不能主动给客户端响应（除非采用 HTTP 长连接技术），iOS 目前主要使用类 NSURLSession</li><li>Socket：长连接，客户端跟服务器端直接使用 Socket 进行连接，没有规定连接后断开，因此客户端和服务器段保持连接通道，双方可以主动发送数据，一般多用于游戏。Socket 默认连接超时时间是30秒，默认大小是8K（可以理解为一个数据包大小）</li></ul></li></ul><hr><h3 id="3-2">2. 关于 HTTP 的请求 GET 和 POST 的区别</h3><blockquote><p>参数传递：</p></blockquote><ul><li><p>GET：参数在地址后拼接，没有请求数据，不安全（因为所有参数都拼接在地址后面），不适合传输大量数据（长度有限制，为1024个字节）<br>GET 提交、请求的数据会附在 URL 之后，即把数据放置在 HTTP 协议头&lt;requestline&gt;中以分割URL和传输数据，多个参数用&amp;连接。如果数据是英文字母或数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密</p></li><li><p>POST：参数在请求数据区放着，相对 GET 请求更安全，并且数据大小没有限制。把提交的数据放置在 HTTP 包的包体&lt;request-body&gt;中</p></li></ul><blockquote><p>传输数据的大小：</p></blockquote><ul><li>GET 提交时，传输数据就会受到 URL 长度限制</li><li>POST 由于不是通过 URL 传值，理论上不受限，但一般服务器对于请求数据量大小有限制</li></ul><blockquote><p>安全性：</p></blockquote><ul><li>POST 的安全性要比 GET 的安全性高</li><li>通过 GET 提交数据，用户名和密码将明文出现在 URL 上，比如登陆界面有可能被浏览器缓存</li><li>HTTPS：安全超文本传输协议（Secure Hypertext Transfer Protocol），它是一个安全通信通道，基于 HTTP 开发，用于客户计算机和服务器之间交换信息，使用安全套结字层（SSI）进行信息交换，即 HTTP 的安全版</li></ul><hr><h3 id="3-3">3. HTTPS 加密过程与原理</h3><ul><li>服务器端用非对称加密(RSA)生成公钥和私钥</li><li>然后把公钥发给客户端, 服务器则保存私钥</li><li>客户端拿到公钥后, 会生成一个密钥, 这个密钥就是将来客户端和服务器用来通信的钥匙</li><li>然后客户端用公钥对密钥进行加密, 再发给服务器</li><li>服务器拿到客户端发来的加密后的密钥后, 再使用私钥解密密钥, 到此双方都获得通信的钥匙</li></ul><hr><h3 id="3-4">4. Socket 原理</h3><blockquote><p>Socket 概念: 套接字</p></blockquote><ul><li>套接字是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口</li><li>应用层通过传输层进行数据通信时，TCP 会遇到同时为多个应用程序进程提供并发服务的问题。多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP/IP 协议交互提供了套接字接口。应用层可以和传输层通过 Socket 接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务</li></ul><blockquote><p>Socket 建立连接: </p></blockquote><ul><li>建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket，另一个运行于服务器端，称为 ServerSocket</li><li>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认</li><li>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求</li><li>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求</li><li>连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求</li></ul><blockquote><p>Socket 连接与 TCP 连接</p></blockquote><ul><li>创建 Socket 连接时，可以指定使用的传输层协议，Socket 可以支持不同的传输层协议（TCP或UDP），当使用 TCP 协议进行连接时，该 Socket 连接就是一个 TCP 连接</li></ul><blockquote><p>Socket 连接与 HTTP 连接</p></blockquote><ul><li>由于通常情况下 Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态</li><li>而 HTT P连接使用的是<code>“请求—响应”</code>的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据</li><li>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是 Socket 连接，服务器就可以直接将数据传送给 客户端；若双方建立的是 HTTP 连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在<code>“询问”</code>服务器是否有新的数据，如果有就将数据传给客户端</li></ul><h3 id="3-5">5. 关于 TCP 的慢启动特性</h3><ul><li>TCP 在连接过程的三次握手完成后，开始传数据，并不是一开始向网络通道中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞</li><li>TCP 使用了一个叫慢启动阈值(<code>ssthresh</code>)的变量，一旦<code>cwnd&gt;=ssthresh</code>（大多数 TCP 的实现，通常大小都是65536）慢启动过程结束，拥塞避免阶段开始</li><li>拥塞避免：<code>cwnd</code>的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，<code>cwnd</code>的大小加1，<code>cwnd</code>的值就随着 RTT 开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值</li></ul><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#x39;&#57;&#x34;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#111;&#109;">&#95;&#x31;&#x39;&#57;&#x34;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS Sharing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS Sharing</tag>
      
      <tag>知识点</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【iOS Sharing】类相关</title>
    <link href="/post/bdcb3700.html"/>
    <url>/post/bdcb3700.html</url>
    
    <content type="html"><![CDATA[<h2 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1、请用一句话概述分类的概念，并阐述分类的优点。"><a href="#1、请用一句话概述分类的概念，并阐述分类的优点。" class="headerlink" title="1、请用一句话概述分类的概念，并阐述分类的优点。"></a><a href="#h3-1">1、请用一句话概述分类的概念，并阐述分类的优点。</a></h3><h3 id="2、多个同宿主分类中的都重写了一个同名方法，哪个分类的同名方法会生效？为什么？"><a href="#2、多个同宿主分类中的都重写了一个同名方法，哪个分类的同名方法会生效？为什么？" class="headerlink" title="2、多个同宿主分类中的都重写了一个同名方法，哪个分类的同名方法会生效？为什么？"></a><a href="#h3-2">2、多个同宿主分类中的都重写了一个同名方法，哪个分类的同名方法会生效？为什么？</a></h3><h3 id="3-Category、-Extension和继承的区别？"><a href="#3-Category、-Extension和继承的区别？" class="headerlink" title="3. Category、 Extension和继承的区别？"></a><a href="#h3-3">3. Category、 Extension和继承的区别？</a></h3><h3 id="4-isKindOfClass、isMemberOfClass作用分别是什么？"><a href="#4-isKindOfClass、isMemberOfClass作用分别是什么？" class="headerlink" title="4. isKindOfClass、isMemberOfClass作用分别是什么？"></a><a href="#h3-4">4. isKindOfClass、isMemberOfClass作用分别是什么？</a></h3><h3 id="5-load-和-initialize-的区别是什么？"><a href="#5-load-和-initialize-的区别是什么？" class="headerlink" title="5. +load 和 +initialize 的区别是什么？"></a><a href="#h3-5">5. +load 和 +initialize 的区别是什么？</a></h3><span id="more"></span><hr><h3 id="h3-1">1、请用一句话概述分类的概念，并阐述分类的优点。</h3>答：<p>概述：Objective-C中的分类是修饰模式的一种具体实现，主要作用是在不改变原有类的基础上，动态的为类扩展功能（添加方法）。</p><p>分类的优点</p><ul><li>声明私有方法</li><li>分解庞大的类文件</li><li>将Framework私有方法公开化</li><li>模拟多继承</li></ul><hr><h3 id="h3-2">2、多个同宿主分类中的都重写了一个同名方法，哪个分类的同名方法会生效？为什么？</h3>答：<p>运行时在处理分类时会倒序遍历分类数组，最先访问最后编译的类，最后编译的类的同名方法最终生效。</p><p>下面我们来看看源码解析：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">int</span> mcount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录方法的数量</span><br><span class="hljs-keyword">int</span> propcount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录属性的数量</span><br><span class="hljs-keyword">int</span> protocount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录协议的数量</span><br><span class="hljs-keyword">int</span> i = cats-&gt;count; <span class="hljs-comment">// 获取分类个数</span><br><span class="hljs-keyword">bool</span> fromBundle = <span class="hljs-literal">NO</span>; <span class="hljs-comment">// 记录是否是从 bundle 中取的</span><br><br><span class="hljs-keyword">while</span> (i--) &#123; <span class="hljs-comment">// 从后往前遍历,保证先取最后编译的类</span><br>    auto&amp;; <br>    entry = cats-&gt;list[i]; <span class="hljs-comment">// 分类,locstamped_category_t 类型</span><br>    <br>    <span class="hljs-comment">// 取出分类中的方法列表;如果是元类,取得的是类方法列表;否则取得的是实例方法列表</span><br>    method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);<br>    <span class="hljs-keyword">if</span> (mlist) &#123;<br>        mlists[mcount++] = mlist; <span class="hljs-comment">// 将方法列表放入 mlists 方法列表数组中</span><br>        fromBundle |= entry.hi-&gt;isBundle(); <span class="hljs-comment">// 分类的头部信息中存储了是否是 bundle,将其记住</span><br>    &#125;<br><br>    <span class="hljs-comment">// 取出分类中的属性列表,如果是元类,取得是nil</span><br>    property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta);<br>    <span class="hljs-keyword">if</span> (proplist) &#123;<br>        proplists[propcount++] = proplist; <span class="hljs-comment">// 将属性列表放入 proplists 属性列表数组中</span><br>    &#125;<br><br>    <span class="hljs-comment">// 取出分类中遵循的协议列表</span><br>    protocol_list_t *protolist = entry.cat-&gt;protocols;<br>    <span class="hljs-keyword">if</span> (protolist) &#123;<br>        protolists[protocount++] = protolist; <span class="hljs-comment">// 将协议列表放入 protolists 协议列表数组中</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><hr><h3 id="h3-3">3. Category、 Extension和继承的区别？</h3><ul><li><code>Category</code>有名字，<code>Extension</code>没有名字，是一种特殊的<code>Category</code>。</li><li><code>Category</code>只能扩展方法（属性仅仅是声明，并没真正实现），<code>Extension</code>可以扩展属性、成员变量和方法。</li><li>继承可以增加，修改或者删除方法，并且可以增加属性。</li></ul><hr><h3 id="h3-4">4. isKindOfClass、isMemberOfClass作用分别是什么？</h3><ul><li><code>isKindOfClass</code>：作用是某个对象属于某个类型或者继承自某类型。</li><li><code>isMemberOfClass</code>：某个对象确切属于某个类型。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//Dog继承自Animal</span><br>Animal *a = [Animal new];<br>Dog *d = [Dog new];<br>        <br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d&quot;</span>,[a isKindOfClass:[Animal <span class="hljs-keyword">class</span>]]);    <span class="hljs-comment">//1</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d&quot;</span>,[a isMemberOfClass:[Animal <span class="hljs-keyword">class</span>]]);  <span class="hljs-comment">//1</span><br>        <br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d&quot;</span>,[d isKindOfClass:[Animal <span class="hljs-keyword">class</span>]]);    <span class="hljs-comment">//1</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d&quot;</span>,[d isMemberOfClass:[Animal <span class="hljs-keyword">class</span>]]);  <span class="hljs-comment">//0</span><br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d&quot;</span>,[d isKindOfClass:[Dog <span class="hljs-keyword">class</span>]]);       <span class="hljs-comment">//1</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d&quot;</span>,[d isMemberOfClass:[Dog <span class="hljs-keyword">class</span>]]);     <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p><strong>Warning:</strong><br>不要对NSArray、NSString等Apple实现的类进行<code>isMemberOfClass</code>操作，得出的结果是<code>false</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSString</span> *s = <span class="hljs-string">@&quot;&quot;</span>;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d&quot;</span>,[s isMemberOfClass:[<span class="hljs-built_in">NSString</span> <span class="hljs-keyword">class</span>]]);  <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><p>Apple使用类簇的方式实现的这些类，所以s不是<code>NSString</code>类的实例。</p><h3 id="h3-5">5. +load 和 +initialize 的区别是什么？</h3><blockquote><p>+(void)load;</p></blockquote><p>+load 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。</p><blockquote><p>+(void)initialize;</p></blockquote><p>+initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。</p><hr><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p><strong>邮箱：</strong> adrenine@163.com</br></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS Sharing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS Sharing</tag>
      
      <tag>知识点</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【iOS Sharing】多线程相关</title>
    <link href="/post/23afa2a3.html"/>
    <url>/post/23afa2a3.html</url>
    
    <content type="html"><![CDATA[<h2 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1、运行以下GCD多线程代码，控制台将打印什么"><a href="#1、运行以下GCD多线程代码，控制台将打印什么" class="headerlink" title="1、运行以下GCD多线程代码，控制台将打印什么?"></a><a href="#h3-1">1、运行以下GCD多线程代码，控制台将打印什么?</a></h3><h3 id="2、串行同步、串行异步、并发同步、并发异步各自会开几条线程？"><a href="#2、串行同步、串行异步、并发同步、并发异步各自会开几条线程？" class="headerlink" title="2、串行同步、串行异步、并发同步、并发异步各自会开几条线程？"></a><a href="#h3-2">2、串行同步、串行异步、并发同步、并发异步各自会开几条线程？</a></h3><h3 id="3、为什么需要在主线程更新UI？"><a href="#3、为什么需要在主线程更新UI？" class="headerlink" title="3、为什么需要在主线程更新UI？"></a><a href="#h3-3">3、为什么需要在主线程更新UI？</a></h3><h3 id="4、iOS中如何用多线程实现多读单写"><a href="#4、iOS中如何用多线程实现多读单写" class="headerlink" title="4、iOS中如何用多线程实现多读单写?"></a><a href="#h3-4">4、iOS中如何用多线程实现多读单写?</a></h3><h3 id="5、iOS多线程中有多少种方式可以做到等待前面线程执行完毕再执行后面的线程？"><a href="#5、iOS多线程中有多少种方式可以做到等待前面线程执行完毕再执行后面的线程？" class="headerlink" title="5、iOS多线程中有多少种方式可以做到等待前面线程执行完毕再执行后面的线程？"></a><a href="#h3-5">5、iOS多线程中有多少种方式可以做到等待前面线程执行完毕再执行后面的线程？</a></h3><span id="more"></span><hr><h3 id="h3-1">1、运行以下GCD多线程代码，控制台将打印什么?</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_queue_t</span> gQueue= dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br><span class="hljs-built_in">dispatch_sync</span>(gQueue, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>    <span class="hljs-built_in">dispatch_sync</span>(gQueue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>     &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4&quot;</span>);<br>    &#125;);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;5&quot;</span>);<br></code></pre></td></tr></table></figure><p>答案：12345</p><p>首先打印1，全局队列本质是并发队列也就是并发同步，同步任务不开起线程，在主线程执行打印2。<br>然后全局队列执行同步任务，依旧不开启线程，在主线程执行打印3。<br>同步任务完成，依旧存在于全局队列同步执行，打印4.<br>同步任务完成，打印5。</p><hr><h3 id="h3-2">2、串行同步、串行异步、并发同步、并发异步各自会开几条线程？</h3>答：<p><strong>首先了解一些基本概念:</strong> </p><ul><li>同步：只能在<strong>当前</strong>线程中执行任务，<strong>不具备</strong>开启新线程的能力</li><li>异步：可以在<strong>新的</strong>线程中执行任务，<strong>具备</strong>开启新线程的能力</li><li>串行：一个任务执行完毕后，再执行下一个任务</li><li>并发：多个任务并发（同时）执行</li></ul><p><img src="https://i.loli.net/2019/04/04/5ca5a36b7307e.png"><br><img src="https://i.loli.net/2019/04/04/5ca5a36b84774.png"></p><p><img src="https://i.loli.net/2019/04/04/5ca5a561c538a.jpeg"></p><p><strong>总结</strong></p><ul><li>串行同步不开新线程</li><li>串行异步开启一条新线程</li><li>并发同步不开新线程</li><li>并发异步开启多条</li></ul><hr><h3 id="h3-3">3、为什么需要在主线程更新UI？</h3>答：<ul><li>安全</br></li></ul><p>在非主线程中更新UI就会有多个线程同时操作一个控件的可能，造成最后更新的结果不符合预期</p><ul><li>效率 </br></li></ul><p>多线程本身就是为了并发处理以达到高效的目的，但是刷新UI使用并发会造成安全问题，要解决上面的安全问题，那就需要给控件加锁，但是加锁必然会造成额外的开销，同时开新的线程本身就有一定的开销，所以不如直接在主线程中执行更新操作。</p><hr><h3 id="h3-4">4、iOS中如何用多线程实现多读单写?</h3>答：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CustomDictionary</span> ()</span><br><br><span class="hljs-comment">//多线程需要访问的数据量</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableDictionary</span> *dataDic;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//模拟场景，允许多个线程同时访问字典，但是只有一个线程可以写字典</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CustomDictionary</span> </span>&#123;<br>    <span class="hljs-comment">//定义一个并发队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> _concurrent_queue;<br><br>&#125;<br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>        _concurrent_queue = dispatch_queue_create(<span class="hljs-string">&quot;com.mf.read_write_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>        _dataDic = @&#123;&#125;.mutableCopy;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">// 读取数据，并发操作</span><br>- (<span class="hljs-keyword">id</span>)objectForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    __block <span class="hljs-keyword">id</span> obj;<br>    <span class="hljs-comment">//同步读取数据</span><br>    <span class="hljs-built_in">dispatch_sync</span>(_concurrent_queue, ^&#123;<br>        obj = [<span class="hljs-keyword">self</span>.dataDic objectForKey:key];<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> obj;<br>    <br>&#125;<br><br><span class="hljs-comment">// 写入数据，异步栅栏</span><br>- (<span class="hljs-keyword">void</span>)setObject:(<span class="hljs-keyword">id</span>)obj forKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-comment">//异步栅栏调用设置数据</span><br>    dispatch_barrier_async(_concurrent_queue, ^&#123;<br>        [<span class="hljs-keyword">self</span>.dataDic setObject:obj forKey:key];<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure><hr><h3 id="h3-5">5、iOS多线程中有多少种方式可以做到等待前面线程执行完毕再执行后面的线程？</h3>答：<ul><li><p>barrier </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;com.mf.barrier&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>&#125;);<br>    <br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>&#125;);<br>    <br>dispatch_barrier_async(queue, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;等待任务1，2上面执行完毕&quot;</span>);<br>&#125;);<br>    <br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>&#125;);<br>    <br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>group notify </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 全局变量group</span><br>dispatch_group_t group = dispatch_group_create();<br><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 进入组（进入组和离开组必须成对出现, 否则会造成死锁）</span><br>dispatch_group_enter(group);<br>dispatch_group_async(group, queue, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-comment">//离开组</span><br>    dispatch_group_leave(group);<br>&#125;);<br><br>dispatch_group_enter(group);<br>dispatch_group_async(group, queue, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>    dispatch_group_leave(group);<br>&#125;);<br><br>dispatch_group_notify(group, queue, ^&#123;  <span class="hljs-comment">// 监听组里所有线程完成的情况</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务1，2已完成&quot;</span>);<br>    &#125;);    <br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>NSOperationQueue Dependency</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//创建队列</span><br>    <span class="hljs-built_in">NSOperationQueue</span> *queue=[[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    <span class="hljs-comment">//创建操作</span><br>    <span class="hljs-built_in">NSBlockOperation</span> *operation1=[<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^()&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;执行第1次操作，线程：%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *operation2=[<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^()&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;执行第2次操作，线程：%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *operation3=[<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^()&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;执行第3次操作，线程：%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;];<br>    <span class="hljs-comment">//添加依赖</span><br>    [operation1 addDependency:operation2];<br>    [operation2 addDependency:operation3];<br>    <span class="hljs-comment">//将操作添加到队列中去</span><br>    [queue addOperation:operation1];<br>    [queue addOperation:operation2];<br>    [queue addOperation:operation3];<br></code></pre></td></tr></table></figure><ul><li>semaphore</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/*</span><br><span class="hljs-comment">比如说我们需要请求三张元素图，拼合成一张海报。我们需要先对元素图进行请求而后才能合成海报，这就形成了依赖关系。我们通过semaphore限制资源数为3，供请求元素图使用，待请求完成后，释放信号量，便能走到合成的耗时操作。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//创建信号量，参数：信号量的初值，如果小于0则会返回NULL</span><br>dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">3</span>);<br>    <br><span class="hljs-comment">//元素图1</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>    <span class="hljs-comment">//等待降低信号量</span><br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;请求第1张元素图&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;第1张元素图Get&quot;</span>);<br>    <span class="hljs-comment">//提高信号量</span><br>    dispatch_semaphore_signal(semaphore);<br>&#125;);<br>    <br><span class="hljs-comment">//元素图2</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;请求第2张元素图&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;第2张元素图Get&quot;</span>);<br>    dispatch_semaphore_signal(semaphore);<br>&#125;);<br>    <br><span class="hljs-comment">//元素图3</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;请求第3张元素图&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;第3张元素图Get&quot;</span>);<br>    dispatch_semaphore_signal(semaphore);<br>&#125;);<br>    <br><span class="hljs-comment">//合成海报</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;合成海报&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;海报Get&quot;</span>);<br>    dispatch_semaphore_signal(semaphore);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></br><br>正常的使用顺序是<strong>先降低然后再提高</strong>，这两个函数通常成对使用。</p><hr><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p><strong>邮箱：</strong> adrenine@163.com</br></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS Sharing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS Sharing</tag>
      
      <tag>知识点</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS错误与警告目录</title>
    <link href="/post/e2m9iu6d.html"/>
    <url>/post/e2m9iu6d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h4 id="nbsp-nbsp-【iOS-Sharing】系列目录"><a href="#nbsp-nbsp-【iOS-Sharing】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS Sharing】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjuia973.html">【iOS Sharing】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS笔记】系列目录"><a href="#nbsp-nbsp-【iOS笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【靠谱程序员】系列目录"><a href="#nbsp-nbsp-【靠谱程序员】系列目录" class="headerlink" title="&nbsp;&nbsp;【靠谱程序员】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS警告与报错】系列目录"><a href="#nbsp-nbsp-【iOS警告与报错】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS警告与报错】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2m9iu6d.html">【iOS警告与报错】系列目录</a></h4><h4 id="nbsp-nbsp-【开发笔记】系列目录"><a href="#nbsp-nbsp-【开发笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【开发笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【Leet-Code】系列目录"><a href="#nbsp-nbsp-【Leet-Code】系列目录" class="headerlink" title="&nbsp;&nbsp;【Leet Code】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/d305db71.html">【Leet Code】系列目录</a></h4><h4 id="nbsp-nbsp-【Coding】系列目录"><a href="#nbsp-nbsp-【Coding】系列目录" class="headerlink" title="&nbsp;&nbsp;【Coding】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ab23a973.html">【Coding】系列目录</a></h4><hr><h3 id="【iOS错误与警告】系列目录"><a href="#【iOS错误与警告】系列目录" class="headerlink" title="【iOS错误与警告】系列目录"></a>【iOS错误与警告】系列目录</h3><h4 id="nbsp-nbsp-【-1】iPad-Multitasking-support-requires-xxx"><a href="#nbsp-nbsp-【-1】iPad-Multitasking-support-requires-xxx" class="headerlink" title="&nbsp;&nbsp;【#1】iPad Multitasking support requires xxx"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/emn1h26d.html">【#1】iPad Multitasking support requires xxx</a></h4><h4 id="nbsp-nbsp-【-2】CUICatalog-Invalid-asset-name-supplied"><a href="#nbsp-nbsp-【-2】CUICatalog-Invalid-asset-name-supplied" class="headerlink" title="&nbsp;&nbsp;【#2】CUICatalog: Invalid asset name supplied:"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/nmuyt54s.html">【#2】CUICatalog: Invalid asset name supplied:</a></h4><h4 id="nbsp-nbsp-【-3】Build-for-iOS-but-xxx-build-for-iOS-and-iOS-Simulator"><a href="#nbsp-nbsp-【-3】Build-for-iOS-but-xxx-build-for-iOS-and-iOS-Simulator" class="headerlink" title="&nbsp;&nbsp;【#3】Build for iOS but xxx build for iOS and iOS-Simulator"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/oknmhy67.html">【#3】Build for iOS but xxx build for iOS and iOS-Simulator</a></h4><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#49;&#57;&#57;&#52;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109;">&#95;&#49;&#57;&#57;&#52;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS错误与警告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>目录</tag>
      
      <tag>iOS错误与警告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【iOS Sharing】方法相关</title>
    <link href="/post/54a89235.html"/>
    <url>/post/54a89235.html</url>
    
    <content type="html"><![CDATA[<h2 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1、实例方法去哪里找？"><a href="#1、实例方法去哪里找？" class="headerlink" title="1、实例方法去哪里找？"></a><a href="#h3-1">1、实例方法去哪里找？</a></h3><h3 id="2、类方法去哪里找？"><a href="#2、类方法去哪里找？" class="headerlink" title="2、类方法去哪里找？"></a><a href="#h3-2">2、类方法去哪里找？</a></h3><h3 id="3、分类的方法具体是在什么时候添加到类的方法列表中？"><a href="#3、分类的方法具体是在什么时候添加到类的方法列表中？" class="headerlink" title="3、分类的方法具体是在什么时候添加到类的方法列表中？"></a><a href="#h3-3">3、分类的方法具体是在什么时候添加到类的方法列表中？</a></h3><h3 id="4、class-addMethod-都需要什么参数"><a href="#4、class-addMethod-都需要什么参数" class="headerlink" title="4、class_addMethod()都需要什么参数?"></a><a href="#h3-4">4、class_addMethod()都需要什么参数?</a></h3><h3 id="5、函数四要素都是什么？"><a href="#5、函数四要素都是什么？" class="headerlink" title="5、函数四要素都是什么？"></a><a href="#h3-5">5、函数四要素都是什么？</a></h3><span id="more"></span><hr><h3 id="h3-1">1、实例方法去哪里找？</h3>答：其所属的类的方法表<hr><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>问：oc是如何找到需要执行哪个方法的？</br><br>答：当需要执行某个实例方法的时候（类方法类似），oc会先去该类的方法的缓存列表里面查找，若找到了，则执行，否则，去该类的方法列表中查找是否存在该方法，存在，执行该方法并更新方法缓存列表，否则，去该父类缓存以及父类方法列表查找，直到根类，若还未找到，则启用动态解析以及消息转发流程，若还是失败，报unrecognized selector异常。</p><p><img src="https://i.loli.net/2019/03/29/5c9dcfbd2b74c.jpg" alt="详细流程"><br>感谢大佬提供的流程图</p><hr><h3 id="h3-2">2、类方法去哪里找？</h3><p>答：<br>见<a href="#h3-1">1、类方法去哪里找？</a>拓展</p><hr><h3 id="h3-3">3、分类的方法具体是在什么时候添加到类的方法列表中？</h3>答：类在编译后会以 class_ro_t 的结构把类的信息存储在 bits 里，运行时的 realizeClass 之后，会把 ro 中的所有信息拷贝到 bits 的 data 内，即以 class_rw_t 的形式存在，分类里的方法即在这个时候添加到类的方法表里，并在方法表数组的最前面<hr><h3 id="h3-4">4、class_addMethod()都需要什么参数?</h3>答：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Adds a new method to a class with a given name and implementation.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @param cls The class to which to add a method.</span><br><span class="hljs-comment">* @param name A selector that specifies the name of the method being added.</span><br><span class="hljs-comment">* @param imp A function which is the implementation of the new method. The function must take at least two arguments—self and _cmd.</span><br><span class="hljs-comment">* @param types An array of characters that describe the types of the arguments to the method.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @return YES if the method was added successfully, otherwise NO</span><br><span class="hljs-comment">* (for example, the class already contains a method implementation with that name).</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @note class_addMethod will add an override of a superclass&#x27;s implementation,</span><br><span class="hljs-comment">* but will not replace an existing implementation in this class.</span><br><span class="hljs-comment">* To change an existing implementation, use method_setImplementation.</span><br><span class="hljs-comment">*/</span><br>OBJC_EXPORT <span class="hljs-built_in">BOOL</span> class_addMethod(Class cls, SEL name, IMP imp,<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *types)<br>__OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);<br><br></code></pre></td></tr></table></figure><ul><li>给类添加一个新的方法和该方法的具体实现</li><li>BOOL: 返回值，YES ——-方法添加成功 NO ——–方法添加失败</li><li>Class cls: 将要给添加方法的类，传的类型 ［类名 class］</li><li>SEL name: 将要添加的方法名，传的类型  @selector(方法名)</li><li>IMP imp：实现这个方法的函数 ，传的类型  <ul><li>1、C语言写法：（IMP）方法名 </li><li>2、OC的写法：class_getMethodImplementation(self,@selector(方法名：))</li></ul></li><li>const char *types：表示我们要添加的方法的返回值和参数</li><li>“v@: @”：<ul><li>‘v’是添加方法无返回值   </li><li>‘@’表示是id(也就是要添加的类) </li><li>‘：’表示添加的方法类型  </li><li>‘@’表示参数类型</li></ul></li></ul><p>const char *types含义表：</br></p><table><thead><tr><th>Code</th><th>Meaning</th></tr></thead><tbody><tr><td>c</td><td>A char</td></tr><tr><td>i</td><td>An int</td></tr><tr><td>s</td><td>A short</td></tr><tr><td>l</td><td>A long l is treated as a 32-bit quantity on 64-bit programs.</td></tr><tr><td>q</td><td>A long long</td></tr><tr><td>C</td><td>An unsigned char</td></tr><tr><td>I</td><td>An unsigned int</td></tr><tr><td>S</td><td>An unsigned short</td></tr><tr><td>L</td><td>An unsigned long</td></tr><tr><td>Q</td><td>An unsigned long long</td></tr><tr><td>f</td><td>A float</td></tr><tr><td>d</td><td>A double</td></tr><tr><td>B</td><td>A C++ bool or a C99 _Bool</td></tr><tr><td>v</td><td>A void</td></tr><tr><td>*</td><td>A character string (char *)</td></tr><tr><td>@</td><td>An object (whether statically typed or typed id)</td></tr><tr><td>#</td><td>A class object (Class)</td></tr><tr><td>:</td><td>A method selector (SEL)</td></tr><tr><td>[array type]</td><td>An array</td></tr><tr><td>{name=type…}</td><td>A structure</td></tr><tr><td>(name=type…)</td><td>A union</td></tr><tr><td>bnum</td><td>A bit field of num bits</td></tr><tr><td>^type</td><td>A pointer to type</td></tr><tr><td>?</td><td>An unknown type (among other things, this code is used for function pointers)</td></tr></tbody></table><p><strong>注意：</strong></br><br>用这个方法添加的方法是无法直接调用的，必须用performSelector：调用。<br>因为performSelector是运行时系统负责去找方法的，在编译时候不做任何校验；如果直接调用编译是会自动校验。<br>添加方法是在运行时添加的，你在编译的时候还没有这个本类方法，所以当然不行。</p><h3 id='h3-5'>5、函数四要素都是什么？</h3>答：函数名，函数参数，参数类型，返回值类型（**PS:ObjC一般叫方法，不叫函数**）<hr><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p><strong>邮箱：</strong> adrenine@163.com</br></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li><li>** </li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS Sharing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS Sharing</tag>
      
      <tag>知识点</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【iOS Sharing】isa相关</title>
    <link href="/post/6de7ode7.html"/>
    <url>/post/6de7ode7.html</url>
    
    <content type="html"><![CDATA[<h2 id="【iOS笔记】系列目录"><a href="#【iOS笔记】系列目录" class="headerlink" title="【iOS笔记】系列目录"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h2><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1、Runtime存在的意义是什么"><a href="#1、Runtime存在的意义是什么" class="headerlink" title="1、Runtime存在的意义是什么?"></a><a href="#h3-1">1、Runtime存在的意义是什么?</a></h3><h3 id="2、根元类的isa指针指向谁"><a href="#2、根元类的isa指针指向谁" class="headerlink" title="2、根元类的isa指针指向谁?"></a><a href="#h3-2">2、根元类的isa指针指向谁?</a></h3><h3 id="3、根元类的superClass指针指向谁？"><a href="#3、根元类的superClass指针指向谁？" class="headerlink" title="3、根元类的superClass指针指向谁？"></a><a href="#h3-3">3、根元类的superClass指针指向谁？</a></h3><h3 id="4、isa指针有几种类型？"><a href="#4、isa指针有几种类型？" class="headerlink" title="4、isa指针有几种类型？"></a><a href="#h3-4">4、isa指针有几种类型？</a></h3><h3 id="5、id、self、super-它们从语法上有什么区别？"><a href="#5、id、self、super-它们从语法上有什么区别？" class="headerlink" title="5、id、self、super 它们从语法上有什么区别？"></a><a href="#h3-5">5、id、self、super 它们从语法上有什么区别？</a></h3><span id="more"></span><hr><h3 id="h3-1">1、Runtime存在的意义是什么？</h3>答：Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。因此，只有编译器是不够的，我们还需要一个运行时系统(Runtime system)来处理编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个Objc运行框架的一块基石。<p>平时编写的OC代码，底层都是由他实现的，如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc">[receiver message];<br><span class="hljs-comment">//底层运行时会被编译器转化为：</span><br>objc_msgSend(receiver, selector)<br><span class="hljs-comment">//如果其还有参数比如：</span><br>[receiver message:(<span class="hljs-keyword">id</span>)arg...];<br><span class="hljs-comment">//底层运行时会被编译器转化为：</span><br>objc_msgSend(receiver, selector, arg1, arg2, ...)<br><br></code></pre></td></tr></table></figure><hr><h3 id="h3-2">2、根元类的isa指针指向谁？</h3>答： 见下一问<hr><h3 id="h3-3">3、根元类的superClass指针指向谁？</h3>答：这两题一起回答。首先看下图：<p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a4d7604d9975b?w=986&h=1010&f=jpeg&s=102113" alt="nsobject"></p><p>先说几个概念:</p><ul><li>（1）supercalss<br>父类</li><li>（2）subclass<br>子类</li><li>（3）isa<br>概念不好说，官方文档说的也不清晰。作用是根据 isa 指针就可以找到对象所属的类，但是isa指针在代码运行时并不总指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型还是需要用对象的 -class 方法。（PS:KVO 的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实类型。）</li><li>（4）class<br>类，一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。（一个实例对象是一个类的实例）</li><li>（5）meta class<br>元类，Objc 类本身也是一个对象<br>，类对象所属的类就叫做元类（一个类是元类的实例）</br></li></ul><hr><p><strong>第一列</strong><br>类的实例变量，如：[Person new]或者[[Person alloc] init]出来的对象；</br><br><strong>第二列</strong><br>类本身，存放父类指针、类名、成员变量、方法、缓存以及附属的协议的信息；</br><br><strong>第三列</strong><br>元类</br></p><ul><li>（1）isa路线：<ul><li>实例对象的isa指向Class</li><li>Class的isa指向Meta Class</li><li>Meta Class的isa指向根元类Root Meta Class</li><li>根元类的isa指向自己</br></li></ul></li><li>（2）superclass路线：</br><ul><li>实例对象没有superclass ；</br></li><li>实例对象所在的类，存在superclass，类的superclass后面会指向Root Class，Root Class的super Class是nil；</br></li><li>元类也存在superclass，元类的superclass后面会指向Root Meta Class，而Root Meta Class的superclass却是Root Class。</br></li></ul></li></ul><p>所以：</p><ul><li>根元类的isa指针指向自己</li><li>根元类的superclass指向root class</li><li>根类的isa指向根元类</li><li>根类的superclass指向nil</li></ul><hr><p>附旧版Class结构：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_class *Class;<br>Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下：<br><span class="hljs-keyword">struct</span> objc_class &#123;<br>    Class isa  OBJC_ISA_AVAILABILITY;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !__OBJC2__</span><br>    Class super_class                                        OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name                                         OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> version                                             OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> info                                                OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125; OBJC2_UNAVAILABLE;<br><br></code></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/// An opaque type that represents an Objective-C class.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_class *Class;<br><span class="hljs-comment">/// A pointer to an instance of a class.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_object *<span class="hljs-keyword">id</span>;<br><br></code></pre></td></tr></table></figure><ul><li><p>Class是一个指向objc_class（类）结构体的指针，而id是一个指向objc_object（对象）结构体的指针。</p></li><li><p>objec_object（对象）中isa指针指向的类结构称为objec_class（该对象的类），其中存放着普通成员变量与对象方法 （“-”开头的方法）。</p></li><li><p>objec_class（类）中isa指针指向的类结构称为metaclass（该类的元类），其中存放着static类型的成员变量与static类型的方法 （“+”开头的方法）。</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a536128859601?w=1242&h=2688&f=png&s=682226" alt="objc-old"><br>新版Class</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a536574fa230c?w=1242&h=2688&f=png&s=718638" alt="objc-new"></p><hr><h3 id="h3-4">4、isa指针有几种类型？</h3>答：isa指针分，指针类型和非指针类型，32位只做地址保存，非嵌入式64位架构下，包含除类地址外的其他信息。<p><img src="https://i.loli.net/2019/05/29/5cee52c02156d48566.jpeg" alt="isa指针类型"></p><hr><h3 id="h3-5">5、id、self、super 它们从语法上有什么区别？</h3><ul><li>id 可作为方法的返回值类型、参数类型，以及变量的类型</li><li>self 可以用来调用方法，在实例方法中代表当前类的实例，在类方法中代表当前类，多态的一个对象, 它只能作为参数传递，不能作为类型使用，另外它也是消息发送过程中第一个默认参数</li><li>super 为编译器的一个关键字，告知编译器在调用方法时从父类的方法表中寻找</li></ul><hr><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p><strong>邮箱：</strong> adrenine@163.com</br></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS Sharing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS Sharing</tag>
      
      <tag>知识点</tag>
      
      <tag>面试</tag>
      
      <tag>isa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coding系列目录</title>
    <link href="/post/ab23a973.html"/>
    <url>/post/ab23a973.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h4 id="nbsp-nbsp-【iOS-Sharing】系列目录"><a href="#nbsp-nbsp-【iOS-Sharing】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS Sharing】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjuia973.html">【iOS Sharing】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS笔记】系列目录"><a href="#nbsp-nbsp-【iOS笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【靠谱程序员】系列目录"><a href="#nbsp-nbsp-【靠谱程序员】系列目录" class="headerlink" title="&nbsp;&nbsp;【靠谱程序员】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS警告与报错】系列目录"><a href="#nbsp-nbsp-【iOS警告与报错】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS警告与报错】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2m9iu6d.html">【iOS警告与报错】系列目录</a></h4><h4 id="nbsp-nbsp-【开发笔记】系列目录"><a href="#nbsp-nbsp-【开发笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【开发笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【Leet-Code】系列目录"><a href="#nbsp-nbsp-【Leet-Code】系列目录" class="headerlink" title="&nbsp;&nbsp;【Leet Code】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/d305db71.html">【Leet Code】系列目录</a></h4><h4 id="nbsp-nbsp-【Coding】系列目录"><a href="#nbsp-nbsp-【Coding】系列目录" class="headerlink" title="&nbsp;&nbsp;【Coding】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ab23a973.html">【Coding】系列目录</a></h4><hr><h3 id="【Coding】系列目录"><a href="#【Coding】系列目录" class="headerlink" title="【Coding】系列目录"></a><a href="https://adrenine.github.io/post/ab23a973.html">【Coding】系列目录</a></h3><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#57;&#x34;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#109;">&#x5f;&#49;&#x39;&#57;&#x34;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>目录</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发笔记系列目录</title>
    <link href="/post/a9ea42fe.html"/>
    <url>/post/a9ea42fe.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h4 id="nbsp-nbsp-【iOS-Sharing】系列目录"><a href="#nbsp-nbsp-【iOS-Sharing】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS Sharing】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjuia973.html">【iOS Sharing】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS笔记】系列目录"><a href="#nbsp-nbsp-【iOS笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【靠谱程序员】系列目录"><a href="#nbsp-nbsp-【靠谱程序员】系列目录" class="headerlink" title="&nbsp;&nbsp;【靠谱程序员】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS警告与报错】系列目录"><a href="#nbsp-nbsp-【iOS警告与报错】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS警告与报错】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2m9iu6d.html">【iOS警告与报错】系列目录</a></h4><h4 id="nbsp-nbsp-【开发笔记】系列目录"><a href="#nbsp-nbsp-【开发笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【开发笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【Leet-Code】系列目录"><a href="#nbsp-nbsp-【Leet-Code】系列目录" class="headerlink" title="&nbsp;&nbsp;【Leet Code】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/d305db71.html">【Leet Code】系列目录</a></h4><h4 id="nbsp-nbsp-【Coding】系列目录"><a href="#nbsp-nbsp-【Coding】系列目录" class="headerlink" title="&nbsp;&nbsp;【Coding】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ab23a973.html">【Coding】系列目录</a></h4><hr><h3 id="【开发笔记】系列目录"><a href="#【开发笔记】系列目录" class="headerlink" title="【开发笔记】系列目录"></a>【开发笔记】系列目录</h3><h4 id="nbsp-nbsp-【-1】Mac生成多个ssh并配置不同域名"><a href="#nbsp-nbsp-【-1】Mac生成多个ssh并配置不同域名" class="headerlink" title="&nbsp;&nbsp;【#1】Mac生成多个ssh并配置不同域名"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/4a6f7eb6.html">【#1】Mac生成多个ssh并配置不同域名</a></h4><h4 id="nbsp-nbsp-【-2】使用Wireshark抓包"><a href="#nbsp-nbsp-【-2】使用Wireshark抓包" class="headerlink" title="&nbsp;&nbsp;【#2】使用Wireshark抓包"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/b24af2ae.html">【#2】使用Wireshark抓包</a></h4><h4 id="nbsp-nbsp-【-3】结构体字节对齐"><a href="#nbsp-nbsp-【-3】结构体字节对齐" class="headerlink" title="&nbsp;&nbsp;【#3】结构体字节对齐"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/pfe2aew.html">【#3】结构体字节对齐</a></h4><h4 id="nbsp-nbsp-【-4】git撤回commit与push"><a href="#nbsp-nbsp-【-4】git撤回commit与push" class="headerlink" title="&nbsp;&nbsp;【#4】git撤回commit与push"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/afe2feq.html">【#4】git撤回commit与push</a></h4><h4 id="nbsp-nbsp-【-5】TCP三次握手与四次挥手"><a href="#nbsp-nbsp-【-5】TCP三次握手与四次挥手" class="headerlink" title="&nbsp;&nbsp;【#5】TCP三次握手与四次挥手"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/gkea24bn.html">【#5】TCP三次握手与四次挥手</a></h4><h4 id="nbsp-nbsp-【-6】Hexo配置"><a href="#nbsp-nbsp-【-6】Hexo配置" class="headerlink" title="&nbsp;&nbsp;【#6】Hexo配置"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ef4ake7i.html">【#6】Hexo配置</a></h4><h4 id="nbsp-nbsp-【-7】Http2-0了解"><a href="#nbsp-nbsp-【-7】Http2-0了解" class="headerlink" title="&nbsp;&nbsp;【#7】Http2.0了解"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/4abpi8ft.html">【#7】Http2.0了解</a></h4><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#x39;&#x39;&#52;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;">&#95;&#x31;&#x39;&#x39;&#52;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>目录</tag>
      
      <tag>开发笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS Sharing系列目录</title>
    <link href="/post/hjuia973.html"/>
    <url>/post/hjuia973.html</url>
    
    <content type="html"><![CDATA[<h2 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h2><hr><h2 id="【iOS-Sharing】系列目录"><a href="#【iOS-Sharing】系列目录" class="headerlink" title="【iOS Sharing】系列目录"></a>【iOS Sharing】系列目录</h2><h3 id="【-1】isa相关"><a href="#【-1】isa相关" class="headerlink" title="【#1】isa相关"></a><a href="https://adrenine.github.io/post/6de7ode7.html">【#1】isa相关</a></h3><h3 id="【-2】方法相关"><a href="#【-2】方法相关" class="headerlink" title="【#2】方法相关"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【#2】方法相关</a></h3><h3 id="【-3】多线程相关"><a href="#【-3】多线程相关" class="headerlink" title="【#3】多线程相关"></a><a href="https://adrenine.github.io/post/23afa2a3.html">【#3】多线程相关</a></h3><h3 id="【-4】类相关"><a href="#【-4】类相关" class="headerlink" title="【#4】类相关"></a><a href="https://adrenine.github.io/post/bdcb3700.html">【#4】类相关</a></h3><h3 id="【-5】网络相关"><a href="#【-5】网络相关" class="headerlink" title="【#5】网络相关"></a><a href="https://adrenine.github.io/post/cacc0796.html">【#5】网络相关</a></h3><h3 id="【-6】block相关"><a href="#【-6】block相关" class="headerlink" title="【#6】block相关"></a><a href="https://adrenine.github.io/post/53c5562c.html">【#6】block相关</a></h3><h3 id="【-7】属性相关"><a href="#【-7】属性相关" class="headerlink" title="【#7】属性相关"></a><a href="https://adrenine.github.io/post/24c266ba.html">【#7】属性相关</a></h3><h3 id="【-8】NSUserDefaults相关"><a href="#【-8】NSUserDefaults相关" class="headerlink" title="【#8】NSUserDefaults相关"></a><a href="https://adrenine.github.io/post/b47d7b2b.html">【#8】NSUserDefaults相关</a></h3><h3 id="【-9】UIView相关"><a href="#【-9】UIView相关" class="headerlink" title="【#9】UIView相关"></a><a href="https://adrenine.github.io/post/c37a4bbd.html">【#9】UIView相关</a></h3><h3 id="【-10】KVO、消息转发等"><a href="#【-10】KVO、消息转发等" class="headerlink" title="【#10】KVO、消息转发等"></a><a href="https://adrenine.github.io/post/a3bdc258.html">【#10】KVO、消息转发等</a></h3><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="【-1】isa相关-1"><a href="#【-1】isa相关-1" class="headerlink" title="【#1】isa相关"></a><a href="https://adrenine.github.io/post/6de7ode7.html">【#1】isa相关</a></h3><h4 id="nbsp-nbsp-1、Runtime存在的意义是什么"><a href="#nbsp-nbsp-1、Runtime存在的意义是什么" class="headerlink" title="&nbsp;&nbsp; 1、Runtime存在的意义是什么?"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/6de7ode7.html#h3-1">1、Runtime存在的意义是什么?</a></h4><h4 id="nbsp-nbsp-2、根元类的isa指针指向谁"><a href="#nbsp-nbsp-2、根元类的isa指针指向谁" class="headerlink" title="&nbsp;&nbsp; 2、根元类的isa指针指向谁?"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/6de7ode7.html#h3-2">2、根元类的isa指针指向谁?</a></h4><h4 id="nbsp-nbsp-3、根元类的superClass指针指向谁？"><a href="#nbsp-nbsp-3、根元类的superClass指针指向谁？" class="headerlink" title="&nbsp;&nbsp; 3、根元类的superClass指针指向谁？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/6de7ode7.html#h3-3">3、根元类的superClass指针指向谁？</a></h4><h4 id="nbsp-nbsp-4、isa指针有几种类型？"><a href="#nbsp-nbsp-4、isa指针有几种类型？" class="headerlink" title="&nbsp;&nbsp; 4、isa指针有几种类型？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/6de7ode7.html#h3-4">4、isa指针有几种类型？</a></h4><h4 id="nbsp-nbsp-5、id、self、super-它们从语法上有什么区别？"><a href="#nbsp-nbsp-5、id、self、super-它们从语法上有什么区别？" class="headerlink" title="&nbsp;&nbsp; 5、id、self、super 它们从语法上有什么区别？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/6de7ode7.html#h3-5">5、id、self、super 它们从语法上有什么区别？</a></h4><hr><h3 id="【-2】方法相关-1"><a href="#【-2】方法相关-1" class="headerlink" title="【#2】方法相关"></a><a href="https://adrenine.github.io/post/hjk78f6d.html">【#2】方法相关</a></h3><h4 id="nbsp-nbsp-1、实例方法去哪里找？"><a href="#nbsp-nbsp-1、实例方法去哪里找？" class="headerlink" title="&nbsp;&nbsp; 1、实例方法去哪里找？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/hjk78f6d.html#h3-1">1、实例方法去哪里找？</a></h4><h4 id="nbsp-nbsp-2、类方法去哪里找？"><a href="#nbsp-nbsp-2、类方法去哪里找？" class="headerlink" title="&nbsp;&nbsp; 2、类方法去哪里找？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/hjk78f6d.html#h3-2">2、类方法去哪里找？</a></h4><h4 id="nbsp-nbsp-3、分类的方法具体是在什么时候添加到类的方法列表中？"><a href="#nbsp-nbsp-3、分类的方法具体是在什么时候添加到类的方法列表中？" class="headerlink" title="&nbsp;&nbsp; 3、分类的方法具体是在什么时候添加到类的方法列表中？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/hjk78f6d.html#h3-3">3、分类的方法具体是在什么时候添加到类的方法列表中？</a></h4><h4 id="nbsp-nbsp-4、class-addMethod-都需要什么参数"><a href="#nbsp-nbsp-4、class-addMethod-都需要什么参数" class="headerlink" title="&nbsp;&nbsp; 4、class_addMethod()都需要什么参数?"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/hjk78f6d.html#h3-4">4、class_addMethod()都需要什么参数?</a></h4><h4 id="nbsp-nbsp-5、函数四要素都是什么？"><a href="#nbsp-nbsp-5、函数四要素都是什么？" class="headerlink" title="&nbsp;&nbsp; 5、函数四要素都是什么？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/hjk78f6d.html#h3-5">5、函数四要素都是什么？</a></h4><hr><h3 id="【-3】多线程相关-1"><a href="#【-3】多线程相关-1" class="headerlink" title="【#3】多线程相关"></a><a href="https://adrenine.github.io/post/23afa2a3.html">【#3】多线程相关</a></h3><h4 id="nbsp-nbsp-1、运行以下GCD多线程代码，控制台将打印什么"><a href="#nbsp-nbsp-1、运行以下GCD多线程代码，控制台将打印什么" class="headerlink" title="&nbsp;&nbsp; 1、运行以下GCD多线程代码，控制台将打印什么?"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/23afa2a3.html#h3-1">1、运行以下GCD多线程代码，控制台将打印什么?</a></h4><h4 id="nbsp-nbsp-2、串行同步、串行异步、并发同步、并发异步各自会开几条线程？"><a href="#nbsp-nbsp-2、串行同步、串行异步、并发同步、并发异步各自会开几条线程？" class="headerlink" title="&nbsp;&nbsp; 2、串行同步、串行异步、并发同步、并发异步各自会开几条线程？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/23afa2a3.html#h3-2">2、串行同步、串行异步、并发同步、并发异步各自会开几条线程？</a></h4><h4 id="nbsp-nbsp-3、为什么需要在主线程更新UI？"><a href="#nbsp-nbsp-3、为什么需要在主线程更新UI？" class="headerlink" title="&nbsp;&nbsp; 3、为什么需要在主线程更新UI？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/23afa2a3.html#h3-3">3、为什么需要在主线程更新UI？</a></h4><h4 id="nbsp-nbsp-4、iOS中如何用多线程实现多读单写"><a href="#nbsp-nbsp-4、iOS中如何用多线程实现多读单写" class="headerlink" title="&nbsp;&nbsp; 4、iOS中如何用多线程实现多读单写?"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/23afa2a3.html#h3-4">4、iOS中如何用多线程实现多读单写?</a></h4><h4 id="nbsp-nbsp-5、iOS多线程中有多少种方式可以做到等待前面线程执行完毕再执行后面的线程？"><a href="#nbsp-nbsp-5、iOS多线程中有多少种方式可以做到等待前面线程执行完毕再执行后面的线程？" class="headerlink" title="&nbsp;&nbsp; 5、iOS多线程中有多少种方式可以做到等待前面线程执行完毕再执行后面的线程？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/23afa2a3.html#h3-5">5、iOS多线程中有多少种方式可以做到等待前面线程执行完毕再执行后面的线程？</a></h4><hr><h3 id="【-4】类相关-1"><a href="#【-4】类相关-1" class="headerlink" title="【#4】类相关"></a><a href="https://adrenine.github.io/post/bdcb3700.html">【#4】类相关</a></h3><h4 id="nbsp-nbsp-1、请用一句话概述分类的概念，并阐述分类的优点。"><a href="#nbsp-nbsp-1、请用一句话概述分类的概念，并阐述分类的优点。" class="headerlink" title="&nbsp;&nbsp; 1、请用一句话概述分类的概念，并阐述分类的优点。"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/bdcb3700.html#h3-1">1、请用一句话概述分类的概念，并阐述分类的优点。</a></h4><h4 id="nbsp-nbsp-2、多个同宿主分类中的都重写了一个同名方法，哪个分类的同名方法会生效？为什么？"><a href="#nbsp-nbsp-2、多个同宿主分类中的都重写了一个同名方法，哪个分类的同名方法会生效？为什么？" class="headerlink" title="&nbsp;&nbsp; 2、多个同宿主分类中的都重写了一个同名方法，哪个分类的同名方法会生效？为什么？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/bdcb3700.html#h3-2">2、多个同宿主分类中的都重写了一个同名方法，哪个分类的同名方法会生效？为什么？</a></h4><h4 id="nbsp-nbsp-3-Category、-Extension和继承的区别？"><a href="#nbsp-nbsp-3-Category、-Extension和继承的区别？" class="headerlink" title="&nbsp;&nbsp; 3. Category、 Extension和继承的区别？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/bdcb3700.html#h3-3">3. Category、 Extension和继承的区别？</a></h4><h4 id="nbsp-nbsp-4-isKindOfClass、isMemberOfClass作用分别是什么？"><a href="#nbsp-nbsp-4-isKindOfClass、isMemberOfClass作用分别是什么？" class="headerlink" title="&nbsp;&nbsp; 4. isKindOfClass、isMemberOfClass作用分别是什么？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/bdcb3700.html#h3-4">4. isKindOfClass、isMemberOfClass作用分别是什么？</a></h4><h4 id="nbsp-nbsp-5-load-和-initialize-的区别是什么？"><a href="#nbsp-nbsp-5-load-和-initialize-的区别是什么？" class="headerlink" title="&nbsp;&nbsp; 5. +load 和 +initialize 的区别是什么？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/bdcb3700.html#h3-5">5. +load 和 +initialize 的区别是什么？</a></h4><hr><h3 id="【-5】网络相关-1"><a href="#【-5】网络相关-1" class="headerlink" title="【#5】网络相关"></a><a href="https://adrenine.github.io/post/cacc0796.html">【#5】网络相关</a></h3><h4 id="nbsp-nbsp-1-Scoket-连接和-HTTP-连接的区别"><a href="#nbsp-nbsp-1-Scoket-连接和-HTTP-连接的区别" class="headerlink" title="&nbsp;&nbsp; 1. Scoket 连接和 HTTP 连接的区别"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/cacc0796.html#h3-1">1. Scoket 连接和 HTTP 连接的区别</a></h4><h4 id="nbsp-nbsp-2-关于-HTTP-的请求-GET-和-POST-的区别"><a href="#nbsp-nbsp-2-关于-HTTP-的请求-GET-和-POST-的区别" class="headerlink" title="&nbsp;&nbsp; 2. 关于 HTTP 的请求 GET 和 POST 的区别"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/cacc0796.html#h3-2">2. 关于 HTTP 的请求 GET 和 POST 的区别</a></h4><h4 id="nbsp-nbsp-3-HTTPS-加密过程与原理"><a href="#nbsp-nbsp-3-HTTPS-加密过程与原理" class="headerlink" title="&nbsp;&nbsp; 3. HTTPS 加密过程与原理"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/cacc0796.html#h3-3">3. HTTPS 加密过程与原理</a></h4><h4 id="nbsp-nbsp-4-Socket-原理"><a href="#nbsp-nbsp-4-Socket-原理" class="headerlink" title="&nbsp;&nbsp; 4. Socket 原理"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/cacc0796.html#h3-4">4. Socket 原理</a></h4><h4 id="nbsp-nbsp-5-关于-TCP-的慢启动特性"><a href="#nbsp-nbsp-5-关于-TCP-的慢启动特性" class="headerlink" title="&nbsp;&nbsp; 5. 关于 TCP 的慢启动特性"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/cacc0796.html#h3-5">5. 关于 TCP 的慢启动特性</a></h4><hr><h3 id="【-6】block相关-1"><a href="#【-6】block相关-1" class="headerlink" title="【#6】block相关"></a><a href="https://adrenine.github.io/post/53c5562c.html">【#6】block相关</a></h3><h4 id="nbsp-nbsp-1-block的循环引用是如何造成的？"><a href="#nbsp-nbsp-1-block的循环引用是如何造成的？" class="headerlink" title="&nbsp;&nbsp; 1. block的循环引用是如何造成的？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/53c5562c.html#h3-1">1. block的循环引用是如何造成的？</a></h4><h4 id="nbsp-nbsp-2-使用UIAnimation的block回调时，需不需要使用-weak避免循环引用？为什么？"><a href="#nbsp-nbsp-2-使用UIAnimation的block回调时，需不需要使用-weak避免循环引用？为什么？" class="headerlink" title="&nbsp;&nbsp; 2. 使用UIAnimation的block回调时，需不需要使用__weak避免循环引用？为什么？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/53c5562c.html#h3-2">2. 使用UIAnimation的block回调时，需不需要使用__weak避免循环引用？为什么？</a></h4><h4 id="nbsp-nbsp-3-block属性是否可以用strong修饰？"><a href="#nbsp-nbsp-3-block属性是否可以用strong修饰？" class="headerlink" title="&nbsp;&nbsp; 3. block属性是否可以用strong修饰？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/53c5562c.html#h3-3">3. block属性是否可以用strong修饰？</a></h4><h4 id="nbsp-nbsp-4-什么场景下才需要对变量使用-block"><a href="#nbsp-nbsp-4-什么场景下才需要对变量使用-block" class="headerlink" title="&nbsp;&nbsp; 4. 什么场景下才需要对变量使用__block?"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/53c5562c.html#h3-4">4. 什么场景下才需要对变量使用__block?</a></h4><h4 id="nbsp-nbsp-5-block-修改捕获变量除了用-block-还可以怎么做？有哪些局限性？"><a href="#nbsp-nbsp-5-block-修改捕获变量除了用-block-还可以怎么做？有哪些局限性？" class="headerlink" title="&nbsp;&nbsp; 5. block 修改捕获变量除了用 __block 还可以怎么做？有哪些局限性？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/53c5562c.html#h3-5">5. block 修改捕获变量除了用 __block 还可以怎么做？有哪些局限性？</a></h4><hr><h3 id="【-7】属性相关-1"><a href="#【-7】属性相关-1" class="headerlink" title="【#7】属性相关"></a><a href="https://adrenine.github.io/post/24c266ba.html">【#7】属性相关</a></h3><h4 id="nbsp-nbsp-1、atomic关键字内部使用的是什么锁？"><a href="#nbsp-nbsp-1、atomic关键字内部使用的是什么锁？" class="headerlink" title="&nbsp;&nbsp; 1、atomic关键字内部使用的是什么锁？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/24c266ba.html#h3-1">1、atomic关键字内部使用的是什么锁？</a></h4><h4 id="nbsp-nbsp-2、-property-copy-NSMutableArray-array这样声明属性会出现什么问题？"><a href="#nbsp-nbsp-2、-property-copy-NSMutableArray-array这样声明属性会出现什么问题？" class="headerlink" title="&nbsp;&nbsp; 2、@property(copy)NSMutableArray *array这样声明属性会出现什么问题？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/24c266ba.html#h3-2">2、@property(copy)NSMutableArray *array这样声明属性会出现什么问题？</a></h4><h4 id="nbsp-nbsp-3、什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#nbsp-nbsp-3、什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="&nbsp;&nbsp; 3、什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/24c266ba.html#h3-3">3、什么情况使用 weak 关键字，相比 assign 有什么不同？</a></h4><h4 id="nbsp-nbsp-4、weak属性需要在dealloc中置nil么？"><a href="#nbsp-nbsp-4、weak属性需要在dealloc中置nil么？" class="headerlink" title="&nbsp;&nbsp; 4、weak属性需要在dealloc中置nil么？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/24c266ba.html#h3-4">4、weak属性需要在dealloc中置nil么？</a></h4><h4 id="nbsp-nbsp-5、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#nbsp-nbsp-5、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="&nbsp;&nbsp; 5、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/24c266ba.html#h3-5">5、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</a></h4><hr><h3 id="【-8】NSUserDefaults相关-1"><a href="#【-8】NSUserDefaults相关-1" class="headerlink" title="【#8】NSUserDefaults相关"></a><a href="https://adrenine.github.io/post/b47d7b2b.html">【#8】NSUserDefaults相关</a></h3><h4 id="nbsp-nbsp-1-NSUserDefaults-能够存储哪些类型的数据？可以存储可变数据类型吗？可以存储自定义数据类型吗？"><a href="#nbsp-nbsp-1-NSUserDefaults-能够存储哪些类型的数据？可以存储可变数据类型吗？可以存储自定义数据类型吗？" class="headerlink" title="&nbsp;&nbsp; 1. NSUserDefaults 能够存储哪些类型的数据？可以存储可变数据类型吗？可以存储自定义数据类型吗？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/b47d7b2b.html#h3-1">1. NSUserDefaults 能够存储哪些类型的数据？可以存储可变数据类型吗？可以存储自定义数据类型吗？</a></h4><h4 id="nbsp-nbsp-2-NSUserDefaults-没有存储-key-的时候默认返回什么？"><a href="#nbsp-nbsp-2-NSUserDefaults-没有存储-key-的时候默认返回什么？" class="headerlink" title="&nbsp;&nbsp; 2. NSUserDefaults 没有存储 key 的时候默认返回什么？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/b47d7b2b.html#h3-2">2. NSUserDefaults 没有存储 key 的时候默认返回什么？</a></h4><h4 id="nbsp-nbsp-3-NSUserDefaults-存取操作是什么？它将数据存在何处？并且它是如何保持数据一致性的"><a href="#nbsp-nbsp-3-NSUserDefaults-存取操作是什么？它将数据存在何处？并且它是如何保持数据一致性的" class="headerlink" title="&nbsp;&nbsp; 3. NSUserDefaults 存取操作是什么？它将数据存在何处？并且它是如何保持数据一致性的?"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/b47d7b2b.html#h3-3">3. NSUserDefaults 存取操作是什么？它将数据存在何处？并且它是如何保持数据一致性的?</a></h4><h4 id="nbsp-nbsp-4-NSUserDefaults-旧数据总能被新设置的替换吗？"><a href="#nbsp-nbsp-4-NSUserDefaults-旧数据总能被新设置的替换吗？" class="headerlink" title="&nbsp;&nbsp; 4. NSUserDefaults 旧数据总能被新设置的替换吗？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/b47d7b2b.html#h3-4">4. NSUserDefaults 旧数据总能被新设置的替换吗？</a></h4><h4 id="nbsp-nbsp-5-NSUserDefaults-性能如何"><a href="#nbsp-nbsp-5-NSUserDefaults-性能如何" class="headerlink" title="&nbsp;&nbsp; 5. NSUserDefaults 性能如何?"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/b47d7b2b.html#h3-5">5. NSUserDefaults 性能如何?</a></h4><hr><h3 id="【-9】UIView相关-1"><a href="#【-9】UIView相关-1" class="headerlink" title="【#9】UIView相关"></a><a href="https://adrenine.github.io/post/c37a4bbd.html">【#9】UIView相关</a></h3><h4 id="nbsp-nbsp-1-setNeedsLayout、layoutIfNeeded与layoutSubviews区别？"><a href="#nbsp-nbsp-1-setNeedsLayout、layoutIfNeeded与layoutSubviews区别？" class="headerlink" title="&nbsp;&nbsp; 1. setNeedsLayout、layoutIfNeeded与layoutSubviews区别？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/c37a4bbd.html#h3-1">1. setNeedsLayout、layoutIfNeeded与layoutSubviews区别？</a></h4><h4 id="nbsp-nbsp-2-UIView与CALayer的区别？"><a href="#nbsp-nbsp-2-UIView与CALayer的区别？" class="headerlink" title="&nbsp;&nbsp; 2. UIView与CALayer的区别？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/c37a4bbd.html#h3-2">2. UIView与CALayer的区别？</a></h4><h4 id="nbsp-nbsp-3-loadView什么时候被调用？它有什么作用？默认实现是怎么样的？"><a href="#nbsp-nbsp-3-loadView什么时候被调用？它有什么作用？默认实现是怎么样的？" class="headerlink" title="&nbsp;&nbsp; 3. loadView什么时候被调用？它有什么作用？默认实现是怎么样的？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/c37a4bbd.html#h3-3">3. loadView什么时候被调用？它有什么作用？默认实现是怎么样的？</a></h4><h4 id="nbsp-nbsp-4-UIViewController的完整生命周期？"><a href="#nbsp-nbsp-4-UIViewController的完整生命周期？" class="headerlink" title="&nbsp;&nbsp; 4. UIViewController的完整生命周期？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/c37a4bbd.html#h3-4">4. UIViewController的完整生命周期？</a></h4><h4 id="nbsp-nbsp-5-UIView动画支持的属性有哪些？"><a href="#nbsp-nbsp-5-UIView动画支持的属性有哪些？" class="headerlink" title="&nbsp;&nbsp; 5. UIView动画支持的属性有哪些？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/c37a4bbd.html#h3-5">5. UIView动画支持的属性有哪些？</a></h4><hr><h3 id="【-10】KVO、消息转发等-1"><a href="#【-10】KVO、消息转发等-1" class="headerlink" title="【#10】KVO、消息转发等"></a><a href="https://adrenine.github.io/post/a3bdc258.html">【#10】KVO、消息转发等</a></h3><h4 id="nbsp-nbsp-1、开发中逆向传值的方式有哪些？"><a href="#nbsp-nbsp-1、开发中逆向传值的方式有哪些？" class="headerlink" title="&nbsp;&nbsp; 1、开发中逆向传值的方式有哪些？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/a3bdc258.html#h3-1">1、开发中逆向传值的方式有哪些？</a></h4><h4 id="nbsp-nbsp-2、开发中方法延迟执行的方式有哪些？"><a href="#nbsp-nbsp-2、开发中方法延迟执行的方式有哪些？" class="headerlink" title="&nbsp;&nbsp; 2、开发中方法延迟执行的方式有哪些？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/a3bdc258.html#h3-2">2、开发中方法延迟执行的方式有哪些？</a></h4><h4 id="nbsp-nbsp-3、说一说KVO在重写NSKVONotifying对象的setter方法中，添加了哪两个关键方法？"><a href="#nbsp-nbsp-3、说一说KVO在重写NSKVONotifying对象的setter方法中，添加了哪两个关键方法？" class="headerlink" title="&nbsp;&nbsp; 3、说一说KVO在重写NSKVONotifying对象的setter方法中，添加了哪两个关键方法？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/a3bdc258.html#h3-3">3、说一说KVO在重写NSKVONotifying对象的setter方法中，添加了哪两个关键方法？</a></h4><h4 id="nbsp-nbsp-4、如何实现一个完整的单例？"><a href="#nbsp-nbsp-4、如何实现一个完整的单例？" class="headerlink" title="&nbsp;&nbsp; 4、如何实现一个完整的单例？"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/a3bdc258.html#h3-4">4、如何实现一个完整的单例？</a></h4><h4 id="nbsp-nbsp-5、iOS消息转发流程"><a href="#nbsp-nbsp-5、iOS消息转发流程" class="headerlink" title="&nbsp;&nbsp; 5、iOS消息转发流程"></a>&nbsp;&nbsp; <a href="https://adrenine.github.io/post/a3bdc258.html#h3-5">5、iOS消息转发流程</a></h4><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#57;&#x39;&#52;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#109;">&#95;&#x31;&#57;&#x39;&#52;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS Sharing</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【主页】全系列文章目录</title>
    <link href="/post/main.html"/>
    <url>/post/main.html</url>
    
    <content type="html"><![CDATA[<h2 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h2><h3 id="nbsp-nbsp-1-【iOS笔记】系列目录"><a href="#nbsp-nbsp-1-【iOS笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;1.【iOS笔记】系列目录"></a>&nbsp;&nbsp;1.<a href="#1">【iOS笔记】系列目录</a></h3><h3 id="nbsp-nbsp-2-【iOS-Sharing】系列目录"><a href="#nbsp-nbsp-2-【iOS-Sharing】系列目录" class="headerlink" title="&nbsp;&nbsp;2.【iOS Sharing】系列目录"></a>&nbsp;&nbsp;2.<a href="#2">【iOS Sharing】系列目录</a></h3><h3 id="nbsp-nbsp-3-【靠谱程序员】系列目录"><a href="#nbsp-nbsp-3-【靠谱程序员】系列目录" class="headerlink" title="&nbsp;&nbsp;3.【靠谱程序员】系列目录"></a>&nbsp;&nbsp;3.<a href="#3">【靠谱程序员】系列目录</a></h3><h3 id="nbsp-nbsp-4-【iOS警告与报错】系列目录"><a href="#nbsp-nbsp-4-【iOS警告与报错】系列目录" class="headerlink" title="&nbsp;&nbsp;4.【iOS警告与报错】系列目录"></a>&nbsp;&nbsp;4.<a href="#4">【iOS警告与报错】系列目录</a></h3><h3 id="nbsp-nbsp-5-【开发笔记】系列目录"><a href="#nbsp-nbsp-5-【开发笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;5.【开发笔记】系列目录"></a>&nbsp;&nbsp;5.<a href="#5">【开发笔记】系列目录</a></h3><h3 id="nbsp-nbsp-6-【Leet-Code】系列目录"><a href="#nbsp-nbsp-6-【Leet-Code】系列目录" class="headerlink" title="&nbsp;&nbsp;6.【Leet Code】系列目录"></a>&nbsp;&nbsp;6.<a href="#6">【Leet Code】系列目录</a></h3><h3 id="nbsp-nbsp-7-【Coding】系列目录"><a href="#nbsp-nbsp-7-【Coding】系列目录" class="headerlink" title="&nbsp;&nbsp;7.【Coding】系列目录"></a>&nbsp;&nbsp;7.<a href="#7">【Coding】系列目录</a></h3><hr><h3 id='1'>1.【iOS笔记】系列目录</h3><h4 id="nbsp-nbsp-【-1】Appearance的使用"><a href="#nbsp-nbsp-【-1】Appearance的使用" class="headerlink" title="&nbsp;&nbsp;【#1】Appearance的使用"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hl6o7p52.html">【#1】Appearance的使用</a></h4><h4 id="nbsp-nbsp-【-2】Runtime基础（一）"><a href="#nbsp-nbsp-【-2】Runtime基础（一）" class="headerlink" title="&nbsp;&nbsp;【#2】Runtime基础（一）"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/20f2ery1.html">【#2】Runtime基础（一）</a></h4><h4 id="nbsp-nbsp-【-3】Runtime基础（二）"><a href="#nbsp-nbsp-【-3】Runtime基础（二）" class="headerlink" title="&nbsp;&nbsp;【#3】Runtime基础（二）"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/c63ec63e.html">【#3】Runtime基础（二）</a></h4><h4 id="nbsp-nbsp-【-4】UIAlertController的使用"><a href="#nbsp-nbsp-【-4】UIAlertController的使用" class="headerlink" title="&nbsp;&nbsp;【#4】UIAlertController的使用"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/a92aa92a.html">【#4】UIAlertController的使用</a></h4><h4 id="nbsp-nbsp-【-5】UILabel富文本的使用"><a href="#nbsp-nbsp-【-5】UILabel富文本的使用" class="headerlink" title="&nbsp;&nbsp;【#5】UILabel富文本的使用"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/2ui9pf8c.html">【#5】UILabel富文本的使用</a></h4><h4 id="nbsp-nbsp-【-6】CocoaPods安装与使用"><a href="#nbsp-nbsp-【-6】CocoaPods安装与使用" class="headerlink" title="&nbsp;&nbsp;【#6】CocoaPods安装与使用"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/7ghei9e0.html">【#6】CocoaPods安装与使用</a></h4><h4 id="nbsp-nbsp-【-7】iOS数组排序"><a href="#nbsp-nbsp-【-7】iOS数组排序" class="headerlink" title="&nbsp;&nbsp;【#7】iOS数组排序"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/73d0bgy4.html">【#7】iOS数组排序</a></h4><h4 id="nbsp-nbsp-【-8】新闻类App-Top-TabBarController实现"><a href="#nbsp-nbsp-【-8】新闻类App-Top-TabBarController实现" class="headerlink" title="&nbsp;&nbsp;【#8】新闻类App Top-TabBarController实现"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/a93i76hj.html">【#8】新闻类App Top-TabBarController实现</a></h4><h4 id="nbsp-nbsp-【-9】class与objc-getClass方法"><a href="#nbsp-nbsp-【-9】class与objc-getClass方法" class="headerlink" title="&nbsp;&nbsp;【#9】class与objc_getClass方法"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/db79nmkl.html">【#9】class与objc_getClass方法</a></h4><h4 id="nbsp-nbsp-【-10】调整UIButton-Image与Title位置"><a href="#nbsp-nbsp-【-10】调整UIButton-Image与Title位置" class="headerlink" title="&nbsp;&nbsp;【#10】调整UIButton Image与Title位置"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e7uin26d.html">【#10】调整UIButton Image与Title位置</a></h4><h4 id="nbsp-nbsp-【-11】iOS控件自适应大小"><a href="#nbsp-nbsp-【-11】iOS控件自适应大小" class="headerlink" title="&nbsp;&nbsp;【#11】iOS控件自适应大小"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/eyujn26d.html">【#11】iOS控件自适应大小</a></h4><h4 id="nbsp-nbsp-【-12】多线程"><a href="#nbsp-nbsp-【-12】多线程" class="headerlink" title="&nbsp;&nbsp;【#12】多线程"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ei822g6d.html">【#12】多线程</a></h4><h4 id="nbsp-nbsp-【-13】iOS延迟执行"><a href="#nbsp-nbsp-【-13】iOS延迟执行" class="headerlink" title="&nbsp;&nbsp;【#13】iOS延迟执行"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/gfs2e26d.html">【#13】iOS延迟执行</a></h4><h4 id="nbsp-nbsp-【-14】SDWebImage浅析"><a href="#nbsp-nbsp-【-14】SDWebImage浅析" class="headerlink" title="&nbsp;&nbsp;【#14】SDWebImage浅析"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/easdr26d.html">【#14】SDWebImage浅析</a></h4><h4 id="nbsp-nbsp-【-15】常驻线程"><a href="#nbsp-nbsp-【-15】常驻线程" class="headerlink" title="&nbsp;&nbsp;【#15】常驻线程"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/sde3r26d.html">【#15】常驻线程</a></h4><h4 id="nbsp-nbsp-【-16】isKindOfClass与isMemberOfClass"><a href="#nbsp-nbsp-【-16】isKindOfClass与isMemberOfClass" class="headerlink" title="&nbsp;&nbsp;【#16】isKindOfClass与isMemberOfClass"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hje6726d.html">【#16】isKindOfClass与isMemberOfClass</a></h4><h4 id="nbsp-nbsp-【-17】weak与unsafe-unretain"><a href="#nbsp-nbsp-【-17】weak与unsafe-unretain" class="headerlink" title="&nbsp;&nbsp;【#17】weak与unsafe_unretain"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ghj7e26d.html">【#17】weak与unsafe_unretain</a></h4><h4 id="nbsp-nbsp-【-18】SEL的使用与原理"><a href="#nbsp-nbsp-【-18】SEL的使用与原理" class="headerlink" title="&nbsp;&nbsp;【#18】SEL的使用与原理"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2789u6d.html">【#18】SEL的使用与原理</a></h4><h4 id="nbsp-nbsp-【-19】iOS远程推送流程"><a href="#nbsp-nbsp-【-19】iOS远程推送流程" class="headerlink" title="&nbsp;&nbsp;【#19】iOS远程推送流程"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2iu766d.html">【#19】iOS远程推送流程</a></h4><h4 id="nbsp-nbsp-【-20】iOS自旋锁、互斥锁与递归锁"><a href="#nbsp-nbsp-【-20】iOS自旋锁、互斥锁与递归锁" class="headerlink" title="&nbsp;&nbsp;【#20】iOS自旋锁、互斥锁与递归锁"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2iokj6d.html">【#20】iOS自旋锁、互斥锁与递归锁</a></h4><h4 id="nbsp-nbsp-【-21】Atomic与自旋锁"><a href="#nbsp-nbsp-【-21】Atomic与自旋锁" class="headerlink" title="&nbsp;&nbsp;【#21】Atomic与自旋锁"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/etr9ui6d.html">【#21】Atomic与自旋锁</a></h4><h4 id="nbsp-nbsp-【-22】KVC"><a href="#nbsp-nbsp-【-22】KVC" class="headerlink" title="&nbsp;&nbsp;【#22】KVC"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjbvw26d.html">【#22】KVC</a></h4><h4 id="nbsp-nbsp-【-23】iOS内存管理"><a href="#nbsp-nbsp-【-23】iOS内存管理" class="headerlink" title="&nbsp;&nbsp;【#23】iOS内存管理"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/evbcd26d.html">【#23】iOS内存管理</a></h4><hr><h3 id='2'>2.【iOS Sharing】系列目录</h3><h4 id="nbsp-nbsp-【-1】isa相关"><a href="#nbsp-nbsp-【-1】isa相关" class="headerlink" title="&nbsp;&nbsp;【#1】isa相关"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/6de7ode7.html">【#1】isa相关</a></h4><h4 id="nbsp-nbsp-【-2】方法相关"><a href="#nbsp-nbsp-【-2】方法相关" class="headerlink" title="&nbsp;&nbsp;【#2】方法相关"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjk78f6d.html">【#2】方法相关</a></h4><h4 id="nbsp-nbsp-【-3】多线程相关"><a href="#nbsp-nbsp-【-3】多线程相关" class="headerlink" title="&nbsp;&nbsp;【#3】多线程相关"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/23afa2a3.html">【#3】多线程相关</a></h4><h4 id="nbsp-nbsp-【-4】类相关"><a href="#nbsp-nbsp-【-4】类相关" class="headerlink" title="&nbsp;&nbsp;【#4】类相关"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/bdcb3700.html">【#4】类相关</a></h4><h4 id="nbsp-nbsp-【-5】网络相关"><a href="#nbsp-nbsp-【-5】网络相关" class="headerlink" title="&nbsp;&nbsp;【#5】网络相关"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/cacc0796.html">【#5】网络相关</a></h4><h4 id="nbsp-nbsp-【-6】block相关"><a href="#nbsp-nbsp-【-6】block相关" class="headerlink" title="&nbsp;&nbsp;【#6】block相关"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/53c5562c.html">【#6】block相关</a></h4><h4 id="nbsp-nbsp-【-7】属性相关"><a href="#nbsp-nbsp-【-7】属性相关" class="headerlink" title="&nbsp;&nbsp;【#7】属性相关"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/24c266ba.html">【#7】属性相关</a></h4><h4 id="nbsp-nbsp-【-8】NSUserDefaults相关"><a href="#nbsp-nbsp-【-8】NSUserDefaults相关" class="headerlink" title="&nbsp;&nbsp;【#8】NSUserDefaults相关"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/b47d7b2b.html">【#8】NSUserDefaults相关</a></h4><h4 id="nbsp-nbsp-【-9】UIView相关"><a href="#nbsp-nbsp-【-9】UIView相关" class="headerlink" title="&nbsp;&nbsp;【#9】UIView相关"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/c37a4bbd.html">【#9】UIView相关</a></h4><h4 id="nbsp-nbsp-【-10】KVO、消息转发等"><a href="#nbsp-nbsp-【-10】KVO、消息转发等" class="headerlink" title="&nbsp;&nbsp;【#10】KVO、消息转发等"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/a3bdc258.html">【#10】KVO、消息转发等</a></h4><hr><h3 id='3'>3.【靠谱程序员】系列目录</h3><h4 id="nbsp-nbsp-【-1】代码风格优化与纠错"><a href="#nbsp-nbsp-【-1】代码风格优化与纠错" class="headerlink" title="&nbsp;&nbsp;【#1】代码风格优化与纠错"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/f829ea4b.html">【#1】代码风格优化与纠错</a></h4><h4 id="nbsp-nbsp-【-2】什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#nbsp-nbsp-【-2】什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="&nbsp;&nbsp;【#2】什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/f9d3oq4d.html">【#2】什么情况使用 weak 关键字，相比 assign 有什么不同？</a></h4><h4 id="nbsp-nbsp-【-3】怎么用-copy-关键字？"><a href="#nbsp-nbsp-【-3】怎么用-copy-关键字？" class="headerlink" title="&nbsp;&nbsp;【#3】怎么用 copy 关键字？"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/1g2rp43e.html">【#3】怎么用 copy 关键字？</a></h4><h4 id="nbsp-nbsp-【-4】这个写法会出什么问题：-property-copy-NSMutableArray-array"><a href="#nbsp-nbsp-【-4】这个写法会出什么问题：-property-copy-NSMutableArray-array" class="headerlink" title="&nbsp;&nbsp;【#4】这个写法会出什么问题： @property (copy) NSMutableArray *array"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/b5y4dc3.html">【#4】这个写法会出什么问题： @property (copy) NSMutableArray *array</a></h4><h4 id="nbsp-nbsp-【-5】如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"><a href="#nbsp-nbsp-【-5】如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？" class="headerlink" title="&nbsp;&nbsp;【#5】如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/5fa0ub2h.html">【#5】如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</a></h4><h4 id="nbsp-nbsp-【-6】-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的？"><a href="#nbsp-nbsp-【-6】-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的？" class="headerlink" title="&nbsp;&nbsp;【#6】@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/87yc6ef.html">【#6】@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？</a></h4><h4 id="nbsp-nbsp-【-7】在-protocol-和-category-中如何使用-property"><a href="#nbsp-nbsp-【-7】在-protocol-和-category-中如何使用-property" class="headerlink" title="&nbsp;&nbsp;【#7】在@protocol 和 category 中如何使用 @property"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/4a8q20e0.html">【#7】在@protocol 和 category 中如何使用 @property</a></h4><hr><h3 id='4'>4.【iOS警告与报错】系列目录</h3><h4 id="nbsp-nbsp-【-1】iPad-Multitasking-support-requires-xxx"><a href="#nbsp-nbsp-【-1】iPad-Multitasking-support-requires-xxx" class="headerlink" title="&nbsp;&nbsp;【#1】iPad Multitasking support requires xxx"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/emn1h26d.html">【#1】iPad Multitasking support requires xxx</a></h4><h4 id="nbsp-nbsp-【-2】CUICatalog-Invalid-asset-name-supplied"><a href="#nbsp-nbsp-【-2】CUICatalog-Invalid-asset-name-supplied" class="headerlink" title="&nbsp;&nbsp;【#2】CUICatalog: Invalid asset name supplied:"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/nmuyt54s.html">【#2】CUICatalog: Invalid asset name supplied:</a></h4><h4 id="nbsp-nbsp-【-3】Build-for-iOS-but-xxx-build-for-iOS-and-iOS-Simulator"><a href="#nbsp-nbsp-【-3】Build-for-iOS-but-xxx-build-for-iOS-and-iOS-Simulator" class="headerlink" title="&nbsp;&nbsp;【#3】Build for iOS but xxx build for iOS and iOS-Simulator"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/oknmhy67.html">【#3】Build for iOS but xxx build for iOS and iOS-Simulator</a></h4><hr><h3 id='5'>5.【开发笔记】系列目录</h3><h4 id="nbsp-nbsp-【-1】Mac生成多个ssh并配置不同域名"><a href="#nbsp-nbsp-【-1】Mac生成多个ssh并配置不同域名" class="headerlink" title="&nbsp;&nbsp;【#1】Mac生成多个ssh并配置不同域名"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/4a6f7eb6.html">【#1】Mac生成多个ssh并配置不同域名</a></h4><h4 id="nbsp-nbsp-【-2】使用Wireshark抓包"><a href="#nbsp-nbsp-【-2】使用Wireshark抓包" class="headerlink" title="&nbsp;&nbsp;【#2】使用Wireshark抓包"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/b24af2ae.html">【#2】使用Wireshark抓包</a></h4><h4 id="nbsp-nbsp-【-3】结构体字节对齐"><a href="#nbsp-nbsp-【-3】结构体字节对齐" class="headerlink" title="&nbsp;&nbsp;【#3】结构体字节对齐"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/pfe2aew.html">【#3】结构体字节对齐</a></h4><h4 id="nbsp-nbsp-【-4】git撤回commit与push"><a href="#nbsp-nbsp-【-4】git撤回commit与push" class="headerlink" title="&nbsp;&nbsp;【#4】git撤回commit与push"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/afe2feq.html">【#4】git撤回commit与push</a></h4><h4 id="nbsp-nbsp-【-5】TCP三次握手与四次挥手"><a href="#nbsp-nbsp-【-5】TCP三次握手与四次挥手" class="headerlink" title="&nbsp;&nbsp;【#5】TCP三次握手与四次挥手"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/gkea24bn.html">【#5】TCP三次握手与四次挥手</a></h4><h4 id="nbsp-nbsp-【-6】Hexo配置"><a href="#nbsp-nbsp-【-6】Hexo配置" class="headerlink" title="&nbsp;&nbsp;【#6】Hexo配置"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ef4ake7i.html">【#6】Hexo配置</a></h4><h4 id="nbsp-nbsp-【-7】Http2-0了解"><a href="#nbsp-nbsp-【-7】Http2-0了解" class="headerlink" title="&nbsp;&nbsp;【#7】Http2.0了解"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/4abpi8ft.html">【#7】Http2.0了解</a></h4><hr><h3 id='6'>6.【Leet Code】系列目录</h3><h4 id="nbsp-nbsp-【-1】Two-Sum"><a href="#nbsp-nbsp-【-1】Two-Sum" class="headerlink" title="&nbsp;&nbsp;【#1】Two Sum"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/2djk89iu.html">【#1】Two Sum</a></h4><h4 id="nbsp-nbsp-【-2】Add-Two-Numbers"><a href="#nbsp-nbsp-【-2】Add-Two-Numbers" class="headerlink" title="&nbsp;&nbsp;【#2】Add Two Numbers"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/c65eh7y4.html">【#2】Add Two Numbers</a></h4><h4 id="nbsp-nbsp-【-3】Longest-Substring-Without-Repeating-Characters"><a href="#nbsp-nbsp-【-3】Longest-Substring-Without-Repeating-Characters" class="headerlink" title="&nbsp;&nbsp;【#3】Longest Substring Without Repeating Characters"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/8b62jk96.html">【#3】Longest Substring Without Repeating Characters</a></h4><h4 id="nbsp-nbsp-【-4】Midian-of-Two-Sorted-Arrays"><a href="#nbsp-nbsp-【-4】Midian-of-Two-Sorted-Arrays" class="headerlink" title="&nbsp;&nbsp;【#4】Midian of Two Sorted Arrays"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/98g2fd04.html">【#4】Midian of Two Sorted Arrays</a></h4><hr><h3 id='7'>7.【Coding】系列目录</h3><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#95;&#x31;&#x39;&#57;&#52;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;">&#95;&#x31;&#x39;&#57;&#52;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS笔记系列目录</title>
    <link href="/post/hjk78f6d.html"/>
    <url>/post/hjk78f6d.html</url>
    
    <content type="html"><![CDATA[<h3 id="【主页】系列文章目录"><a href="#【主页】系列文章目录" class="headerlink" title="【主页】系列文章目录"></a><a href="https://adrenine.github.io/post/main.html">【主页】系列文章目录</a></h3><h4 id="nbsp-nbsp-【iOS-Sharing】系列目录"><a href="#nbsp-nbsp-【iOS-Sharing】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS Sharing】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjuia973.html">【iOS Sharing】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS笔记】系列目录"><a href="#nbsp-nbsp-【iOS笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjk78f6d.html">【iOS笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【靠谱程序员】系列目录"><a href="#nbsp-nbsp-【靠谱程序员】系列目录" class="headerlink" title="&nbsp;&nbsp;【靠谱程序员】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/10fb75fe.html">【靠谱程序员】系列目录</a></h4><h4 id="nbsp-nbsp-【iOS警告与报错】系列目录"><a href="#nbsp-nbsp-【iOS警告与报错】系列目录" class="headerlink" title="&nbsp;&nbsp;【iOS警告与报错】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2m9iu6d.html">【iOS警告与报错】系列目录</a></h4><h4 id="nbsp-nbsp-【开发笔记】系列目录"><a href="#nbsp-nbsp-【开发笔记】系列目录" class="headerlink" title="&nbsp;&nbsp;【开发笔记】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/a9ea42fe.html">【开发笔记】系列目录</a></h4><h4 id="nbsp-nbsp-【Leet-Code】系列目录"><a href="#nbsp-nbsp-【Leet-Code】系列目录" class="headerlink" title="&nbsp;&nbsp;【Leet Code】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/d305db71.html">【Leet Code】系列目录</a></h4><h4 id="nbsp-nbsp-【Coding】系列目录"><a href="#nbsp-nbsp-【Coding】系列目录" class="headerlink" title="&nbsp;&nbsp;【Coding】系列目录"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ab23a973.html">【Coding】系列目录</a></h4><hr><h3 id='2'> 【iOS笔记】系列目录</h3><h5 id="nbsp-nbsp-【-1】Appearance的使用"><a href="#nbsp-nbsp-【-1】Appearance的使用" class="headerlink" title="&nbsp;&nbsp;【#1】Appearance的使用"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hl6o7p52.html">【#1】Appearance的使用</a></h5><h5 id="nbsp-nbsp-【-2】Runtime基础（一）"><a href="#nbsp-nbsp-【-2】Runtime基础（一）" class="headerlink" title="&nbsp;&nbsp;【#2】Runtime基础（一）"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/20f2ery1.html">【#2】Runtime基础（一）</a></h5><h5 id="nbsp-nbsp-【-3】Runtime基础（二）"><a href="#nbsp-nbsp-【-3】Runtime基础（二）" class="headerlink" title="&nbsp;&nbsp;【#3】Runtime基础（二）"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/c63ec63e.html">【#3】Runtime基础（二）</a></h5><h5 id="nbsp-nbsp-【-4】UIAlertController的使用"><a href="#nbsp-nbsp-【-4】UIAlertController的使用" class="headerlink" title="&nbsp;&nbsp;【#4】UIAlertController的使用"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/a92aa92a.html">【#4】UIAlertController的使用</a></h5><h5 id="nbsp-nbsp-【-5】UILabel富文本的使用"><a href="#nbsp-nbsp-【-5】UILabel富文本的使用" class="headerlink" title="&nbsp;&nbsp;【#5】UILabel富文本的使用"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/2ui9pf8c.html">【#5】UILabel富文本的使用</a></h5><h5 id="nbsp-nbsp-【-6】CocoaPods安装与使用"><a href="#nbsp-nbsp-【-6】CocoaPods安装与使用" class="headerlink" title="&nbsp;&nbsp;【#6】CocoaPods安装与使用"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/7ghei9e0.html">【#6】CocoaPods安装与使用</a></h5><h5 id="nbsp-nbsp-【-7】iOS数组排序"><a href="#nbsp-nbsp-【-7】iOS数组排序" class="headerlink" title="&nbsp;&nbsp;【#7】iOS数组排序"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/73d0bgy4.html">【#7】iOS数组排序</a></h5><h5 id="nbsp-nbsp-【-8】新闻类App-Top-TabBarController实现"><a href="#nbsp-nbsp-【-8】新闻类App-Top-TabBarController实现" class="headerlink" title="&nbsp;&nbsp;【#8】新闻类App Top-TabBarController实现"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/a93i76hj.html">【#8】新闻类App Top-TabBarController实现</a></h5><h5 id="nbsp-nbsp-【-9】class与objc-getClass方法"><a href="#nbsp-nbsp-【-9】class与objc-getClass方法" class="headerlink" title="&nbsp;&nbsp;【#9】class与objc_getClass方法"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/db79nmkl.html">【#9】class与objc_getClass方法</a></h5><h5 id="nbsp-nbsp-【-10】调整UIButton-Image与Title位置"><a href="#nbsp-nbsp-【-10】调整UIButton-Image与Title位置" class="headerlink" title="&nbsp;&nbsp;【#10】调整UIButton Image与Title位置"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e7uin26d.html">【#10】调整UIButton Image与Title位置</a></h5><h5 id="nbsp-nbsp-【-11】iOS控件自适应大小"><a href="#nbsp-nbsp-【-11】iOS控件自适应大小" class="headerlink" title="&nbsp;&nbsp;【#11】iOS控件自适应大小"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/eyujn26d.html">【#11】iOS控件自适应大小</a></h5><h5 id="nbsp-nbsp-【-12】多线程"><a href="#nbsp-nbsp-【-12】多线程" class="headerlink" title="&nbsp;&nbsp;【#12】多线程"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ei822g6d.html">【#12】多线程</a></h5><h5 id="nbsp-nbsp-【-13】iOS延迟执行"><a href="#nbsp-nbsp-【-13】iOS延迟执行" class="headerlink" title="&nbsp;&nbsp;【#13】iOS延迟执行"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/gfs2e26d.html">【#13】iOS延迟执行</a></h5><h5 id="nbsp-nbsp-【-14】SDWebImage浅析"><a href="#nbsp-nbsp-【-14】SDWebImage浅析" class="headerlink" title="&nbsp;&nbsp;【#14】SDWebImage浅析"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/easdr26d.html">【#14】SDWebImage浅析</a></h5><h5 id="nbsp-nbsp-【-15】常驻线程"><a href="#nbsp-nbsp-【-15】常驻线程" class="headerlink" title="&nbsp;&nbsp;【#15】常驻线程"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/sde3r26d.html">【#15】常驻线程</a></h5><h5 id="nbsp-nbsp-【-16】isKindOfClass与isMemberOfClass"><a href="#nbsp-nbsp-【-16】isKindOfClass与isMemberOfClass" class="headerlink" title="&nbsp;&nbsp;【#16】isKindOfClass与isMemberOfClass"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hje6726d.html">【#16】isKindOfClass与isMemberOfClass</a></h5><h5 id="nbsp-nbsp-【-17】weak与unsafe-unretain"><a href="#nbsp-nbsp-【-17】weak与unsafe-unretain" class="headerlink" title="&nbsp;&nbsp;【#17】weak与unsafe_unretain"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/ghj7e26d.html">【#17】weak与unsafe_unretain</a></h5><h5 id="nbsp-nbsp-【-18】SEL的使用与原理"><a href="#nbsp-nbsp-【-18】SEL的使用与原理" class="headerlink" title="&nbsp;&nbsp;【#18】SEL的使用与原理"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2789u6d.html">【#18】SEL的使用与原理</a></h5><h5 id="nbsp-nbsp-【-19】iOS远程推送流程"><a href="#nbsp-nbsp-【-19】iOS远程推送流程" class="headerlink" title="&nbsp;&nbsp;【#19】iOS远程推送流程"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2iu766d.html">【#19】iOS远程推送流程</a></h5><h5 id="nbsp-nbsp-【-20】iOS自旋锁、互斥锁与递归锁"><a href="#nbsp-nbsp-【-20】iOS自旋锁、互斥锁与递归锁" class="headerlink" title="&nbsp;&nbsp;【#20】iOS自旋锁、互斥锁与递归锁"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/e2iokj6d.html">【#20】iOS自旋锁、互斥锁与递归锁</a></h5><h5 id="nbsp-nbsp-【-21】Atomic与自旋锁"><a href="#nbsp-nbsp-【-21】Atomic与自旋锁" class="headerlink" title="&nbsp;&nbsp;【#21】Atomic与自旋锁"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/etr9ui6d.html">【#21】Atomic与自旋锁</a></h5><h5 id="nbsp-nbsp-【-22】KVC"><a href="#nbsp-nbsp-【-22】KVC" class="headerlink" title="&nbsp;&nbsp;【#22】KVC"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/hjbvw26d.html">【#22】KVC</a></h5><h5 id="nbsp-nbsp-【-23】iOS内存管理"><a href="#nbsp-nbsp-【-23】iOS内存管理" class="headerlink" title="&nbsp;&nbsp;【#23】iOS内存管理"></a>&nbsp;&nbsp;<a href="https://adrenine.github.io/post/evbcd26d.html">【#23】iOS内存管理</a></h5><hr><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p><strong>邮箱：</strong> xiebangyao<a href="mailto:&#x5f;&#49;&#x39;&#x39;&#x34;&#64;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;">&#x5f;&#49;&#x39;&#x39;&#x34;&#64;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;</a></br><br><strong>相关账号：</strong></p><ul><li><a href="https://juejin.im/user/57c39bfb79bc440063e5ad44">掘金 - Adrenine</a></li><li><a href="https://www.jianshu.com/u/b20be2dcb0c3">简书 - Adrenine</a></li><li><a href="https://adrenine.github.io/">Blog - Adrenine</a></li><li><a href="https://github.com/Adrenine">Github - Adrenine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>目录</tag>
      
      <tag>iOS笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
